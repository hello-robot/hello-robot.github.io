{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Safety WARNING: The Stretch RE1 is a potentially dangerous robot. All users must carefully read the Stretch Safety Guide prior to using the robot. Resource Description Stretch Safety Guide Safety guide for users of the Stretch RE1 Stretch Best Practices - Powered Off Video How to work with Stretch when its power is off Stretch Best Practices - Powered On Video How to work with Stretch when its power is on Quick Start Resource Description Stretch Unboxing Video How to unpack your new Stretch Stretch Quick Start Guide Getting started - Xbox Teleoperation Demo and beyond Stretch Troubleshooting Guide Solutions to common issues Stretch Network Setup Guide to network setup for working with Stretch untethered Tutorials Resource Description Working with Robot Parameters Learn how to query, set, and manage robot parameters. Working with Dynamixel Servos Learn how to use various tools to manage Dynamixel servos Changing End of Arm Tools Learn how to configure the Stretch software interfaces to support other tools Extending the Wrist DOF Learn how to integrate additional DOF to the End of Arm Working with the Wrist Expansion Header Learn how to integrate custom hardware on to the expansion header in the wrist. Hardware Resource Description Stretch Hardware User Guide Specification and functional description of the Stretch RE1 Hardware Stretch Dex Wrist User Guide Installing, configuring, and working with the Stretch Dex Wrist Stretch Battery Maintenance Guide Guide to Care for and Charge the Stretch Batteries Stretch Tool Share Open resource to share designs and code for end-of-arm tools Software Body Interface Resource Description Stretch Body Guide Guide to the low level Python interface to the Stretch hardware Stretch Body API Reference API reference for the Stretch Body python module. Stretch Firmware Guide Guide to updating the Stretch Firmware Stretch Installation Guide Guide to installing a new user and managing the Stretch installation Stretch Factory Tools Guide to factory tools for hardware calibration and introspection ROS Interface We provide ROS-related code for the Stretch RE1 mobile manipulator, including a ROS node that interfaces to the robot, calibration code, and demonstrations of various autonomous robot capabilities. Resource Description stretch_ros repository on GitHub Repository with ROS-related code for Stretch Other Tools Resource Description Stretch Web Interface Repository with code to allow a user to operate a Stretch through a web browser Version This is version 0.1 of the Stretch User Documentation. License This documentation is only to be used for an authentic Stretch RE1 robot produced and sold by Hello Robot Inc. All Hello Robot stretch_docs related materials are released under the Creative Commons Attribution-NoDerivatives 4.0 International (CC BY-ND 4.0) license. The Stretch RE1 has patents pending.","title":"Home"},{"location":"#safety","text":"WARNING: The Stretch RE1 is a potentially dangerous robot. All users must carefully read the Stretch Safety Guide prior to using the robot. Resource Description Stretch Safety Guide Safety guide for users of the Stretch RE1 Stretch Best Practices - Powered Off Video How to work with Stretch when its power is off Stretch Best Practices - Powered On Video How to work with Stretch when its power is on","title":"Safety"},{"location":"#quick-start","text":"Resource Description Stretch Unboxing Video How to unpack your new Stretch Stretch Quick Start Guide Getting started - Xbox Teleoperation Demo and beyond Stretch Troubleshooting Guide Solutions to common issues Stretch Network Setup Guide to network setup for working with Stretch untethered","title":"Quick Start"},{"location":"#tutorials","text":"Resource Description Working with Robot Parameters Learn how to query, set, and manage robot parameters. Working with Dynamixel Servos Learn how to use various tools to manage Dynamixel servos Changing End of Arm Tools Learn how to configure the Stretch software interfaces to support other tools Extending the Wrist DOF Learn how to integrate additional DOF to the End of Arm Working with the Wrist Expansion Header Learn how to integrate custom hardware on to the expansion header in the wrist.","title":"Tutorials"},{"location":"#hardware","text":"Resource Description Stretch Hardware User Guide Specification and functional description of the Stretch RE1 Hardware Stretch Dex Wrist User Guide Installing, configuring, and working with the Stretch Dex Wrist Stretch Battery Maintenance Guide Guide to Care for and Charge the Stretch Batteries Stretch Tool Share Open resource to share designs and code for end-of-arm tools","title":"Hardware"},{"location":"#software","text":"","title":"Software"},{"location":"#body-interface","text":"Resource Description Stretch Body Guide Guide to the low level Python interface to the Stretch hardware Stretch Body API Reference API reference for the Stretch Body python module. Stretch Firmware Guide Guide to updating the Stretch Firmware Stretch Installation Guide Guide to installing a new user and managing the Stretch installation Stretch Factory Tools Guide to factory tools for hardware calibration and introspection","title":"Body Interface"},{"location":"#ros-interface","text":"We provide ROS-related code for the Stretch RE1 mobile manipulator, including a ROS node that interfaces to the robot, calibration code, and demonstrations of various autonomous robot capabilities. Resource Description stretch_ros repository on GitHub Repository with ROS-related code for Stretch","title":"ROS Interface"},{"location":"#other-tools","text":"Resource Description Stretch Web Interface Repository with code to allow a user to operate a Stretch through a web browser","title":"Other Tools"},{"location":"#version","text":"This is version 0.1 of the Stretch User Documentation.","title":"Version"},{"location":"#license","text":"This documentation is only to be used for an authentic Stretch RE1 robot produced and sold by Hello Robot Inc. All Hello Robot stretch_docs related materials are released under the Creative Commons Attribution-NoDerivatives 4.0 International (CC BY-ND 4.0) license. The Stretch RE1 has patents pending.","title":"License"},{"location":"LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains documentation exclusively for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents are licensed under the Creative Commons Attribution-NoDerivatives 4.0 International (CC BY-ND 4.0) license (the \"License\"); you may not use the Contents except in compliance with the License. You may obtain a copy of the License at https://creativecommons.org/licenses/by-nd/4.0 Unless required by applicable law or agreed to in writing, the Contents distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Patents pending and trademark rights cover the Contents. As stated by the detailed License, \"Patent and trademark rights are not licensed under this Public License.\" For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"battery_maintenance_guide/","text":"Battery Maintenance Guide - Stretch RE1 Overview Stretch RE1 utilizes two 12V AGM SLA batteries that provide a combined 18AH of capacity. Maintaining an adequate level of charge on the battery system will enhance the battery lifetime. The run time for a fully charged system is dependent on the load use case. The majority of battery power is consumed by the NUC computer as Stretch uses relatively low power motors. A fully charged robot running a high CPU load can run approximately 2 hours before requiring a recharge. Charger Stretch ships with a NOCO Genius 10 charger. Earlier versions of Stretch use the NOCO G7200. These two chargers are functionally very similar. Please review the battery charger user manuals prior to following the guidance in this document. Genius 10 Manual G7200 Manual Stretch utilizes four of the available modes on these chargers. Mode Function STANDBY Charger not charging the robot 12V AGM Charging robot powered down SUPPLY 1) Power the robot during tethered use 2) Repair damaged batteries. REPAIR Repair damaged batteries. NOCO Genius 10 - Interface Mode Procedure STANDBY Illuminates when charger not charging 12V AGM 1) From STANDBY, charger attached 2) Press MODE button repeatedly until 12V AGM indicator is illuminated SUPPLY 1) From STANDBY, charger not attached 2) Press and hold MODE button for 3s 3) Press MODE button until SUPPLY indicator is illuminated 4) Attach charger REPAIR 1) From STANDBY, charger attached 2) Press and hold MODE button for 3s 3) Press MODE button until REPAIR indicator is illuminated NOCO G7200 - Interface Mode Procedure STANDBY Illuminates when charger not charging 12V AGM 1) From STANDBY, charger attached 2) Press MODE button repeatedly until 12V AGM indicator is illuminated SUPPLY 1) From STANDBY, charger not attached 2) Press and hold MODE button for 3s 3) Press MODE button until SUPPLY indicator is illuminated 4) Attach charger REPAIR 1) From STANDBY, charger attached 2) Press and hold MODE button for 3s 3) Press MODE button until REPAIR indicator is illuminated Charging Best Practices It is possible to accidentally deeply discharge the batteries by leaving the robot on for long durations without the charger attached. This is similar to leaving the lights on your car where the battery will continue to drain until fully discharged. We recommend following the best practices below to avoid deep discharge of the batteries and to ensure they have a long lifespan. Use Case Best Practice Reason Robot is in use - tethered Leave the charger attached in SUPPLY mode while developing on the robot whenever possible. Shutdown and power off the robot when development is done. Running the robot while attempting to charge in 12V AGM mode can cause issues and is generally bad for battery health. SUPPLY mode is preferred whenever the robot needs to be powered on. Robot is in use - untethered Regularly check the battery voltage using the command line tool. Shutdown the computer and power off the robot when voltage falls below 11.5V. Attach the charger in 12V AGM mode. Charge to 100% before resuming operation. The 12V AGM charge mode expects the battery voltage to be above 10.5-11V in order to operate. Robot is not in use Shutdown the computer and turn off the robot power. Leave the charger attached and place it in 12V AGM mode. Leaving the robot power on may cause the batteries to deep discharge The charger will maintain a \u2018trickle charge\u2019 on the battery, keeping the charge at 100%. Robot is coming out of storage Attach charger in 12V AGM mode and charge for 2-3 hours until charger reports 100% SLA batteries naturally lose charge over time due to \u2018self-discharge\u2019. When To Plug in the Charger We recommend keeping the charger attached whenever the robot is not running untethered. When the battery voltage drops below \u2018low voltage\u2019 threshold the robot will produce an intermittent double beep sound. This is a reminder to the user to plug in the charger. If desired, the intermittent beep functionality can be disabled by setting the stop_at_low_voltage field in the User YAML to 0 . Troubleshooting Issue How to Diagnose Cause Corrective Procedure Robot shows no power on activity Nothing happens when you toggle on the robot\u2019s power switch. There is no visible illumination of LEDs, motion of the laser range finder, or audible noise of the robot fans. The robot fuse may have blown. When the batteries drain the current required to maintain power goes up, which can ultimately blow the fuse. Proceed to \u201cChanging the Fuse\u201d steps below Robot powers on momentarily When you toggle on the robot\u2019s power switch some activity occurs (illumination of LEDs, audible noise of robot fans, etc) but the computer fails to boot. The battery voltage is too low to maintain power. As the power draw increases during power-on, the voltage dips and causes the system to shut down. Connect the battery charger in 12V AGM mode and leave until fully charged. Battery won\u2019t charge in 12V AGM mode When the robot is powered down and the charger is connected in 12V AGM mode, the charger eventually switches to a different mode. The battery voltage is too low for the charger to function correctly in normal operation. Proceed to the \u201cRecovering from Low Battery Voltage\u201d steps below. Charger reports 100% charge but the batteries are discharged When the robot is powered down and the charger is connected in 12V AGM mode, the charger status shows 100%. However the robot fails to turn on properly. Damage to the batteries (usually caused by excessively low voltage) may artificially raise the open circuit voltage of the battery, causing the battery to appear fully charged, while providing low capacity. Proceed to the \u201cRecovering from Low Battery Voltage\u201d steps below. Charger will not charge or stay in any mode. When placed in 12V AGM, SUPPLY, or REPAIR mode, it continually reverts to STANDBY mode after ~ 20 minutes. Charger may be defective. Contact Hello Robot Support for a replacement. Recovering from Low Battery Voltage Turn off the robot power switch and detach the charger from the robot Place charger in SUPPLY Mode Allow robot to charge for 4-8 hours, or up to 24 hours for extreme discharge Switch the charger to 12V AGM mode Charge until at 100% Additional Information Powering Down the Robot The recommended power down procedure is Place a clamp on the mast below the shoulder to prevent dropping Shutdown the computer from the Desktop or via SSH When the laser range finder has stopped spinning, turn off the main power switch Replacing the Fuse Stretch RE1 has an automotive fuse inside the base that may need to be replaced. The type of fuse depends on your build version of the RE1 Build Version Fuse Type Recommended Fuse Guthrie 8A 5x20mm Fast Blow Glass Bussman S505-8-R Hank and later 7.5A ATM Fast Blow Blade Bussman VP/ATM-7-1/2-RP The fuse location is shown below. For guidance on replacing the fuse, contact Hello Robot support: support@hello-robot.com . Checking the Battery Charge The battery charger LEDs provide an approximate indicator of battery charge when it is in 12V AGM mode. Checking the Battery Voltage Battery voltage is not always an accurate indicator of battery charge but it can be a useful proxy. A charged battery will typically report a voltage of 12-12.8V and will maintain that voltage across load conditions. Meanwhile, a partially charged battery may report anywhere from 10-12.8V but its voltage will drop rapidly when loaded. Measuring Battery Voltage from the Command Line The battery voltage and current draw can be checked from the command line: $ stretch_robot_battery_check.py [Pass] Voltage with 12.9889035225 [Pass] Current with 2.46239192784 [Pass] CPU Temp with 56.0 Measuring Battery Voltage with a DMM When troubleshooting a deeply discharged battery it may be useful to directly measure the battery voltage with a digital multimeter (DMM). To do this we recommend detaching the charger cable at its inline connector and applying the DMM to the connector contacts as shown. NOTE: Caution should be taken as it is possible to short the battery when doing this. Repairing Damaged Batteries It is possible for Stretch's batteries to become damaged due to repeated deep discharge. If the robot has continued issues maintaining a charge we recommend attempting the following procedure: Turn off the robot power switch and detach the charger from the robot Place charger in SUPPLY Mode Attach the charger and allow robot to charge for 4-8 hours Place the charger in REPAIR mode Allow robot to charge until the repair cycle completes and the charger returns to standby - up to 4 hours Place the charger back in 12V AGM mode and allow batteries to charger to 100% Replacing Dead Batteries It is possible for a mechanically skilled person to replace the Stretch batteries should it be necessary . Please contact Hello Robot Support for more information (support@hello-robot.com) . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Battery Maintenance Guide - Stretch RE1"},{"location":"battery_maintenance_guide/#battery-maintenance-guide-stretch-re1","text":"","title":"Battery Maintenance Guide - Stretch RE1"},{"location":"battery_maintenance_guide/#overview","text":"Stretch RE1 utilizes two 12V AGM SLA batteries that provide a combined 18AH of capacity. Maintaining an adequate level of charge on the battery system will enhance the battery lifetime. The run time for a fully charged system is dependent on the load use case. The majority of battery power is consumed by the NUC computer as Stretch uses relatively low power motors. A fully charged robot running a high CPU load can run approximately 2 hours before requiring a recharge.","title":"Overview"},{"location":"battery_maintenance_guide/#charger","text":"Stretch ships with a NOCO Genius 10 charger. Earlier versions of Stretch use the NOCO G7200. These two chargers are functionally very similar. Please review the battery charger user manuals prior to following the guidance in this document. Genius 10 Manual G7200 Manual Stretch utilizes four of the available modes on these chargers. Mode Function STANDBY Charger not charging the robot 12V AGM Charging robot powered down SUPPLY 1) Power the robot during tethered use 2) Repair damaged batteries. REPAIR Repair damaged batteries.","title":"Charger"},{"location":"battery_maintenance_guide/#noco-genius-10-interface","text":"Mode Procedure STANDBY Illuminates when charger not charging 12V AGM 1) From STANDBY, charger attached 2) Press MODE button repeatedly until 12V AGM indicator is illuminated SUPPLY 1) From STANDBY, charger not attached 2) Press and hold MODE button for 3s 3) Press MODE button until SUPPLY indicator is illuminated 4) Attach charger REPAIR 1) From STANDBY, charger attached 2) Press and hold MODE button for 3s 3) Press MODE button until REPAIR indicator is illuminated","title":"NOCO Genius 10 - Interface"},{"location":"battery_maintenance_guide/#noco-g7200-interface","text":"Mode Procedure STANDBY Illuminates when charger not charging 12V AGM 1) From STANDBY, charger attached 2) Press MODE button repeatedly until 12V AGM indicator is illuminated SUPPLY 1) From STANDBY, charger not attached 2) Press and hold MODE button for 3s 3) Press MODE button until SUPPLY indicator is illuminated 4) Attach charger REPAIR 1) From STANDBY, charger attached 2) Press and hold MODE button for 3s 3) Press MODE button until REPAIR indicator is illuminated","title":"NOCO G7200 - Interface"},{"location":"battery_maintenance_guide/#charging-best-practices","text":"It is possible to accidentally deeply discharge the batteries by leaving the robot on for long durations without the charger attached. This is similar to leaving the lights on your car where the battery will continue to drain until fully discharged. We recommend following the best practices below to avoid deep discharge of the batteries and to ensure they have a long lifespan. Use Case Best Practice Reason Robot is in use - tethered Leave the charger attached in SUPPLY mode while developing on the robot whenever possible. Shutdown and power off the robot when development is done. Running the robot while attempting to charge in 12V AGM mode can cause issues and is generally bad for battery health. SUPPLY mode is preferred whenever the robot needs to be powered on. Robot is in use - untethered Regularly check the battery voltage using the command line tool. Shutdown the computer and power off the robot when voltage falls below 11.5V. Attach the charger in 12V AGM mode. Charge to 100% before resuming operation. The 12V AGM charge mode expects the battery voltage to be above 10.5-11V in order to operate. Robot is not in use Shutdown the computer and turn off the robot power. Leave the charger attached and place it in 12V AGM mode. Leaving the robot power on may cause the batteries to deep discharge The charger will maintain a \u2018trickle charge\u2019 on the battery, keeping the charge at 100%. Robot is coming out of storage Attach charger in 12V AGM mode and charge for 2-3 hours until charger reports 100% SLA batteries naturally lose charge over time due to \u2018self-discharge\u2019.","title":"Charging Best Practices"},{"location":"battery_maintenance_guide/#when-to-plug-in-the-charger","text":"We recommend keeping the charger attached whenever the robot is not running untethered. When the battery voltage drops below \u2018low voltage\u2019 threshold the robot will produce an intermittent double beep sound. This is a reminder to the user to plug in the charger. If desired, the intermittent beep functionality can be disabled by setting the stop_at_low_voltage field in the User YAML to 0 .","title":"When To Plug in the Charger"},{"location":"battery_maintenance_guide/#troubleshooting","text":"Issue How to Diagnose Cause Corrective Procedure Robot shows no power on activity Nothing happens when you toggle on the robot\u2019s power switch. There is no visible illumination of LEDs, motion of the laser range finder, or audible noise of the robot fans. The robot fuse may have blown. When the batteries drain the current required to maintain power goes up, which can ultimately blow the fuse. Proceed to \u201cChanging the Fuse\u201d steps below Robot powers on momentarily When you toggle on the robot\u2019s power switch some activity occurs (illumination of LEDs, audible noise of robot fans, etc) but the computer fails to boot. The battery voltage is too low to maintain power. As the power draw increases during power-on, the voltage dips and causes the system to shut down. Connect the battery charger in 12V AGM mode and leave until fully charged. Battery won\u2019t charge in 12V AGM mode When the robot is powered down and the charger is connected in 12V AGM mode, the charger eventually switches to a different mode. The battery voltage is too low for the charger to function correctly in normal operation. Proceed to the \u201cRecovering from Low Battery Voltage\u201d steps below. Charger reports 100% charge but the batteries are discharged When the robot is powered down and the charger is connected in 12V AGM mode, the charger status shows 100%. However the robot fails to turn on properly. Damage to the batteries (usually caused by excessively low voltage) may artificially raise the open circuit voltage of the battery, causing the battery to appear fully charged, while providing low capacity. Proceed to the \u201cRecovering from Low Battery Voltage\u201d steps below. Charger will not charge or stay in any mode. When placed in 12V AGM, SUPPLY, or REPAIR mode, it continually reverts to STANDBY mode after ~ 20 minutes. Charger may be defective. Contact Hello Robot Support for a replacement.","title":"Troubleshooting"},{"location":"battery_maintenance_guide/#recovering-from-low-battery-voltage","text":"Turn off the robot power switch and detach the charger from the robot Place charger in SUPPLY Mode Allow robot to charge for 4-8 hours, or up to 24 hours for extreme discharge Switch the charger to 12V AGM mode Charge until at 100%","title":"Recovering from Low Battery Voltage"},{"location":"battery_maintenance_guide/#additional-information","text":"","title":"Additional Information"},{"location":"battery_maintenance_guide/#powering-down-the-robot","text":"The recommended power down procedure is Place a clamp on the mast below the shoulder to prevent dropping Shutdown the computer from the Desktop or via SSH When the laser range finder has stopped spinning, turn off the main power switch","title":"Powering Down the Robot"},{"location":"battery_maintenance_guide/#replacing-the-fuse","text":"Stretch RE1 has an automotive fuse inside the base that may need to be replaced. The type of fuse depends on your build version of the RE1 Build Version Fuse Type Recommended Fuse Guthrie 8A 5x20mm Fast Blow Glass Bussman S505-8-R Hank and later 7.5A ATM Fast Blow Blade Bussman VP/ATM-7-1/2-RP The fuse location is shown below. For guidance on replacing the fuse, contact Hello Robot support: support@hello-robot.com .","title":"Replacing the Fuse"},{"location":"battery_maintenance_guide/#checking-the-battery-charge","text":"The battery charger LEDs provide an approximate indicator of battery charge when it is in 12V AGM mode.","title":"Checking the Battery Charge"},{"location":"battery_maintenance_guide/#checking-the-battery-voltage","text":"Battery voltage is not always an accurate indicator of battery charge but it can be a useful proxy. A charged battery will typically report a voltage of 12-12.8V and will maintain that voltage across load conditions. Meanwhile, a partially charged battery may report anywhere from 10-12.8V but its voltage will drop rapidly when loaded. Measuring Battery Voltage from the Command Line The battery voltage and current draw can be checked from the command line: $ stretch_robot_battery_check.py [Pass] Voltage with 12.9889035225 [Pass] Current with 2.46239192784 [Pass] CPU Temp with 56.0 Measuring Battery Voltage with a DMM When troubleshooting a deeply discharged battery it may be useful to directly measure the battery voltage with a digital multimeter (DMM). To do this we recommend detaching the charger cable at its inline connector and applying the DMM to the connector contacts as shown. NOTE: Caution should be taken as it is possible to short the battery when doing this.","title":"Checking the Battery Voltage"},{"location":"battery_maintenance_guide/#repairing-damaged-batteries","text":"It is possible for Stretch's batteries to become damaged due to repeated deep discharge. If the robot has continued issues maintaining a charge we recommend attempting the following procedure: Turn off the robot power switch and detach the charger from the robot Place charger in SUPPLY Mode Attach the charger and allow robot to charge for 4-8 hours Place the charger in REPAIR mode Allow robot to charge until the repair cycle completes and the charger returns to standby - up to 4 hours Place the charger back in 12V AGM mode and allow batteries to charger to 100%","title":"Repairing Damaged Batteries"},{"location":"battery_maintenance_guide/#replacing-dead-batteries","text":"It is possible for a mechanically skilled person to replace the Stretch batteries should it be necessary . Please contact Hello Robot Support for more information (support@hello-robot.com) . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Replacing Dead Batteries"},{"location":"dex_wrist_user_guide/","text":"Stretch RE1: Dex Wrist User Guide In this guide, we will cover the installation, configuration, and use of the Stretch Dex Wrist. Overview The Stretch Dex Wrist is an optional add-on to the RE1. It adds pitch and roll degrees of freedom to the standard wrist yaw joint. It also includes a slightly modified version of the standard Stretch Compliant Gripper. NOTE: If your robot did not ship with the Stretch Dex Wrist pre-installed you will want to first proceed to the Appendix: Installation and Configuration at the end of this guide. Functional Specification Working with the Dex Wrist Safe Use The Dex Wrist requires added attention to safety. Its additional dexterity introduces new pinch points around the wrist pitch and roll degrees of freedom. NOTE: Please review the Robot Safety Guide prior to working with the Dex Wrist. In addition to these precautions, the Dex Wrist requires attention to pinch points between: The wrist pitch and wrist yaw structures during yaw motion The gripper and wrist pitch structures during pitch motion The Dex Wrist includes a pinch point safety marking as a reminder to users: Avoiding Collisions The added dexterity of the Dex Wrist introduces new opportunities for self-collision between the robot tool and the robot. These include Running the tool into the base during lift downward motion Running the tool into the ground Running the tool into the wrist yaw structure We recommend becoming familiar with the potential collision points of the Dex Wrist by commanding careful motions through the stretch_xbox_controller_teleop.py tool. With Stretch Body v0.1.0 we introduce a simple collision avoidance controller . The collision avoidance behavior acts to dynamically set the robot joint limits according to simple models of its kinematic state. The avoidance behavior is defined in collision_model.py For performance reasons this collision avoidance behavior is coarse and does not prevent all self-collisions and considered 'experimental'. The collision avoidance is off by default for the standard Stretch RE1. For robots with the wrist we turn it on by default. It be turned on or off by modifying the following in your user YAML: robot : use_collision_manager : 1 XBox Teleoperation The Dex Wrist can be teleoperated using the XBox controller. When the Dex Wrist is installed the stretch_xbox_controller_teleop.py tool will automatically remap control of the pan-tilt head to control of the pitch-roll wrist. $ stretch_xbox_controller_teleop.py The new key mapping is shown below. A printable version is available here . Stretch Body Interface The new WristPitch and WristRoll joints are accessed from Stretch Body in the same manner as the WristYaw joint. Control of the Stretch Dex Wrist uses the same interfaces as the rest of the Stretch Body Robot joints. For example: import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () #Move arm to safe manipulation location robot . stow () robot . lift . move_to ( 0.4 ) robot . push_command () time . sleep ( 2.0 ) #Pose the Dex Wrist robot . end_of_arm . move_to ( 'wrist_yaw' , 0 ) robot . end_of_arm . move_to ( 'wrist_pitch' , 0 ) robot . end_of_arm . move_to ( 'wrist_roll' , 0 ) robot . end_of_arm . move_to ( 'stretch_gripper' , 50 ) time . sleep ( 2.0 ) #Go back to stow and shutdown robot . stow () robot . stop () You can jog the individual joints of the wrist with the Stretch Body interface using the stretch_dex_wrist_jog.py tool that installs with the Stretch Tool Share: $ stretch_dex_wrist_jog.py --pitch $ stretch_dex_wrist_jog.py --yaw $ stretch_dex_wrist_jog.py --roll For reference, the parameters for the Stretch Dex Wrist (which can be overridden in the user YAML) can be seen in params.py . Stretch ROS Interface The Dex Wrist can be controlled via ROS as well, as shown in the keyboard teleoperation code . To test the interface: $ roslaunch stretch_calibration simple_test_head_calibration.launch You can use Ctrl-C to exit when done. The menu interface is: ---------- KEYBOARD TELEOP MENU ----------- i HEAD UP j HEAD LEFT l HEAD RIGHT , HEAD DOWN 7 BASE ROTATE LEFT 9 BASE ROTATE RIGHT home page-up 8 LIFT UP up-arrow 4 BASE FORWARD 6 BASE BACK left-arrow right-arrow 2 LIFT DOWN down-arrow w ARM OUT a WRIST FORWARD d WRIST BACK x ARM IN c PITCH FORWARD v PITCH BACK o ROLL FORWARD p ROLL BACK 5 GRIPPER CLOSE 0 GRIPPER OPEN step size: b BIG, m MEDIUM, s SMALL q QUIT ------------------------------------------- Appendix: Installation and Configuration Robots that did not ship with the Dex Wrist installed will require additional hardware and software installation. Production Batch Variation Earlier production 'batches' of Stretch will require a hardware upgrade prior to use the Dex Wrist. To check your robot's batch, run: $ stretch_about.py Refer to this table to determine what changes are required for your robot. Batch Name Upgrade Wacc Board Update Baud Rate Guthrie Y Y Hank Y Y Irma Y Y Joplin N Y Kendrick or later N N Upgrade Wacc Board If your robot requires a Wacc Board upgrade please follow the instructions here with the assistance of Hello Robot support. This must be done before attaching the Dex Wrist to our robot. Update Baud Rate The new wrist requires moving to 115200 Baud communication for all Dynamixel servos from the previous 57600. Use the commands below. $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-head 11 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-head 12 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-wrist 13 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud Attaching the Dex Wrist Power down your Stretch before installing the Dex Wrist. The Dex Wrist mounts to the bottom of the Stretch Wrist Tool Plate . Installation requires 8 M2x6mm Torx FHCS bolts (provided) 4 M2.5x4mm Torx FHCS bolts (provided) 2 M2.5x8mm SHCS bolts (provided) T6 Torx wrench (provided) T8 Torx wrench (provided) 2mm Hex key (provided) First, remove the standard Stretch Gripper if it is still attached according to the Hardware User Guide . Mounting Bracket Note where the forward direction is on the wrist yaw tool plate. The forward direction is indicated by the additional alignment hole that is just outside the bolt pattern (shown pointing down in the image) Using the T6 Torx wrench, attach the wrist mount bracket (A) to the bottom of the tool plate using the provided M2x6mm bolts (B). NOTE: ensure that the forward direction of the bracket (also indicated by an alignment hole) matches the forward direction of the tool plate. Now route the Dynamixel cable coming from the Stretch Wrist Yaw through the hollow bore of the wrist yaw joint. NOTE: During this step ensure the Dynamixel cable from the wrist yaw exits out the back (towards the shoulder) Next, raise the wrist module up vertically into the mounting bracket , then sliding it over horizontally so that the bearing mates onto its post. Now rotate the wrist yaw joint so the wrist pitch servo body is accessible. Attach the pitch servo to the mounting bracket using the 4 M2.5x4mm screws (C) using the T8 Torx wrench. Finally, route the Dynamixel cable into the wrist pitch servo (pink) and install the cable clip (D) using the M2.5x8mm bolts and the 2mm hex wrench. Software Configuration Robots that did not ship with the Dex Wrist pre-installed will require their software to be updated and configured. NOTE: Each user account on the robot will need to run the following steps to configure the Dex Wrist. Upgrade Stretch Body Ensure the latest version of Stretch Body and Stretch Factory are installed $ pip2 install hello-robot-stretch-body -U --no-cache-dir $ pip2 install hello-robot-stretch-body-tools -U --no-cache-dir $ pip2 install hello-robot-stretch-factory -U --no-cache-dir $ pip2 install hello-robot-stretch-tool-share -U --no-cache-dir Backup User YAML $ cd $HELLO_FLEET_PATH / $HELLO_FLEET_ID $ cp stretch_re1_user_params.yaml stretch_re1_user_params.yaml.bak Run Installation Script $ cd ~/repos $ git clone https://github.com/hello-robot/stretch_install $ cd ./stretch_install $ git pull $ ./factory/stretch_install_dex_wrist.sh NOTE: The factory gripper calibration may not provide the full range of motion in some cases. If necessary you can dial in the gripper calibration with the tool RE1_gripper_calibrate.py All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch RE1: Dex Wrist User Guide"},{"location":"dex_wrist_user_guide/#stretch-re1-dex-wrist-user-guide","text":"In this guide, we will cover the installation, configuration, and use of the Stretch Dex Wrist.","title":"Stretch RE1: Dex Wrist User Guide"},{"location":"dex_wrist_user_guide/#overview","text":"The Stretch Dex Wrist is an optional add-on to the RE1. It adds pitch and roll degrees of freedom to the standard wrist yaw joint. It also includes a slightly modified version of the standard Stretch Compliant Gripper. NOTE: If your robot did not ship with the Stretch Dex Wrist pre-installed you will want to first proceed to the Appendix: Installation and Configuration at the end of this guide.","title":"Overview"},{"location":"dex_wrist_user_guide/#functional-specification","text":"","title":"Functional Specification"},{"location":"dex_wrist_user_guide/#working-with-the-dex-wrist","text":"","title":"Working with the Dex Wrist"},{"location":"dex_wrist_user_guide/#safe-use","text":"The Dex Wrist requires added attention to safety. Its additional dexterity introduces new pinch points around the wrist pitch and roll degrees of freedom. NOTE: Please review the Robot Safety Guide prior to working with the Dex Wrist. In addition to these precautions, the Dex Wrist requires attention to pinch points between: The wrist pitch and wrist yaw structures during yaw motion The gripper and wrist pitch structures during pitch motion The Dex Wrist includes a pinch point safety marking as a reminder to users:","title":"Safe Use"},{"location":"dex_wrist_user_guide/#avoiding-collisions","text":"The added dexterity of the Dex Wrist introduces new opportunities for self-collision between the robot tool and the robot. These include Running the tool into the base during lift downward motion Running the tool into the ground Running the tool into the wrist yaw structure We recommend becoming familiar with the potential collision points of the Dex Wrist by commanding careful motions through the stretch_xbox_controller_teleop.py tool. With Stretch Body v0.1.0 we introduce a simple collision avoidance controller . The collision avoidance behavior acts to dynamically set the robot joint limits according to simple models of its kinematic state. The avoidance behavior is defined in collision_model.py For performance reasons this collision avoidance behavior is coarse and does not prevent all self-collisions and considered 'experimental'. The collision avoidance is off by default for the standard Stretch RE1. For robots with the wrist we turn it on by default. It be turned on or off by modifying the following in your user YAML: robot : use_collision_manager : 1","title":"Avoiding Collisions"},{"location":"dex_wrist_user_guide/#xbox-teleoperation","text":"The Dex Wrist can be teleoperated using the XBox controller. When the Dex Wrist is installed the stretch_xbox_controller_teleop.py tool will automatically remap control of the pan-tilt head to control of the pitch-roll wrist. $ stretch_xbox_controller_teleop.py The new key mapping is shown below. A printable version is available here .","title":"XBox Teleoperation"},{"location":"dex_wrist_user_guide/#stretch-body-interface","text":"The new WristPitch and WristRoll joints are accessed from Stretch Body in the same manner as the WristYaw joint. Control of the Stretch Dex Wrist uses the same interfaces as the rest of the Stretch Body Robot joints. For example: import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () #Move arm to safe manipulation location robot . stow () robot . lift . move_to ( 0.4 ) robot . push_command () time . sleep ( 2.0 ) #Pose the Dex Wrist robot . end_of_arm . move_to ( 'wrist_yaw' , 0 ) robot . end_of_arm . move_to ( 'wrist_pitch' , 0 ) robot . end_of_arm . move_to ( 'wrist_roll' , 0 ) robot . end_of_arm . move_to ( 'stretch_gripper' , 50 ) time . sleep ( 2.0 ) #Go back to stow and shutdown robot . stow () robot . stop () You can jog the individual joints of the wrist with the Stretch Body interface using the stretch_dex_wrist_jog.py tool that installs with the Stretch Tool Share: $ stretch_dex_wrist_jog.py --pitch $ stretch_dex_wrist_jog.py --yaw $ stretch_dex_wrist_jog.py --roll For reference, the parameters for the Stretch Dex Wrist (which can be overridden in the user YAML) can be seen in params.py .","title":"Stretch Body Interface"},{"location":"dex_wrist_user_guide/#stretch-ros-interface","text":"The Dex Wrist can be controlled via ROS as well, as shown in the keyboard teleoperation code . To test the interface: $ roslaunch stretch_calibration simple_test_head_calibration.launch You can use Ctrl-C to exit when done. The menu interface is: ---------- KEYBOARD TELEOP MENU ----------- i HEAD UP j HEAD LEFT l HEAD RIGHT , HEAD DOWN 7 BASE ROTATE LEFT 9 BASE ROTATE RIGHT home page-up 8 LIFT UP up-arrow 4 BASE FORWARD 6 BASE BACK left-arrow right-arrow 2 LIFT DOWN down-arrow w ARM OUT a WRIST FORWARD d WRIST BACK x ARM IN c PITCH FORWARD v PITCH BACK o ROLL FORWARD p ROLL BACK 5 GRIPPER CLOSE 0 GRIPPER OPEN step size: b BIG, m MEDIUM, s SMALL q QUIT -------------------------------------------","title":"Stretch ROS Interface"},{"location":"dex_wrist_user_guide/#appendix-installation-and-configuration","text":"Robots that did not ship with the Dex Wrist installed will require additional hardware and software installation.","title":"Appendix: Installation and Configuration"},{"location":"dex_wrist_user_guide/#production-batch-variation","text":"Earlier production 'batches' of Stretch will require a hardware upgrade prior to use the Dex Wrist. To check your robot's batch, run: $ stretch_about.py Refer to this table to determine what changes are required for your robot. Batch Name Upgrade Wacc Board Update Baud Rate Guthrie Y Y Hank Y Y Irma Y Y Joplin N Y Kendrick or later N N","title":"Production Batch Variation"},{"location":"dex_wrist_user_guide/#upgrade-wacc-board","text":"If your robot requires a Wacc Board upgrade please follow the instructions here with the assistance of Hello Robot support. This must be done before attaching the Dex Wrist to our robot.","title":"Upgrade Wacc Board"},{"location":"dex_wrist_user_guide/#update-baud-rate","text":"The new wrist requires moving to 115200 Baud communication for all Dynamixel servos from the previous 57600. Use the commands below. $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-head 11 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-head 12 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-wrist 13 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud","title":"Update Baud Rate"},{"location":"dex_wrist_user_guide/#attaching-the-dex-wrist","text":"Power down your Stretch before installing the Dex Wrist. The Dex Wrist mounts to the bottom of the Stretch Wrist Tool Plate . Installation requires 8 M2x6mm Torx FHCS bolts (provided) 4 M2.5x4mm Torx FHCS bolts (provided) 2 M2.5x8mm SHCS bolts (provided) T6 Torx wrench (provided) T8 Torx wrench (provided) 2mm Hex key (provided) First, remove the standard Stretch Gripper if it is still attached according to the Hardware User Guide .","title":"Attaching the Dex Wrist"},{"location":"dex_wrist_user_guide/#mounting-bracket","text":"Note where the forward direction is on the wrist yaw tool plate. The forward direction is indicated by the additional alignment hole that is just outside the bolt pattern (shown pointing down in the image) Using the T6 Torx wrench, attach the wrist mount bracket (A) to the bottom of the tool plate using the provided M2x6mm bolts (B). NOTE: ensure that the forward direction of the bracket (also indicated by an alignment hole) matches the forward direction of the tool plate. Now route the Dynamixel cable coming from the Stretch Wrist Yaw through the hollow bore of the wrist yaw joint. NOTE: During this step ensure the Dynamixel cable from the wrist yaw exits out the back (towards the shoulder) Next, raise the wrist module up vertically into the mounting bracket , then sliding it over horizontally so that the bearing mates onto its post. Now rotate the wrist yaw joint so the wrist pitch servo body is accessible. Attach the pitch servo to the mounting bracket using the 4 M2.5x4mm screws (C) using the T8 Torx wrench. Finally, route the Dynamixel cable into the wrist pitch servo (pink) and install the cable clip (D) using the M2.5x8mm bolts and the 2mm hex wrench.","title":"Mounting Bracket"},{"location":"dex_wrist_user_guide/#software-configuration","text":"Robots that did not ship with the Dex Wrist pre-installed will require their software to be updated and configured. NOTE: Each user account on the robot will need to run the following steps to configure the Dex Wrist.","title":"Software Configuration"},{"location":"dex_wrist_user_guide/#upgrade-stretch-body","text":"Ensure the latest version of Stretch Body and Stretch Factory are installed $ pip2 install hello-robot-stretch-body -U --no-cache-dir $ pip2 install hello-robot-stretch-body-tools -U --no-cache-dir $ pip2 install hello-robot-stretch-factory -U --no-cache-dir $ pip2 install hello-robot-stretch-tool-share -U --no-cache-dir","title":"Upgrade Stretch Body"},{"location":"dex_wrist_user_guide/#backup-user-yaml","text":"$ cd $HELLO_FLEET_PATH / $HELLO_FLEET_ID $ cp stretch_re1_user_params.yaml stretch_re1_user_params.yaml.bak","title":"Backup User YAML"},{"location":"dex_wrist_user_guide/#run-installation-script","text":"$ cd ~/repos $ git clone https://github.com/hello-robot/stretch_install $ cd ./stretch_install $ git pull $ ./factory/stretch_install_dex_wrist.sh NOTE: The factory gripper calibration may not provide the full range of motion in some cases. If necessary you can dial in the gripper calibration with the tool RE1_gripper_calibrate.py All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Run Installation Script"},{"location":"hardware_user_guide/","text":"Hardware User Guide This manual provides the engineering data and user guidance for working with the Hello Robot Stretch RE1 hardware. Disclaimer The Hello Robot Stretch Robot is intended for use in the research of mobile manipulation applications by users experienced in the use and programming of research robots. This product is not intended for general use in the home by consumers, and lacks the required certifications for such use. Please see the section on Regulatory Compliance for further details. Functional Specification Body Plan Hardware Architecture Robot Subsystems Base The base is a two wheel differential drive with a passive Mecanum wheel for a caster. It includes four cliff sensors to allow detection of stairs, thresholds, etc. Item Notes A Drive wheels 4 inch diameter, urethane rubber shore 60A B Cliff sensors Sharp GP2Y0A51SK0F, Analog, range 2-15 cm C Mecanum wheel Diameter 50mm The base has 6 M4 threaded inserts available for mounting user accessories such as a tray. The mounting pattern is shown below. The inserts are recessed 1mm from the top of the base shell. Base IMU The base has a 9 DOF IMU using the 9 DOF FXOS8700 + FXAS21002 chipset. The IMU orientation is as shown below: Trunk Development and charge ports are at the back of the base in the trunk. The trunk cover slides into place vertically and is non-latching. The trunk height has been designed to accommodate one or more USB based Intel Neural Compute Sticks. Two mounting holes are provided inside the trunk. These allow the user to strain relief tethered cables (eg, HDMI and keyboard) during development. It is recommended to strain relief such cables to prevent accidental damage during base motion. Item Notes A Vent Intake vent for computer fan B 6 Port USB Hub USB 3.0 , powered 5V/3A C Ethernet Connected to computer NIC D On/Off Robot power on / off. Switch is illuminated when on. E Charge Rated for upplied 12V/7A charger F HDMI Connected to computer HDMI G Mounting points M4 threaded holes Head The head provides the audio interface to the robot, a pan tilt depth camera, a runstop, as well as a developer interface to allow the addition of additional user hardware. Item Notes A Pan tilt depth camera Intel RealSense D435i Two Dynamixel XL430-W250-T servos B Speakers C Mounting holes 2x M4 threaded, spacing 25mm D Developer Interface USB2.0-A with 5V@500mA fused JST XHP-2, 12V@3A fused Pin 1: 12V Pin 2: GND E Microphone array With programmable 12 RGB LED ring F Runstop G Audio volume control Pan Tilt The head pan-tilt unit utilizes two Dynamixel XL430-W250-T servos. It incorporates a small fan in order to ensure proper cooling of the servo and camera during dynamic repeated motions of the tilt DOF. The nominal \u2018zero\u2019 position is of the head is shown below, along with the corresponding range of motion. DOF Range (deg) Min(deg) Max (deg) Pan 346 -234 112 Tilt 115 -25 90 ReSpeaker Microphone Array The ReSPeaker has 12 RGB LEDs that can be controlled programatically. By default they display sound intensity and direction of the microphone array. The ReSpeaker has 4 mems microphones mounted on a 64.61mm circle at 45 degree spacing. The drawing below shows the position and orientation of the microphone array relative to the head pan axis. Runstop The runstop allows the user to pause the motion of the four primary DOF (base, lift, and arm) by tapping the illuminated button on the head. When the runstop is enabled, these DOF are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume. Lift The lift degree of freedom provides vertical translation of the arm. It is driven by a closed loop stepper motor, providing smooth and precise motion through a low gear-ratio belt drive. The \u2018shoulder\u2019 includes two mounting holes and a small delivery tray. Item Notes A Delivery tray B Mounting holes Threaded M4. Spacing 34.5 mm. C Aruco Tag Size 40x40 mm Arm The arm comprises 5 telescoping carbon fiber links set on rollers. Its proprietary drive train is driven by a stepper motor with closed loop control and current sensing, allowing contact sensitivity during motion. The arm exhibits a small amount of play (lash) in the X, Y, Z, and theta directions which is a normal characteristic of its design. Despite this it can achieve good repeatability, in part because its gravity loading is fairly constant. The retracted arm and wrist combined are designed to fit within the footprint of the base. The arm is designed to have: Reach: 0.52m Wrist The wrist includes: Yaw DOF to allow for stowing of the tool 2 Aruco tags for calibration and visual localization of the tool Expansion port with Arduino expansion header USB-A connector Tool plate with dual sided mounting Dynamixel X-Series TTL bus Wrist Control Interface The wrist yaw degree-of-freedom uses a Dynamixel XL430 servo . Additional Dynamixel servos can be daisy chained off of this servo, allowing for one more additional degree-of-freedoms to be easily integrated onto the robot (such as the provided Stretch Gripper). Stretch comes with a XL430 compatible control cable preinstalled into this servo. If a different cable needs to be installed the servo cap can be removed as shown. Wrist Tool Plate The tool plate allows for mounting on the top or the bottom using the M2 bolt pattern. The mounting pattern is compatible with Robotis Dynamixel frames as well: FR12-H101K FR12-S102K FR12-S101K Wrist Yaw Range of Motion The wrist yaw DOF is calibrated so that the index hole faces forward at the 'zero' position. From this pose the wrist has a ROM of +256/-76 degrees as shown. Wrist Accelerometer The wrist includes a 3 axis ADXL343 accelerometer which provides bump and tap detection capabilities. The sensor is mounted inside the distal link of the arm as shown below. Wrist Expansion USB The wrist includes a USB 2.0 A interface. This power to this USB port is fused to 500mA@5V. Wrist Expansion Header The wrist includes an expansion header that provides access to pins of the wrist Arduino board. The header connector can be accessed by removing the cap at the end of the arm. The header is wired to a Atmel SAMD21G18A-AUT ( datasheet ) microcontroller (same as Arduino Zero). The expansion header pins are configured at the factory to allow: General purpose digital I/O Analog input In addition, the firmware can be configured for other pin functions, including: Serial SPI Serial I2C Serial UART The Stretch Firmware Manual covers this modification. The header pins utilize 3V3 TTL logic. They do not have interface protection (eg, ESD, over-voltage, shorts). It is possible to damage your robot if pin specifications are exceeded The pin mapping is: Pin Name Function Factory Firmware 1 DGND Digital ground 2 3V3 3.3V supply fused at 250mA. 3 E12V 12VDC fused at 500mA 4 SS DIO | SPI SS Digital out (D3) 5 SCK DIO | SPI SCK Digital out (D2) 6 MISO DIO | SPI MISO |UART TX Digital in (D0) 7 MOSI DIO | SPI MOSI | UART RX Digital in (D1) 8 SCL DIO | I2C SCL Not used 9 SS DIO | I2C SDA Not used 10 ANA0 Analog input Analog in (A0) The expansion DIO uses a 10 pin JST header B10B-PHDSS(LF)(SN) . It is compatible with a JST PHDR-10VS housing. JST provides pre-crimped wire compatible with this housing ( part APAPA22K305 ). Pin 1 & 10 are indicated below. The expansion DIO schematic shown below. Wrist Mounts Gripper The Stretch Compliant Gripper utilizes a Dynamixel XL430-W250-T servo to drive the spring grasper mechanism. The kinematics of the grasper mechanism are complex and non-linear relative to the motor position. As shown, it includes mounting features on one side to allow for attachment of simple rigid tools such as hooks and pullers . Item Notes A Stud attachment Threaded 6-32 B Thread attahcment Threaded M4 The attachment features are spaced at 9mm. The weight of the Stretch Compliant Gripper is 240g. Gripper Removal Here we describe removing the Stretch Compliant gripper. Installation is simply these steps in reverse. Unplug the Dynamixel cable from the back of the gripper. Remove the 4 screws holding the gripper to the bracket. Remove the gripper from the mounting bracket Unscrew the 8 screws holding the mounting bracket to the bottom of the tool plate. Robot Care Battery Maintenance Please review the Battery Maintenance Guide for proper care and charging of the Stretch batteries. Belt Tension A neoprene timing belt drives the arm up and down the lift. It may detension over long periods of time if it experiences sustained loading. In this case, slack will become visually apparent in the belt as the lift moves. The belt is very straightforward to re-tension. Please contact support@hello-robot.com for tensioning instructions. Keeping the Robot Clean The robot surfaces can be wiped down with an alcohol wipe or a moist rag from time to time in order to remove and debris or oils that accumulate on the shells or mast. The drive wheels can accumulate dust over time and begin to lose traction. They should be periodically wiped down as well. When possible, the Trunk cover for the base should be kept on in order to keep dust and debris out of the Trunk connectors. If the D435i camera requires cleaning use appropriate lens cleaning fluid and a microfiber cloth. Keeping the Robot Calibrated The robot comes pre-calibrated with a robot-specific URDF. This calibration allows the D435i depth sensor to accurately estimate where the robot wrist, and body, is in the depth image. The robot may become slightly uncalibrated over time for a variety of reasons: Normal wear and tear and loosening of joints of the robot The head structure is accidentally load and the structure becomes very slightly bent The wrist and should structure become accidentally highly loaded and become slightly bent The calibration accuracy can be checked using the provided ROS tools. If necessary, the user can recalibrate the robot. See the Stretch URDF Calibration Guide for more information. Transporting the Robot Stretch was designed to be easily transported in the back of a car, up a stair case, or around a building. For short trips, the robot can be simply rolled around by grabbing its mast. It may be picked up by its mast and carried up stairs as well. For safety, please use two people to lift the robot. For longer trips it is recommended to transport the robot in its original cardboard box with foam packaging. The metal protective cage that surrounds the head is only necessary if the robot might be shipped and the box will not remain upright. System Check It is useful to periodically run stretch_robot_system_check.py. This will check that the robot's hardware devices are present and within normal operating conditions. $ stretch_robot_system_check.py ---- Checking Devices ---- [Pass] : hello-wacc [Pass] : hello-motor-left-wheel [Pass] : hello-motor-arm [Pass] : hello-dynamixel-wrist [Pass] : hello-motor-right-wheel [Pass] : hello-motor-lift [Pass] : hello-pimu [Pass] : hello-respeaker [Pass] : hello-lrf [Pass] : hello-dynamixel-head ---- Checking Pimu ---- [Pass] Voltage = 12.8763639927 [Pass] Current = 3.25908634593 [Pass] Temperature = 36.3404559783 [Pass] Cliff-0 = -4.72064208984 [Pass] Cliff-1 = -8.56213378906 [Pass] Cliff-2 = 1.08505249023 [Pass] Cliff-3 = 5.68453979492 [Pass] IMU AZ = -9.80407142639 ---- Checking EndOfArm ---- [Dynamixel ID:013] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: wrist_yaw [Pass] Calibrated: wrist_yaw [Dynamixel ID:014] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: stretch_gripper [Pass] Calibrated: stretch_gripper ---- Checking Head ---- [Dynamixel ID:012] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_tilt [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_pan ---- Checking Wacc ---- [Pass] AX = 9.4840593338 ---- Checking hello-motor-left-wheel ---- [Pass] Position = 43.9992256165 ---- Checking hello-motor-right-wheel ---- [Pass] Position = 15.1164712906 ---- Checking hello-motor-arm ---- [Pass] Position = 59.7719421387 [Pass] Position Calibrated = True ---- Checking hello-motor-lift ---- [Pass] Position = 83.7744064331 [Pass] Position Calibrated = True ---- Checking for Intel D435i ---- Bus 002 Device 016: ID 8086:0b3a Intel Corp. [Pass] : Device found Regulatory Compliance The Stretch Research Edition 1 (Stretch RE1) is not certified for use as a consumer device in the U.S. Unless stated otherwise, the Stretch RE1 is not subjected to compliance testing nor certified to meet any requirements, such as requirements for EMI, EMC, or ESD. Per FCC 47 CFR, Part 15, Subpart B, section 15.103(c) , we claim the Stretch Research Edition 1 as an exempted device, since it is a digital device used exclusively as industrial, commercial, or medical test equipment, where test equipment is equipment intended primarily for purposes of performing scientific investigations. OET BULLETIN NO. 62 , titled \"UNDERSTANDING THE FCC REGULATIONS FOR COMPUTERS AND OTHER DIGITAL DEVICES\" from December 1993 provides further clarification of the Section 15.103(c) exemption: \u201c Test equipment includes devices used for maintenance, research, evaluation, simulation and other analytical or scientific applications in areas such as industrial plants, public utilities, hospitals, universities, laboratories, automotive service centers and electronic repair shops.\u201d All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Hardware User Guide"},{"location":"hardware_user_guide/#hardware-user-guide","text":"This manual provides the engineering data and user guidance for working with the Hello Robot Stretch RE1 hardware.","title":"Hardware User Guide"},{"location":"hardware_user_guide/#disclaimer","text":"The Hello Robot Stretch Robot is intended for use in the research of mobile manipulation applications by users experienced in the use and programming of research robots. This product is not intended for general use in the home by consumers, and lacks the required certifications for such use. Please see the section on Regulatory Compliance for further details.","title":"Disclaimer"},{"location":"hardware_user_guide/#functional-specification","text":"","title":"Functional Specification"},{"location":"hardware_user_guide/#body-plan","text":"","title":"Body Plan"},{"location":"hardware_user_guide/#hardware-architecture","text":"","title":"Hardware Architecture"},{"location":"hardware_user_guide/#robot-subsystems","text":"","title":"Robot Subsystems"},{"location":"hardware_user_guide/#base","text":"The base is a two wheel differential drive with a passive Mecanum wheel for a caster. It includes four cliff sensors to allow detection of stairs, thresholds, etc. Item Notes A Drive wheels 4 inch diameter, urethane rubber shore 60A B Cliff sensors Sharp GP2Y0A51SK0F, Analog, range 2-15 cm C Mecanum wheel Diameter 50mm The base has 6 M4 threaded inserts available for mounting user accessories such as a tray. The mounting pattern is shown below. The inserts are recessed 1mm from the top of the base shell.","title":"Base"},{"location":"hardware_user_guide/#base-imu","text":"The base has a 9 DOF IMU using the 9 DOF FXOS8700 + FXAS21002 chipset. The IMU orientation is as shown below:","title":"Base IMU"},{"location":"hardware_user_guide/#trunk","text":"Development and charge ports are at the back of the base in the trunk. The trunk cover slides into place vertically and is non-latching. The trunk height has been designed to accommodate one or more USB based Intel Neural Compute Sticks. Two mounting holes are provided inside the trunk. These allow the user to strain relief tethered cables (eg, HDMI and keyboard) during development. It is recommended to strain relief such cables to prevent accidental damage during base motion. Item Notes A Vent Intake vent for computer fan B 6 Port USB Hub USB 3.0 , powered 5V/3A C Ethernet Connected to computer NIC D On/Off Robot power on / off. Switch is illuminated when on. E Charge Rated for upplied 12V/7A charger F HDMI Connected to computer HDMI G Mounting points M4 threaded holes","title":"Trunk"},{"location":"hardware_user_guide/#head","text":"The head provides the audio interface to the robot, a pan tilt depth camera, a runstop, as well as a developer interface to allow the addition of additional user hardware. Item Notes A Pan tilt depth camera Intel RealSense D435i Two Dynamixel XL430-W250-T servos B Speakers C Mounting holes 2x M4 threaded, spacing 25mm D Developer Interface USB2.0-A with 5V@500mA fused JST XHP-2, 12V@3A fused Pin 1: 12V Pin 2: GND E Microphone array With programmable 12 RGB LED ring F Runstop G Audio volume control","title":"Head"},{"location":"hardware_user_guide/#pan-tilt","text":"The head pan-tilt unit utilizes two Dynamixel XL430-W250-T servos. It incorporates a small fan in order to ensure proper cooling of the servo and camera during dynamic repeated motions of the tilt DOF. The nominal \u2018zero\u2019 position is of the head is shown below, along with the corresponding range of motion. DOF Range (deg) Min(deg) Max (deg) Pan 346 -234 112 Tilt 115 -25 90","title":"Pan Tilt"},{"location":"hardware_user_guide/#respeaker-microphone-array","text":"The ReSPeaker has 12 RGB LEDs that can be controlled programatically. By default they display sound intensity and direction of the microphone array. The ReSpeaker has 4 mems microphones mounted on a 64.61mm circle at 45 degree spacing. The drawing below shows the position and orientation of the microphone array relative to the head pan axis.","title":"ReSpeaker Microphone Array"},{"location":"hardware_user_guide/#runstop","text":"The runstop allows the user to pause the motion of the four primary DOF (base, lift, and arm) by tapping the illuminated button on the head. When the runstop is enabled, these DOF are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume.","title":"Runstop"},{"location":"hardware_user_guide/#lift","text":"The lift degree of freedom provides vertical translation of the arm. It is driven by a closed loop stepper motor, providing smooth and precise motion through a low gear-ratio belt drive. The \u2018shoulder\u2019 includes two mounting holes and a small delivery tray. Item Notes A Delivery tray B Mounting holes Threaded M4. Spacing 34.5 mm. C Aruco Tag Size 40x40 mm","title":"Lift"},{"location":"hardware_user_guide/#arm","text":"The arm comprises 5 telescoping carbon fiber links set on rollers. Its proprietary drive train is driven by a stepper motor with closed loop control and current sensing, allowing contact sensitivity during motion. The arm exhibits a small amount of play (lash) in the X, Y, Z, and theta directions which is a normal characteristic of its design. Despite this it can achieve good repeatability, in part because its gravity loading is fairly constant. The retracted arm and wrist combined are designed to fit within the footprint of the base. The arm is designed to have: Reach: 0.52m","title":"Arm"},{"location":"hardware_user_guide/#wrist","text":"The wrist includes: Yaw DOF to allow for stowing of the tool 2 Aruco tags for calibration and visual localization of the tool Expansion port with Arduino expansion header USB-A connector Tool plate with dual sided mounting Dynamixel X-Series TTL bus","title":"Wrist"},{"location":"hardware_user_guide/#wrist-control-interface","text":"The wrist yaw degree-of-freedom uses a Dynamixel XL430 servo . Additional Dynamixel servos can be daisy chained off of this servo, allowing for one more additional degree-of-freedoms to be easily integrated onto the robot (such as the provided Stretch Gripper). Stretch comes with a XL430 compatible control cable preinstalled into this servo. If a different cable needs to be installed the servo cap can be removed as shown.","title":"Wrist Control Interface"},{"location":"hardware_user_guide/#wrist-tool-plate","text":"The tool plate allows for mounting on the top or the bottom using the M2 bolt pattern. The mounting pattern is compatible with Robotis Dynamixel frames as well: FR12-H101K FR12-S102K FR12-S101K","title":"Wrist Tool Plate"},{"location":"hardware_user_guide/#wrist-yaw-range-of-motion","text":"The wrist yaw DOF is calibrated so that the index hole faces forward at the 'zero' position. From this pose the wrist has a ROM of +256/-76 degrees as shown.","title":"Wrist Yaw Range of Motion"},{"location":"hardware_user_guide/#wrist-accelerometer","text":"The wrist includes a 3 axis ADXL343 accelerometer which provides bump and tap detection capabilities. The sensor is mounted inside the distal link of the arm as shown below.","title":"Wrist Accelerometer"},{"location":"hardware_user_guide/#wrist-expansion-usb","text":"The wrist includes a USB 2.0 A interface. This power to this USB port is fused to 500mA@5V.","title":"Wrist Expansion USB"},{"location":"hardware_user_guide/#wrist-expansion-header","text":"The wrist includes an expansion header that provides access to pins of the wrist Arduino board. The header connector can be accessed by removing the cap at the end of the arm. The header is wired to a Atmel SAMD21G18A-AUT ( datasheet ) microcontroller (same as Arduino Zero). The expansion header pins are configured at the factory to allow: General purpose digital I/O Analog input In addition, the firmware can be configured for other pin functions, including: Serial SPI Serial I2C Serial UART The Stretch Firmware Manual covers this modification. The header pins utilize 3V3 TTL logic. They do not have interface protection (eg, ESD, over-voltage, shorts). It is possible to damage your robot if pin specifications are exceeded The pin mapping is: Pin Name Function Factory Firmware 1 DGND Digital ground 2 3V3 3.3V supply fused at 250mA. 3 E12V 12VDC fused at 500mA 4 SS DIO | SPI SS Digital out (D3) 5 SCK DIO | SPI SCK Digital out (D2) 6 MISO DIO | SPI MISO |UART TX Digital in (D0) 7 MOSI DIO | SPI MOSI | UART RX Digital in (D1) 8 SCL DIO | I2C SCL Not used 9 SS DIO | I2C SDA Not used 10 ANA0 Analog input Analog in (A0) The expansion DIO uses a 10 pin JST header B10B-PHDSS(LF)(SN) . It is compatible with a JST PHDR-10VS housing. JST provides pre-crimped wire compatible with this housing ( part APAPA22K305 ). Pin 1 & 10 are indicated below. The expansion DIO schematic shown below.","title":"Wrist Expansion Header"},{"location":"hardware_user_guide/#wrist-mounts","text":"","title":"Wrist Mounts"},{"location":"hardware_user_guide/#gripper","text":"The Stretch Compliant Gripper utilizes a Dynamixel XL430-W250-T servo to drive the spring grasper mechanism. The kinematics of the grasper mechanism are complex and non-linear relative to the motor position. As shown, it includes mounting features on one side to allow for attachment of simple rigid tools such as hooks and pullers . Item Notes A Stud attachment Threaded 6-32 B Thread attahcment Threaded M4 The attachment features are spaced at 9mm. The weight of the Stretch Compliant Gripper is 240g.","title":"Gripper"},{"location":"hardware_user_guide/#gripper-removal","text":"Here we describe removing the Stretch Compliant gripper. Installation is simply these steps in reverse. Unplug the Dynamixel cable from the back of the gripper. Remove the 4 screws holding the gripper to the bracket. Remove the gripper from the mounting bracket Unscrew the 8 screws holding the mounting bracket to the bottom of the tool plate.","title":"Gripper Removal"},{"location":"hardware_user_guide/#robot-care","text":"","title":"Robot Care"},{"location":"hardware_user_guide/#battery-maintenance","text":"Please review the Battery Maintenance Guide for proper care and charging of the Stretch batteries.","title":"Battery Maintenance"},{"location":"hardware_user_guide/#belt-tension","text":"A neoprene timing belt drives the arm up and down the lift. It may detension over long periods of time if it experiences sustained loading. In this case, slack will become visually apparent in the belt as the lift moves. The belt is very straightforward to re-tension. Please contact support@hello-robot.com for tensioning instructions.","title":"Belt Tension"},{"location":"hardware_user_guide/#keeping-the-robot-clean","text":"The robot surfaces can be wiped down with an alcohol wipe or a moist rag from time to time in order to remove and debris or oils that accumulate on the shells or mast. The drive wheels can accumulate dust over time and begin to lose traction. They should be periodically wiped down as well. When possible, the Trunk cover for the base should be kept on in order to keep dust and debris out of the Trunk connectors. If the D435i camera requires cleaning use appropriate lens cleaning fluid and a microfiber cloth.","title":"Keeping the Robot Clean"},{"location":"hardware_user_guide/#keeping-the-robot-calibrated","text":"The robot comes pre-calibrated with a robot-specific URDF. This calibration allows the D435i depth sensor to accurately estimate where the robot wrist, and body, is in the depth image. The robot may become slightly uncalibrated over time for a variety of reasons: Normal wear and tear and loosening of joints of the robot The head structure is accidentally load and the structure becomes very slightly bent The wrist and should structure become accidentally highly loaded and become slightly bent The calibration accuracy can be checked using the provided ROS tools. If necessary, the user can recalibrate the robot. See the Stretch URDF Calibration Guide for more information.","title":"Keeping the Robot Calibrated"},{"location":"hardware_user_guide/#transporting-the-robot","text":"Stretch was designed to be easily transported in the back of a car, up a stair case, or around a building. For short trips, the robot can be simply rolled around by grabbing its mast. It may be picked up by its mast and carried up stairs as well. For safety, please use two people to lift the robot. For longer trips it is recommended to transport the robot in its original cardboard box with foam packaging. The metal protective cage that surrounds the head is only necessary if the robot might be shipped and the box will not remain upright.","title":"Transporting the Robot"},{"location":"hardware_user_guide/#system-check","text":"It is useful to periodically run stretch_robot_system_check.py. This will check that the robot's hardware devices are present and within normal operating conditions. $ stretch_robot_system_check.py ---- Checking Devices ---- [Pass] : hello-wacc [Pass] : hello-motor-left-wheel [Pass] : hello-motor-arm [Pass] : hello-dynamixel-wrist [Pass] : hello-motor-right-wheel [Pass] : hello-motor-lift [Pass] : hello-pimu [Pass] : hello-respeaker [Pass] : hello-lrf [Pass] : hello-dynamixel-head ---- Checking Pimu ---- [Pass] Voltage = 12.8763639927 [Pass] Current = 3.25908634593 [Pass] Temperature = 36.3404559783 [Pass] Cliff-0 = -4.72064208984 [Pass] Cliff-1 = -8.56213378906 [Pass] Cliff-2 = 1.08505249023 [Pass] Cliff-3 = 5.68453979492 [Pass] IMU AZ = -9.80407142639 ---- Checking EndOfArm ---- [Dynamixel ID:013] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: wrist_yaw [Pass] Calibrated: wrist_yaw [Dynamixel ID:014] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: stretch_gripper [Pass] Calibrated: stretch_gripper ---- Checking Head ---- [Dynamixel ID:012] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_tilt [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_pan ---- Checking Wacc ---- [Pass] AX = 9.4840593338 ---- Checking hello-motor-left-wheel ---- [Pass] Position = 43.9992256165 ---- Checking hello-motor-right-wheel ---- [Pass] Position = 15.1164712906 ---- Checking hello-motor-arm ---- [Pass] Position = 59.7719421387 [Pass] Position Calibrated = True ---- Checking hello-motor-lift ---- [Pass] Position = 83.7744064331 [Pass] Position Calibrated = True ---- Checking for Intel D435i ---- Bus 002 Device 016: ID 8086:0b3a Intel Corp. [Pass] : Device found","title":"System Check"},{"location":"hardware_user_guide/#regulatory-compliance","text":"The Stretch Research Edition 1 (Stretch RE1) is not certified for use as a consumer device in the U.S. Unless stated otherwise, the Stretch RE1 is not subjected to compliance testing nor certified to meet any requirements, such as requirements for EMI, EMC, or ESD. Per FCC 47 CFR, Part 15, Subpart B, section 15.103(c) , we claim the Stretch Research Edition 1 as an exempted device, since it is a digital device used exclusively as industrial, commercial, or medical test equipment, where test equipment is equipment intended primarily for purposes of performing scientific investigations. OET BULLETIN NO. 62 , titled \"UNDERSTANDING THE FCC REGULATIONS FOR COMPUTERS AND OTHER DIGITAL DEVICES\" from December 1993 provides further clarification of the Section 15.103(c) exemption: \u201c Test equipment includes devices used for maintenance, research, evaluation, simulation and other analytical or scientific applications in areas such as industrial plants, public utilities, hospitals, universities, laboratories, automotive service centers and electronic repair shops.\u201d All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Regulatory Compliance"},{"location":"quick_start_guide/","text":"Stretch RE1: Quick Start Guide Congratulations on your Stretch RE1! This guide will get you started with your new robot. Safety Stretch has the potential to cause harm if not properly used. All users should review the Stretch Safety Guide before operating the robot. Unboxing Please watch the Stretch Unboxing Video . Robot Tour A few items you'll want to know about before getting started. Power The entire robot powers up and down with the On/Off switch. When powering down, we recommend selecting 'Power Off' from the Ubuntu Desktop prior to hitting the Off switch The provided battery charger can be plugged and unplugged at any time during operation. Stretch uses the following charger modes: Mode Function STANDBY Charger not charging the robot 12V AGM Charging while robot is powered down SUPPLY 1) Power the robot during tethered use 2) Repair damaged batteries. REPAIR Repair damaged batteries. Please review the Battery Maintenance Guide for proper care and charging of Stretch batteries. Runstop The illuminated button on the head is its Runstop. Just tap it, you'll hear a beep and it will start flashing. This will pause motion of the primary robot joints during operation. This can be useful if the robot makes an unsafe motion, or if you just want to free up the robot motors while you roll it around. To allow motion once again, hold the button down for two seconds. After the beep, motion can resume. Safe Handling Like any robot, it is possible to break Stretch if you're not careful. Use common sense when applying forces to its joints, transporting it, etc. The Stretch Unpowered Best Practices Video provides a quick overview of how to work with the robot. Things that won't hurt the robot : Manually push and pull the arm (when the motor isn't holding a position). Manually raise and lower the lift (when the motor isn't holding a position). Manually tilt and roll the base around (when the motors aren't holding a position). Pick up and carry Stretch (while holding it by the mast, two people for safety). Things to be mindful of : Manually moving the head and wrist. They will move but they want to go at their own speed. The arm will slowly descend when the robot is powered off. If the arm is retracted it may rest the tool on the base. If desired to hold the arm up when un-powered, the provided 'clip-clamp' can be clipped onto the mast below the shoulder to support it. Things that can hurt the robot : Driving the wrist and gripper into the base. When the arm and wrist are stowed it is possible to collide the two. Getting the gripper stuck on something and then driving the arm, lift, or base. Laying the robot down with it weight on its camera. Trying to ride on the robot, getting it wet, etc. (eg, common sense) Hello World Demo Stretch comes ready to run out of the box. The Xbox Teleoperation demo will let you quickly test out the robot capabilities by teleoperating it with an Xbox Controller. Note : You will find the USB Dongle already plugged into the the USB port of the base trunk. To start the demo after unboxing: Remove the 'trunk' cover and power on the robot Wait for about 45 seconds. You will hear the Ubuntu startup sound, followed by two beeps (indicating the demo is running). Hit the Connect button on the controller. The upper two LEDs of the ring will illuminate. Hit the Home Robot button. Stretch will go through its homing calibration routine. Note : make sure the space around the robot is clear before running the Home function You're ready to go! A few things to try: Hit the Stow Robot button. The robot will assume the stow pose. Practice driving the robot around. Pull the Fast Base trigger while driving. When stowed, it will make Stretch drive faster Manually stop the arm or lift from moving to make it stop upon contact. Try picking up your cellphone from the floor Try grasping cup from a counter top Try delivering an object to a person If you're done, hold down the Shutdown PC button for 2 seconds. This will cause the PC to turn off. You can then power down the robot. Or proceed to the next step... Now that you're familiar with the robot, take a minute to watch the Stretch Powered Best Practices Video . Get Plugged In Let's get plugged in. Remove the 'trunk' cover and power on the robot if its not already on. Plug in a mouse, keyboard and HDMI monitor to the robot trunk Plug in the battery charger Place the charger in SUPPLY mode Log in to the robot computer. The default user credentials came in the box with the robot. Start Coding Python is the easiest way to begin writing code for the robot. This section will give you a quick look at Stretch Body, which is the low level Python interface to the robot. Detailed information on the Stretch Body Interface can be found here. Stretch is configured to run the XBox Controller demo in the background at startup. To run your own code you'll need kill off this process so that it doesn't contend with your code. $ pkill -f stretch_xbox* While you're at it, disable this autoboot feature. You can always turn it back on later. Search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop' Now open up a Terminal. From the command line, first verify that that all of the hardware is present and happy $ stretch_robot_system_check.py You may see a few joints reported in red because they haven't yet been calibrated. If so, home the robot $ stretch_robot_home.py Once the robot has homed, let's write some quick test code: $ ipython Python 2.7.17 (default, Apr 15 2020, 17:20:14) ... Now let's move the robot around using the Robot API. Try typing in these interactive commands at the iPython prompt: import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . stow () robot . arm . move_to ( 0.25 ) robot . push_command () robot . arm . move_to ( 0.0 ) robot . push_command () robot . lift . move_to ( 0.4 ) robot . push_command () robot . pretty_print () robot . lift . pretty_print () robot . head . pose ( 'tool' ) robot . head . pose ( 'ahead' ) robot . end_of_arm . move_to ( 'wrist_yaw' , 0 ) robot . end_of_arm . move_to ( 'stretch_gripper' , 50 ) robot . end_of_arm . move_to ( 'stretch_gripper' , - 50 ) robot . stow () robot . stop () Change Credentials Finally, we recommend that you change the login credentials for the default user, hello-robot. $ sudo passwd hello-robot If you'd like to setup a new user account, check out the Stretch Installation Guide . In a lab setting, it's useful for lab members to have their own user accounts to run experiments. Power Down The recommended power down procedure is Place a clamp on the mast below the shoulder to prevent dropping Shutdown the computer from the Desktop When the laser range finder has stopped spinning, turn off the main power switch Attach the charger Place the charger in 12V AGM mode Join the Community Forum Join the Hello Robot Community . We'd welcome hearing your feedback as you get to know your robot. Hello Robot support monitors the forum closely and will quickly get back to you on any questions or issues you post. Further Exploration Encounter any issues while getting started? Please let us know at support@hello-robot.com. Also take a minute to review the Stretch Troubleshooting Guide We recommend next exploring the ROS based demos that ship with Stretch. These are found in the stretch_ros repository . That's it. Happy coding! All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch RE1: Quick Start Guide"},{"location":"quick_start_guide/#stretch-re1-quick-start-guide","text":"Congratulations on your Stretch RE1! This guide will get you started with your new robot.","title":"Stretch RE1: Quick Start Guide"},{"location":"quick_start_guide/#safety","text":"Stretch has the potential to cause harm if not properly used. All users should review the Stretch Safety Guide before operating the robot.","title":"Safety"},{"location":"quick_start_guide/#unboxing","text":"Please watch the Stretch Unboxing Video .","title":"Unboxing"},{"location":"quick_start_guide/#robot-tour","text":"A few items you'll want to know about before getting started.","title":"Robot Tour"},{"location":"quick_start_guide/#power","text":"The entire robot powers up and down with the On/Off switch. When powering down, we recommend selecting 'Power Off' from the Ubuntu Desktop prior to hitting the Off switch The provided battery charger can be plugged and unplugged at any time during operation. Stretch uses the following charger modes: Mode Function STANDBY Charger not charging the robot 12V AGM Charging while robot is powered down SUPPLY 1) Power the robot during tethered use 2) Repair damaged batteries. REPAIR Repair damaged batteries. Please review the Battery Maintenance Guide for proper care and charging of Stretch batteries.","title":"Power"},{"location":"quick_start_guide/#runstop","text":"The illuminated button on the head is its Runstop. Just tap it, you'll hear a beep and it will start flashing. This will pause motion of the primary robot joints during operation. This can be useful if the robot makes an unsafe motion, or if you just want to free up the robot motors while you roll it around. To allow motion once again, hold the button down for two seconds. After the beep, motion can resume.","title":"Runstop"},{"location":"quick_start_guide/#safe-handling","text":"Like any robot, it is possible to break Stretch if you're not careful. Use common sense when applying forces to its joints, transporting it, etc. The Stretch Unpowered Best Practices Video provides a quick overview of how to work with the robot. Things that won't hurt the robot : Manually push and pull the arm (when the motor isn't holding a position). Manually raise and lower the lift (when the motor isn't holding a position). Manually tilt and roll the base around (when the motors aren't holding a position). Pick up and carry Stretch (while holding it by the mast, two people for safety). Things to be mindful of : Manually moving the head and wrist. They will move but they want to go at their own speed. The arm will slowly descend when the robot is powered off. If the arm is retracted it may rest the tool on the base. If desired to hold the arm up when un-powered, the provided 'clip-clamp' can be clipped onto the mast below the shoulder to support it. Things that can hurt the robot : Driving the wrist and gripper into the base. When the arm and wrist are stowed it is possible to collide the two. Getting the gripper stuck on something and then driving the arm, lift, or base. Laying the robot down with it weight on its camera. Trying to ride on the robot, getting it wet, etc. (eg, common sense)","title":"Safe Handling"},{"location":"quick_start_guide/#hello-world-demo","text":"Stretch comes ready to run out of the box. The Xbox Teleoperation demo will let you quickly test out the robot capabilities by teleoperating it with an Xbox Controller. Note : You will find the USB Dongle already plugged into the the USB port of the base trunk. To start the demo after unboxing: Remove the 'trunk' cover and power on the robot Wait for about 45 seconds. You will hear the Ubuntu startup sound, followed by two beeps (indicating the demo is running). Hit the Connect button on the controller. The upper two LEDs of the ring will illuminate. Hit the Home Robot button. Stretch will go through its homing calibration routine. Note : make sure the space around the robot is clear before running the Home function You're ready to go! A few things to try: Hit the Stow Robot button. The robot will assume the stow pose. Practice driving the robot around. Pull the Fast Base trigger while driving. When stowed, it will make Stretch drive faster Manually stop the arm or lift from moving to make it stop upon contact. Try picking up your cellphone from the floor Try grasping cup from a counter top Try delivering an object to a person If you're done, hold down the Shutdown PC button for 2 seconds. This will cause the PC to turn off. You can then power down the robot. Or proceed to the next step... Now that you're familiar with the robot, take a minute to watch the Stretch Powered Best Practices Video .","title":"Hello World Demo"},{"location":"quick_start_guide/#get-plugged-in","text":"Let's get plugged in. Remove the 'trunk' cover and power on the robot if its not already on. Plug in a mouse, keyboard and HDMI monitor to the robot trunk Plug in the battery charger Place the charger in SUPPLY mode Log in to the robot computer. The default user credentials came in the box with the robot.","title":"Get Plugged In"},{"location":"quick_start_guide/#start-coding","text":"Python is the easiest way to begin writing code for the robot. This section will give you a quick look at Stretch Body, which is the low level Python interface to the robot. Detailed information on the Stretch Body Interface can be found here. Stretch is configured to run the XBox Controller demo in the background at startup. To run your own code you'll need kill off this process so that it doesn't contend with your code. $ pkill -f stretch_xbox* While you're at it, disable this autoboot feature. You can always turn it back on later. Search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop' Now open up a Terminal. From the command line, first verify that that all of the hardware is present and happy $ stretch_robot_system_check.py You may see a few joints reported in red because they haven't yet been calibrated. If so, home the robot $ stretch_robot_home.py Once the robot has homed, let's write some quick test code: $ ipython Python 2.7.17 (default, Apr 15 2020, 17:20:14) ... Now let's move the robot around using the Robot API. Try typing in these interactive commands at the iPython prompt: import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . stow () robot . arm . move_to ( 0.25 ) robot . push_command () robot . arm . move_to ( 0.0 ) robot . push_command () robot . lift . move_to ( 0.4 ) robot . push_command () robot . pretty_print () robot . lift . pretty_print () robot . head . pose ( 'tool' ) robot . head . pose ( 'ahead' ) robot . end_of_arm . move_to ( 'wrist_yaw' , 0 ) robot . end_of_arm . move_to ( 'stretch_gripper' , 50 ) robot . end_of_arm . move_to ( 'stretch_gripper' , - 50 ) robot . stow () robot . stop ()","title":"Start Coding"},{"location":"quick_start_guide/#change-credentials","text":"Finally, we recommend that you change the login credentials for the default user, hello-robot. $ sudo passwd hello-robot If you'd like to setup a new user account, check out the Stretch Installation Guide . In a lab setting, it's useful for lab members to have their own user accounts to run experiments.","title":"Change Credentials"},{"location":"quick_start_guide/#power-down","text":"The recommended power down procedure is Place a clamp on the mast below the shoulder to prevent dropping Shutdown the computer from the Desktop When the laser range finder has stopped spinning, turn off the main power switch Attach the charger Place the charger in 12V AGM mode","title":"Power Down"},{"location":"quick_start_guide/#join-the-community-forum","text":"Join the Hello Robot Community . We'd welcome hearing your feedback as you get to know your robot. Hello Robot support monitors the forum closely and will quickly get back to you on any questions or issues you post.","title":"Join the Community Forum"},{"location":"quick_start_guide/#further-exploration","text":"Encounter any issues while getting started? Please let us know at support@hello-robot.com. Also take a minute to review the Stretch Troubleshooting Guide We recommend next exploring the ROS based demos that ship with Stretch. These are found in the stretch_ros repository . That's it. Happy coding! All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Further Exploration"},{"location":"robot_safety_guide/","text":"Robot Safety Guide The Stretch RE1 is a potentially dangerous machine with safety hazards. If improperly used it can cause injury or death. All users must carefully read the following safety information prior to using the robot. Anyone near the robot who has not read this safety information must be closely supervised at all times and made aware that the robot could be dangerous. Only use the robot after inspecting the surrounding environment for potential hazards. Intended Use The Stretch RE1 (\u201cStretch\u201d) is intended for use by researchers to conduct research in controlled indoor environments. This product is not intended for other uses and lacks the required certifications for other uses, such as use in the home by consumers. Safety Hazards As described later in this document, we have designed Stretch to be safer than previous commercially-available human-scale mobile manipulators, so that researchers can explore the future of mobile manipulation. For example, we have made it smaller and lighter weight with backdrivable torque-sensing joints that can stop when they detect contact. Nonetheless, Stretch is a research robot that can be dangerous. It is essential that researchers use Stretch carefully to avoid damage, injury, or death. Here, we list a number of safety hazards that researchers must consider prior to use and during use of Stretch. Stretch Can Put People And Animals At Risk As described in more detail later, Stretch can put people and animals at risk. People and animals near the robot must be closely supervised at all times. At all times, an experienced researcher must carefully monitor the robot and be prepared to stop it. Any people near the robot must be made aware that the robot could be dangerous. Prior to any use of the robot near people or animals, researchers must carefully assess and minimize risks. Researchers who use the robot near children, animals, vulnerable adults, or other people do so at their own risk. Researchers must take appropriate precautions and obtain required approvals from their organizations. Stretch Can Topple Onto A Person The robot may drive off stairs, push or pull itself over with its telescoping arm, fall over while attempting to traverse a threshold, or encounter obstacles that cause it to fall on or otherwise collide with people, causing injury. Operate the robot only on flat surfaces away from stairs or other obstacles that may cause it to topple, and do not allow the robot to push or pull itself over. Stretch Should Not Be Lifted By A Single Person Stretch with the standard gripper weighs about 50.5lb, so two or more people should lift and carry the robot. A single person can move the robot around by enabling the runstop button, tilting it over, and rolling it on flat ground. At least two people should lift and carry the robot when needed. Stretch Can Cause Lacerations The robot wrist and tool have sharp edges that can cause lacerations or punctures to skin or the eyes. Operate the robot away from eyes and other sensitive body parts. Stretch Can Trap, Crush, Or Pinch Body Parts The robot has moving joints that can trap, crush or pinch hands, fingers, or other body parts. The robot could also injure a person or animal by driving over a body part. Keep body parts away from trap, crush, and pinch points during robot motion, including underneath the wheels. Stretch Can Entrap Loose Clothing Or Hair The robot's shoulder and telescoping arm have rollers that can pull in and entrap loose clothing or hair. Keep loose clothing and long hair away from the robot's shoulder and telescoping arm when either is in motion. Stretch Has Flammable Components The robot has polyurethane covers that are flammable and must be kept away from potential ignition sources, such as open flames and hot surfaces. The robot\u2019s head, shoulder, and mobile base have polyurethane covers. Keep the robot away from potential ignition sources and always have a working fire extinguisher nearby. Stretch Is An Electrical Device Stretch has batteries, electronics, wires, and other electrical components throughout its body. It also provides uncovered connectors that provide power. While the robot has fuses to reduce electrical risks, users must be careful. Keep the robot dry and away from liquids, avoid electrical shocks, ensure power cables and wires are in good condition, be careful with the robot\u2019s connectors, and generally exercise caution while working with this electrical device. Stretch Can Perform Dangerous Activities Stretch is a versatile robot capable of performing many actions, including actions that would be dangerous to people. For example, if a dangerous object is held by or affixed to the robot, such as a knife, a heavy object, or breakable glass, the robot can become very dangerous. Likewise, the robot is capable of physically altering the environment in ways that would be dangerous, such as turning a knob that releases gas from a gas stove. Users must be cautious while using the robot to ensure it interacts safely with people and the surrounding environment. Stretch Is An Open Platform That Can Be Made More Dangerous Stretch is an open platform with user-modifiable and user-extensible hardware and software. User changes to the hardware or software can entail serious risks. For example, when shipped, the robot has conservative settings that restrict its speed and the forces it applies to reduce the risks associated with the robot. By modifying the robot, users could enable the robot to move at unsafe speeds and apply unsafe forces. As another example, improper electrical connections could result in a fire. Researchers who choose to modify or extend the robot\u2019s hardware or software do so at their own risk, and should be careful to understand the implications of their modifications or extensions. Changes to the robot could result in dangerous situations that cause injury or death. Additional Risks The most important aspects of safety with Stretch are to use good judgment and common sense. Additional important considerations follow: If the robot appears to be damaged, stop the robot immediately. Always be ready to stop the robot. Do not operate the robot unless an experienced user is present and attentive. Be aware that the robot can move in unexpected ways. Do not put fingers or other objects into the channel that runs along the length of the mast. A belt moves within this channel. Keep an eye on cords, rugs, and any other floor hazards as the robot drives. Keep the robot at least 3 meters from ledges, curbs, stairs, and any other toppling hazard. Do not operate the robot outdoors. Do not attempt to ride the robot. Do not have the robot hold sharp objects. Do not attempt to service the robot without supervision by Hello Robot. Other Problems Will Likely Occur \u201c Anticipate potential problems and hazards. Always imagine what might happen if the robot malfunctions or behaves in a way different from the desired action. Be vigilant.\u201d - PR2 User Manual by Willow Garage from October 5, 2012 Stretch is a complex device that includes many mechanical, electrical, and computational systems that have been designed to work together. Be prepared for something to go wrong. For example, a motor control board might fail, software might not operate as anticipated, an unexpected process might still be running on the robot, or the batteries for the Xbox-style controller or the robot itself might run out. Safety Features We have considered safety from the outset in the design of Stretch. Runstop : The illuminated runstop button on Stretch\u2019s head can be used to pause operation of the four primary joints (base, lift, and arm) of the robot when it is in motion. Lightweight design: The overall mass of Stretch with the standard gripper is 23Kg (50.5lb), and the majority of the mass is in the base. The carbon fiber arm and aluminum mast make for a remarkably lightweight upper body. While this reduces the risk of crushing, crushing injury can still occur and should be carefully monitored. Gravity friendly : Due to Stretch\u2019s design, its actuators don't have to counteract gravity on a large lever arm. As a result, the motors and gearboxes are lower torque and lower weight than a conventional mobile manipulator with a comparable reach, avoiding the often dangerously strong shoulder joints of typical robot arms. Low gear ratio : The primary joints of Stretch (base, lift, and arm) have low gear-ratios (approx 5:1), allowing for backdriving of joints when powered off. A low gear-ratio also reduces the effective inertia of each joint, limiting the impacted force during undesired contacts with people and the environment. Contact Sensitivity : The four primary joints of Stretch (base, lift, and arm) have contact sensitivity. We measure motor currents to estimate contact forces. Because Stretch is a low gear-ratio robot, current sensing provides a fairly sensitive measure of contact forces. Firmware limits : Motor torques are limited at the lowest level of the firmware to configured bounds. Velocity limits : Fast motions of the base are restricted when the arm is up high and the tool is outside the base footprint. This limits the likelihood of toppling or snagging the tool during base motion. Tilt detection : The robot can detect when its body is tilted beyond a safe threshold. The robot can be configured to trigger a runstop event during an over-tilt event. Safety Markings Stretch has the following safety markings: Top of shoulder, indicating potential pinch point between rollers and mast. Top of base, indicating potential pinch point between arm and base. Runstop The runstop allows the user to pause the motion of the four primary actuators (base, lift, and arm) by tapping the illuminated button on the head. An experienced operator should always keep the runstop within reach, allowing them to stop the motion of the robot if it is deemed unsafe. NOTE: The runstop is not equivalent to an Emergency Stop found on industrial equipment and no safety guarantees are made by its function . When the runstop is enabled, these actuators are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume. The runstop logic is: Action Runstop State Button Illumination Robot startup Motion enabled Solid Tap runstop button Motion disabled Flashing at 1Hz Hold down runstop button for >2s Motion enabled Solid Safety Hazard Details Sharp Edges Stretch RE1 is a piece of laboratory equipment. As such, its structure has moderately sharp edges and corners that can be unsafe. These edges can get snagged during motion, or they may cause lacerations when sufficient force is applied to a person. Care should be taken when grasping or otherwise making contact with Stretch that a sharp corner or edge is not contacted. Toppling Stretch is a relatively lightweight robot. In some kinematic configurations a high center of gravity can make it prone to toppling. Toppling can occur when: The mobile base is moving at moderate or fast speed and hits a bump, threshold, or other change in floor property. The arm is raised up high and pushes or pulls on the environment with sufficient force. The robot drives over a drop-off such as a stair or curb. NOTE: While Stretch has cliff sensors, they do not currently inhibit motion of the base. During typical use, the robot will not attempt to stop itself at a cliff, and can fall down stairs and hurt itself or a person. Pinch Points Pinch points around the robot's head, gripper, and wrist can cause discomfort and care should be taken when handling these joints as they move. The shoulder, which travels up and down on the lift, has a series of rollers that ride along the mast. While the shoulder shells can prevent large objects from getting pinched by the rollers, small and thin objects can be pulled into and crushed. The telescoping arm, which extends and retracts, has rollers that ride along the telescoping elements. While the arm link cuffs can reduce the chance of large objects getting pinched, small and thin objects, such as hair, can be pulled in. Extra care should be taken with long hair, clothing, and small fingers around the shoulder rollers. Crush Points The lift degree of freedom is the strongest joint on the robot and as such can apply potentially unsafe forces to a person. The lift, while in motion, may trap or crush objects between the \u2018shoulder\u2019 and another surface. As such, best practices for lift safety should always be used when using the lift degree of freedom. The lift has a max theoretical strength of nearly 200N of linear force. In practice, this force is limited by the lift\u2019s Guarded Move function, which places the lift in Safety Mode when the actuator forces exceed a threshold. The diagrams below show the potential crush points at the top and bottom of the lift range of motion.","title":"Robot Safety"},{"location":"robot_safety_guide/#robot-safety-guide","text":"The Stretch RE1 is a potentially dangerous machine with safety hazards. If improperly used it can cause injury or death. All users must carefully read the following safety information prior to using the robot. Anyone near the robot who has not read this safety information must be closely supervised at all times and made aware that the robot could be dangerous. Only use the robot after inspecting the surrounding environment for potential hazards.","title":"Robot Safety Guide"},{"location":"robot_safety_guide/#intended-use","text":"The Stretch RE1 (\u201cStretch\u201d) is intended for use by researchers to conduct research in controlled indoor environments. This product is not intended for other uses and lacks the required certifications for other uses, such as use in the home by consumers.","title":"Intended Use"},{"location":"robot_safety_guide/#safety-hazards","text":"As described later in this document, we have designed Stretch to be safer than previous commercially-available human-scale mobile manipulators, so that researchers can explore the future of mobile manipulation. For example, we have made it smaller and lighter weight with backdrivable torque-sensing joints that can stop when they detect contact. Nonetheless, Stretch is a research robot that can be dangerous. It is essential that researchers use Stretch carefully to avoid damage, injury, or death. Here, we list a number of safety hazards that researchers must consider prior to use and during use of Stretch.","title":"Safety Hazards"},{"location":"robot_safety_guide/#stretch-can-put-people-and-animals-at-risk","text":"As described in more detail later, Stretch can put people and animals at risk. People and animals near the robot must be closely supervised at all times. At all times, an experienced researcher must carefully monitor the robot and be prepared to stop it. Any people near the robot must be made aware that the robot could be dangerous. Prior to any use of the robot near people or animals, researchers must carefully assess and minimize risks. Researchers who use the robot near children, animals, vulnerable adults, or other people do so at their own risk. Researchers must take appropriate precautions and obtain required approvals from their organizations.","title":"Stretch Can Put People And Animals At Risk"},{"location":"robot_safety_guide/#stretch-can-topple-onto-a-person","text":"The robot may drive off stairs, push or pull itself over with its telescoping arm, fall over while attempting to traverse a threshold, or encounter obstacles that cause it to fall on or otherwise collide with people, causing injury. Operate the robot only on flat surfaces away from stairs or other obstacles that may cause it to topple, and do not allow the robot to push or pull itself over.","title":"Stretch Can Topple Onto A Person"},{"location":"robot_safety_guide/#stretch-should-not-be-lifted-by-a-single-person","text":"Stretch with the standard gripper weighs about 50.5lb, so two or more people should lift and carry the robot. A single person can move the robot around by enabling the runstop button, tilting it over, and rolling it on flat ground. At least two people should lift and carry the robot when needed.","title":"Stretch Should Not Be Lifted By A Single Person"},{"location":"robot_safety_guide/#stretch-can-cause-lacerations","text":"The robot wrist and tool have sharp edges that can cause lacerations or punctures to skin or the eyes. Operate the robot away from eyes and other sensitive body parts.","title":"Stretch Can Cause Lacerations"},{"location":"robot_safety_guide/#stretch-can-trap-crush-or-pinch-body-parts","text":"The robot has moving joints that can trap, crush or pinch hands, fingers, or other body parts. The robot could also injure a person or animal by driving over a body part. Keep body parts away from trap, crush, and pinch points during robot motion, including underneath the wheels.","title":"Stretch Can Trap, Crush, Or Pinch Body Parts"},{"location":"robot_safety_guide/#stretch-can-entrap-loose-clothing-or-hair","text":"The robot's shoulder and telescoping arm have rollers that can pull in and entrap loose clothing or hair. Keep loose clothing and long hair away from the robot's shoulder and telescoping arm when either is in motion.","title":"Stretch Can Entrap Loose Clothing Or Hair"},{"location":"robot_safety_guide/#stretch-has-flammable-components","text":"The robot has polyurethane covers that are flammable and must be kept away from potential ignition sources, such as open flames and hot surfaces. The robot\u2019s head, shoulder, and mobile base have polyurethane covers. Keep the robot away from potential ignition sources and always have a working fire extinguisher nearby.","title":"Stretch Has Flammable Components"},{"location":"robot_safety_guide/#stretch-is-an-electrical-device","text":"Stretch has batteries, electronics, wires, and other electrical components throughout its body. It also provides uncovered connectors that provide power. While the robot has fuses to reduce electrical risks, users must be careful. Keep the robot dry and away from liquids, avoid electrical shocks, ensure power cables and wires are in good condition, be careful with the robot\u2019s connectors, and generally exercise caution while working with this electrical device.","title":"Stretch Is An Electrical Device"},{"location":"robot_safety_guide/#stretch-can-perform-dangerous-activities","text":"Stretch is a versatile robot capable of performing many actions, including actions that would be dangerous to people. For example, if a dangerous object is held by or affixed to the robot, such as a knife, a heavy object, or breakable glass, the robot can become very dangerous. Likewise, the robot is capable of physically altering the environment in ways that would be dangerous, such as turning a knob that releases gas from a gas stove. Users must be cautious while using the robot to ensure it interacts safely with people and the surrounding environment.","title":"Stretch Can Perform Dangerous Activities"},{"location":"robot_safety_guide/#stretch-is-an-open-platform-that-can-be-made-more-dangerous","text":"Stretch is an open platform with user-modifiable and user-extensible hardware and software. User changes to the hardware or software can entail serious risks. For example, when shipped, the robot has conservative settings that restrict its speed and the forces it applies to reduce the risks associated with the robot. By modifying the robot, users could enable the robot to move at unsafe speeds and apply unsafe forces. As another example, improper electrical connections could result in a fire. Researchers who choose to modify or extend the robot\u2019s hardware or software do so at their own risk, and should be careful to understand the implications of their modifications or extensions. Changes to the robot could result in dangerous situations that cause injury or death.","title":"Stretch Is An Open Platform That Can Be Made More Dangerous"},{"location":"robot_safety_guide/#additional-risks","text":"The most important aspects of safety with Stretch are to use good judgment and common sense. Additional important considerations follow: If the robot appears to be damaged, stop the robot immediately. Always be ready to stop the robot. Do not operate the robot unless an experienced user is present and attentive. Be aware that the robot can move in unexpected ways. Do not put fingers or other objects into the channel that runs along the length of the mast. A belt moves within this channel. Keep an eye on cords, rugs, and any other floor hazards as the robot drives. Keep the robot at least 3 meters from ledges, curbs, stairs, and any other toppling hazard. Do not operate the robot outdoors. Do not attempt to ride the robot. Do not have the robot hold sharp objects. Do not attempt to service the robot without supervision by Hello Robot.","title":"Additional Risks"},{"location":"robot_safety_guide/#other-problems-will-likely-occur","text":"\u201c Anticipate potential problems and hazards. Always imagine what might happen if the robot malfunctions or behaves in a way different from the desired action. Be vigilant.\u201d - PR2 User Manual by Willow Garage from October 5, 2012 Stretch is a complex device that includes many mechanical, electrical, and computational systems that have been designed to work together. Be prepared for something to go wrong. For example, a motor control board might fail, software might not operate as anticipated, an unexpected process might still be running on the robot, or the batteries for the Xbox-style controller or the robot itself might run out.","title":"Other Problems Will Likely Occur"},{"location":"robot_safety_guide/#safety-features","text":"We have considered safety from the outset in the design of Stretch. Runstop : The illuminated runstop button on Stretch\u2019s head can be used to pause operation of the four primary joints (base, lift, and arm) of the robot when it is in motion. Lightweight design: The overall mass of Stretch with the standard gripper is 23Kg (50.5lb), and the majority of the mass is in the base. The carbon fiber arm and aluminum mast make for a remarkably lightweight upper body. While this reduces the risk of crushing, crushing injury can still occur and should be carefully monitored. Gravity friendly : Due to Stretch\u2019s design, its actuators don't have to counteract gravity on a large lever arm. As a result, the motors and gearboxes are lower torque and lower weight than a conventional mobile manipulator with a comparable reach, avoiding the often dangerously strong shoulder joints of typical robot arms. Low gear ratio : The primary joints of Stretch (base, lift, and arm) have low gear-ratios (approx 5:1), allowing for backdriving of joints when powered off. A low gear-ratio also reduces the effective inertia of each joint, limiting the impacted force during undesired contacts with people and the environment. Contact Sensitivity : The four primary joints of Stretch (base, lift, and arm) have contact sensitivity. We measure motor currents to estimate contact forces. Because Stretch is a low gear-ratio robot, current sensing provides a fairly sensitive measure of contact forces. Firmware limits : Motor torques are limited at the lowest level of the firmware to configured bounds. Velocity limits : Fast motions of the base are restricted when the arm is up high and the tool is outside the base footprint. This limits the likelihood of toppling or snagging the tool during base motion. Tilt detection : The robot can detect when its body is tilted beyond a safe threshold. The robot can be configured to trigger a runstop event during an over-tilt event.","title":"Safety Features"},{"location":"robot_safety_guide/#safety-markings","text":"Stretch has the following safety markings: Top of shoulder, indicating potential pinch point between rollers and mast. Top of base, indicating potential pinch point between arm and base.","title":"Safety Markings"},{"location":"robot_safety_guide/#runstop","text":"The runstop allows the user to pause the motion of the four primary actuators (base, lift, and arm) by tapping the illuminated button on the head. An experienced operator should always keep the runstop within reach, allowing them to stop the motion of the robot if it is deemed unsafe. NOTE: The runstop is not equivalent to an Emergency Stop found on industrial equipment and no safety guarantees are made by its function . When the runstop is enabled, these actuators are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume. The runstop logic is: Action Runstop State Button Illumination Robot startup Motion enabled Solid Tap runstop button Motion disabled Flashing at 1Hz Hold down runstop button for >2s Motion enabled Solid","title":"Runstop"},{"location":"robot_safety_guide/#safety-hazard-details","text":"","title":"Safety Hazard Details"},{"location":"robot_safety_guide/#sharp-edges","text":"Stretch RE1 is a piece of laboratory equipment. As such, its structure has moderately sharp edges and corners that can be unsafe. These edges can get snagged during motion, or they may cause lacerations when sufficient force is applied to a person. Care should be taken when grasping or otherwise making contact with Stretch that a sharp corner or edge is not contacted.","title":"Sharp Edges"},{"location":"robot_safety_guide/#toppling","text":"Stretch is a relatively lightweight robot. In some kinematic configurations a high center of gravity can make it prone to toppling. Toppling can occur when: The mobile base is moving at moderate or fast speed and hits a bump, threshold, or other change in floor property. The arm is raised up high and pushes or pulls on the environment with sufficient force. The robot drives over a drop-off such as a stair or curb. NOTE: While Stretch has cliff sensors, they do not currently inhibit motion of the base. During typical use, the robot will not attempt to stop itself at a cliff, and can fall down stairs and hurt itself or a person.","title":"Toppling"},{"location":"robot_safety_guide/#pinch-points","text":"Pinch points around the robot's head, gripper, and wrist can cause discomfort and care should be taken when handling these joints as they move. The shoulder, which travels up and down on the lift, has a series of rollers that ride along the mast. While the shoulder shells can prevent large objects from getting pinched by the rollers, small and thin objects can be pulled into and crushed. The telescoping arm, which extends and retracts, has rollers that ride along the telescoping elements. While the arm link cuffs can reduce the chance of large objects getting pinched, small and thin objects, such as hair, can be pulled in. Extra care should be taken with long hair, clothing, and small fingers around the shoulder rollers.","title":"Pinch Points"},{"location":"robot_safety_guide/#crush-points","text":"The lift degree of freedom is the strongest joint on the robot and as such can apply potentially unsafe forces to a person. The lift, while in motion, may trap or crush objects between the \u2018shoulder\u2019 and another surface. As such, best practices for lift safety should always be used when using the lift degree of freedom. The lift has a max theoretical strength of nearly 200N of linear force. In practice, this force is limited by the lift\u2019s Guarded Move function, which places the lift in Safety Mode when the actuator forces exceed a threshold. The diagrams below show the potential crush points at the top and bottom of the lift range of motion.","title":"Crush Points"},{"location":"tool_change_tutorial/","text":"Stretch RE1: Tool Change Tutorial Many users will want to work with tools other than the default Stretch Gripper that ships with the robot. In this tutorial you will learn how to configure the Stretch software interfaces to support other tools. Changing Tool Interfaces in Stretch Body Stretch Body v0.1.x and later supports a plug-in based architecture for tools. A tool interface is an extension of the EndOfArm class that supports additional degrees of freedom. Standard Tools Stretch Body supports two tool interfaces by default: The ToolNone & ToolStretchGripper . We will explore swapping between these default tools. ToolStretchGripper The RE1 is configured to load the ToolStretchGripper interface by default. This tool is loaded according to the stretch_re1_user_params.yaml field: robot : tool : tool_stretch_gripper We can interact with this tool from iPython In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_body . end_of_arm_tools . ToolStretchGripper instance at 0x7f99109155a0 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'stretch_gripper' : < stretch_body . stretch_gripper . StretchGripper instance at 0x7f99109159b0 > , 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f9910915820 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ---- --------- Stowing Gripper ---- In [ 7 ]: r . stop () ToolNone The ToolNone interface can be loaded when no tool is attached to the Wrist Yaw joint. To switch to this interface, simply update the field in your stretch_re1_user_params.yaml to: robot : tool : tool_none After updating the YAML we can interact with the ToolNone via iPython In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_body . end_of_arm_tools . ToolNone instance at 0x7f245f786fa0 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f245e69e410 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ---- In [ 7 ]: r . stop () Loading Tool Interfaces from the Stretch Tool Share The Stretch Tool Share is an open Git repository for non-standard RE1 tools. It hosts the CAD, URDF, and Python files needed to integrate these tools onto your robot. To use Stretch Tool Share tools, first update your installation: $ pip2 install hello-robot-stretch-tool-share As an example, we see on the Tool Share that there is a tool, the ToolDryEraseToolHolderV1 which extends the EndOfArm class. In order to load this tool interface , modify your stretch_re1_user_params.yaml to load the tool as before. We will also need to tell it where to find the tool's parameter file : robot : tool : tool_dry_erase_holder_v1 params : - stretch_tool_share.dry_erase_holder_v1.params We can now interact with the tool in iPython: In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_tool_share . dry_erase_holder_v1 . tool . ToolDryEraseHolderV1 instance at 0x7f3b61c17f00 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f3b61c59280 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ---- Changing Tool Interfaces in Stretch ROS Next we'll show how to change the ROS interface for a tool. Here we will continue with the ToolDryEraseHolderV1 example. First, configure Stretch Body to use the tool as in the previous exercise. Next, ensure your ROS is up to date: $ cd ~/catkin_ws/src/stretch_ros/ $ git pull To access the URDF data for the ToolDryEraseHolderV1 we'll need to clone the Tool Share repository: $ cd ~/repos $ git clone https://github.com/hello-robot/stretch_tool_share Copy in the tool's URDF data into the Stretch ROS repository: $ cd ~/repos/stretch_tool_share/tool_share/dry_erase_holder_v1 $ cp stretch_description/urdf/*.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf/ $ cp stretch_description/meshes/*.STL ~/catkin_ws/src/stretch_ros/stretch_description/meshes/ Now we will update the tool Xacro for Stretch. Open the file ~/catkin_ws/src/stretch_ros/stretch_description/urdf/stretch_description.xacro in an editor. Comment out the current tool Xacro and include the Xacro for the dry erase holder. <?xml version=\"1.0\"?> <robot xmlns:xacro= \"http://www.ros.org/wiki/xacro\" name= \"stretch_description\" > <!--<xacro:include filename=\"stretch_gripper.xacro\" />--> <xacro:include filename= \"stretch_dry_erase_marker.xacro\" /> <xacro:include filename= \"stretch_main.xacro\" /> <xacro:include filename= \"stretch_aruco.xacro\" /> <xacro:include filename= \"stretch_d435i.xacro\" /> <xacro:include filename= \"stretch_laser_range_finder.xacro\" /> <xacro:include filename= \"stretch_respeaker.xacro\" /> </robot> Finally, we'll update our already calibrated URDF to use this new tool: $ cd ~/catkin_ws/src/stretch_ros/stretch_description/urdf $ cp stretch.urdf stretch.urdf.bak $ rosrun stretch_calibration update_urdf_after_xacro_change.sh Ctrl-C when the rosrun command terminates and you're ready to visualize the tool in RViz: $ roslaunch stretch_calibration simple_test_head_calibration.launch Advanced Topics Understanding How the Tool Plug-In Works For users looking to create their own custom tools it can be useful to understand how the tool plug-in architecture works. Here we will walk through the basics of the system for both Stretch Body and Stretch ROS Stretch Body The Robot class expects an instance of EndOfArm tool to be present. The EndOfArm tool is an extension of the DynamixelXChain class, which manages a chain of Dynamixel servos. A tool is defined via its parameters (either in user YAML or Python). For example, the ToolStretchGripper is defined in robot_params.py . These parameters tell the plug-in which DynamixelHelloXL430 instances to load and manage. Here we see: \"tool_stretch_gripper\" : { 'use_group_sync_read' : 1 , 'retry_on_comm_failure' : 1 , 'baud' : 115200 , 'verbose' : 0 , 'py_class_name' : 'ToolStretchGripper' , 'py_module_name' : 'stretch_body.end_of_arm_tools' , 'stow' : { 'stretch_gripper' : 0 , 'wrist_yaw' : 3.4 }, 'devices' : { 'stretch_gripper' : { 'py_class_name' : 'StretchGripper' , 'py_module_name' : 'stretch_body.stretch_gripper' }, 'wrist_yaw' : { 'py_class_name' : 'WristYaw' , 'py_module_name' : 'stretch_body.wrist_yaw' } } }, This dictionary defines a tool of class ToolStretchGripper with two DynamixelHelloXL430 devices on its bus (StretchGripper and WristYaw). We see that the ToolStretchGripper class extends the EndOfArm class and provides its own stowing behavior: class ToolStretchGripper ( EndOfArm ): def __init__ ( self , name = 'tool_stretch_gripper' ): EndOfArm . __init__ ( self , name ) def stow ( self ): # Fold in wrist and gripper print ( '--------- Stowing Wrist Yaw ----' ) self . move_to ( 'wrist_yaw' , self . params [ 'stow' ][ 'wrist_yaw' ]) print ( '--------- Stowing Gripper ----' ) self . move_to ( 'stretch_gripper' , self . params [ 'stow' ][ 'stretch_gripper' ]) For tools that are not a part of Stretch Body, such as from the Tool Share, you must include the tool parameters as well in your stretch_re1_user_params.yaml . A robot that must support many tools may have user YAML that looks like: params : - stretch_tool_share.usbcam_wrist_v1.params - stretch_tool_share.stretch_dex_wrist_beta.params - stretch_tool_share.dry_erase_holder_v1.params robot : tool : tool_dry_erase_holder_v1 #tool: tool_none #tool: tool_stretch_gripper #tool: tool_usbcam_wrist_v1 #tool: tool_stretch_dex_wrist_beta For a more complex implementation of a tool we recommend reviewing the Stretch Dex Wrist implementation on the Stretch Tool Share. Stretch ROS Stretch ROS also supports the tool plug-in architecture. Under ROS this is managed by extending the SimpleCommandGroup . More coming soon. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch RE1: Tool Change Tutorial"},{"location":"tool_change_tutorial/#stretch-re1-tool-change-tutorial","text":"Many users will want to work with tools other than the default Stretch Gripper that ships with the robot. In this tutorial you will learn how to configure the Stretch software interfaces to support other tools.","title":"Stretch RE1: Tool Change Tutorial"},{"location":"tool_change_tutorial/#changing-tool-interfaces-in-stretch-body","text":"Stretch Body v0.1.x and later supports a plug-in based architecture for tools. A tool interface is an extension of the EndOfArm class that supports additional degrees of freedom.","title":"Changing Tool Interfaces in Stretch Body"},{"location":"tool_change_tutorial/#standard-tools","text":"Stretch Body supports two tool interfaces by default: The ToolNone & ToolStretchGripper . We will explore swapping between these default tools.","title":"Standard Tools"},{"location":"tool_change_tutorial/#toolstretchgripper","text":"The RE1 is configured to load the ToolStretchGripper interface by default. This tool is loaded according to the stretch_re1_user_params.yaml field: robot : tool : tool_stretch_gripper We can interact with this tool from iPython In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_body . end_of_arm_tools . ToolStretchGripper instance at 0x7f99109155a0 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'stretch_gripper' : < stretch_body . stretch_gripper . StretchGripper instance at 0x7f99109159b0 > , 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f9910915820 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ---- --------- Stowing Gripper ---- In [ 7 ]: r . stop ()","title":"ToolStretchGripper"},{"location":"tool_change_tutorial/#toolnone","text":"The ToolNone interface can be loaded when no tool is attached to the Wrist Yaw joint. To switch to this interface, simply update the field in your stretch_re1_user_params.yaml to: robot : tool : tool_none After updating the YAML we can interact with the ToolNone via iPython In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_body . end_of_arm_tools . ToolNone instance at 0x7f245f786fa0 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f245e69e410 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ---- In [ 7 ]: r . stop ()","title":"ToolNone"},{"location":"tool_change_tutorial/#loading-tool-interfaces-from-the-stretch-tool-share","text":"The Stretch Tool Share is an open Git repository for non-standard RE1 tools. It hosts the CAD, URDF, and Python files needed to integrate these tools onto your robot. To use Stretch Tool Share tools, first update your installation: $ pip2 install hello-robot-stretch-tool-share As an example, we see on the Tool Share that there is a tool, the ToolDryEraseToolHolderV1 which extends the EndOfArm class. In order to load this tool interface , modify your stretch_re1_user_params.yaml to load the tool as before. We will also need to tell it where to find the tool's parameter file : robot : tool : tool_dry_erase_holder_v1 params : - stretch_tool_share.dry_erase_holder_v1.params We can now interact with the tool in iPython: In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_tool_share . dry_erase_holder_v1 . tool . ToolDryEraseHolderV1 instance at 0x7f3b61c17f00 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f3b61c59280 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ----","title":"Loading Tool Interfaces from the Stretch Tool Share"},{"location":"tool_change_tutorial/#changing-tool-interfaces-in-stretch-ros","text":"Next we'll show how to change the ROS interface for a tool. Here we will continue with the ToolDryEraseHolderV1 example. First, configure Stretch Body to use the tool as in the previous exercise. Next, ensure your ROS is up to date: $ cd ~/catkin_ws/src/stretch_ros/ $ git pull To access the URDF data for the ToolDryEraseHolderV1 we'll need to clone the Tool Share repository: $ cd ~/repos $ git clone https://github.com/hello-robot/stretch_tool_share Copy in the tool's URDF data into the Stretch ROS repository: $ cd ~/repos/stretch_tool_share/tool_share/dry_erase_holder_v1 $ cp stretch_description/urdf/*.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf/ $ cp stretch_description/meshes/*.STL ~/catkin_ws/src/stretch_ros/stretch_description/meshes/ Now we will update the tool Xacro for Stretch. Open the file ~/catkin_ws/src/stretch_ros/stretch_description/urdf/stretch_description.xacro in an editor. Comment out the current tool Xacro and include the Xacro for the dry erase holder. <?xml version=\"1.0\"?> <robot xmlns:xacro= \"http://www.ros.org/wiki/xacro\" name= \"stretch_description\" > <!--<xacro:include filename=\"stretch_gripper.xacro\" />--> <xacro:include filename= \"stretch_dry_erase_marker.xacro\" /> <xacro:include filename= \"stretch_main.xacro\" /> <xacro:include filename= \"stretch_aruco.xacro\" /> <xacro:include filename= \"stretch_d435i.xacro\" /> <xacro:include filename= \"stretch_laser_range_finder.xacro\" /> <xacro:include filename= \"stretch_respeaker.xacro\" /> </robot> Finally, we'll update our already calibrated URDF to use this new tool: $ cd ~/catkin_ws/src/stretch_ros/stretch_description/urdf $ cp stretch.urdf stretch.urdf.bak $ rosrun stretch_calibration update_urdf_after_xacro_change.sh Ctrl-C when the rosrun command terminates and you're ready to visualize the tool in RViz: $ roslaunch stretch_calibration simple_test_head_calibration.launch","title":"Changing Tool Interfaces in Stretch ROS"},{"location":"tool_change_tutorial/#advanced-topics","text":"","title":"Advanced Topics"},{"location":"tool_change_tutorial/#understanding-how-the-tool-plug-in-works","text":"For users looking to create their own custom tools it can be useful to understand how the tool plug-in architecture works. Here we will walk through the basics of the system for both Stretch Body and Stretch ROS","title":"Understanding How the Tool Plug-In Works"},{"location":"tool_change_tutorial/#stretch-body","text":"The Robot class expects an instance of EndOfArm tool to be present. The EndOfArm tool is an extension of the DynamixelXChain class, which manages a chain of Dynamixel servos. A tool is defined via its parameters (either in user YAML or Python). For example, the ToolStretchGripper is defined in robot_params.py . These parameters tell the plug-in which DynamixelHelloXL430 instances to load and manage. Here we see: \"tool_stretch_gripper\" : { 'use_group_sync_read' : 1 , 'retry_on_comm_failure' : 1 , 'baud' : 115200 , 'verbose' : 0 , 'py_class_name' : 'ToolStretchGripper' , 'py_module_name' : 'stretch_body.end_of_arm_tools' , 'stow' : { 'stretch_gripper' : 0 , 'wrist_yaw' : 3.4 }, 'devices' : { 'stretch_gripper' : { 'py_class_name' : 'StretchGripper' , 'py_module_name' : 'stretch_body.stretch_gripper' }, 'wrist_yaw' : { 'py_class_name' : 'WristYaw' , 'py_module_name' : 'stretch_body.wrist_yaw' } } }, This dictionary defines a tool of class ToolStretchGripper with two DynamixelHelloXL430 devices on its bus (StretchGripper and WristYaw). We see that the ToolStretchGripper class extends the EndOfArm class and provides its own stowing behavior: class ToolStretchGripper ( EndOfArm ): def __init__ ( self , name = 'tool_stretch_gripper' ): EndOfArm . __init__ ( self , name ) def stow ( self ): # Fold in wrist and gripper print ( '--------- Stowing Wrist Yaw ----' ) self . move_to ( 'wrist_yaw' , self . params [ 'stow' ][ 'wrist_yaw' ]) print ( '--------- Stowing Gripper ----' ) self . move_to ( 'stretch_gripper' , self . params [ 'stow' ][ 'stretch_gripper' ]) For tools that are not a part of Stretch Body, such as from the Tool Share, you must include the tool parameters as well in your stretch_re1_user_params.yaml . A robot that must support many tools may have user YAML that looks like: params : - stretch_tool_share.usbcam_wrist_v1.params - stretch_tool_share.stretch_dex_wrist_beta.params - stretch_tool_share.dry_erase_holder_v1.params robot : tool : tool_dry_erase_holder_v1 #tool: tool_none #tool: tool_stretch_gripper #tool: tool_usbcam_wrist_v1 #tool: tool_stretch_dex_wrist_beta For a more complex implementation of a tool we recommend reviewing the Stretch Dex Wrist implementation on the Stretch Tool Share.","title":"Stretch Body"},{"location":"tool_change_tutorial/#stretch-ros","text":"Stretch ROS also supports the tool plug-in architecture. Under ROS this is managed by extending the SimpleCommandGroup . More coming soon. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch ROS"},{"location":"troubleshooting_guide/","text":"Stretch RE1: Troubleshooting Guide This guide covers common issues and ways to resolve them. Please check the Hello Robot Forum for additional topics not covered here. XBox teleoperation is not working The provided Easy SMX wireless controller can accidentally be placed in the wrong mode. The mode is indicated by the round illuminated ring (shown as Connect below). The top 2 LEDs only should be illuminated. If a different LED pattern is shown then the button mapping expected by stretch_xbox_controller_teleop.py will be incorrect. To set the controller into the correct mode: Hold the center button down for 5s. It will switch modes. Release. Repeat until top half of ring (upper two lights) are illuminated. In addition, check that the provided USB dongle is plugged into the robot USB port in its trunk. . Battery is not staying charged Please review the troubleshooting section of the Battery Maintenance Guide . RPC Transport Errors (Stretch doesn't respond to commands) If more than one instance of Stretch Body's Robot class is instantiated at a time, Stretch Body will report communication errors and will not always execute motion commands as expected. This is because Robot manages communications with the robot hardware and it doesn't support multiple writes to the USB devices. These errors can appear as Transport RX Error on RPC_ACK_SEND_BLOCK_MORE False 0 102 ---- Debug Exception --------------- New RPC ------------------------- Framer sent RPC_START_NEW_RPC ... or as IOError(None): None ... To check if a instance of Robot is already instantiated, you may use the Unix top command to monitor active processes. You may use the Unix pkill command to end the background instance of Robot. $ pkill -9 python As shipped, Stretch launches stretch_xbox_controller_teleop.py upon boot. It is necessary to turn off this automatic launch feature, otherwise your own Robot instance will conflict with this script. Additionally, if you are logged into multiple accounts, a Robot instance may be active in another user account. To turn it off, search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop'. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch RE1: Troubleshooting Guide"},{"location":"troubleshooting_guide/#stretch-re1-troubleshooting-guide","text":"This guide covers common issues and ways to resolve them. Please check the Hello Robot Forum for additional topics not covered here.","title":"Stretch RE1: Troubleshooting Guide"},{"location":"troubleshooting_guide/#xbox-teleoperation-is-not-working","text":"The provided Easy SMX wireless controller can accidentally be placed in the wrong mode. The mode is indicated by the round illuminated ring (shown as Connect below). The top 2 LEDs only should be illuminated. If a different LED pattern is shown then the button mapping expected by stretch_xbox_controller_teleop.py will be incorrect. To set the controller into the correct mode: Hold the center button down for 5s. It will switch modes. Release. Repeat until top half of ring (upper two lights) are illuminated. In addition, check that the provided USB dongle is plugged into the robot USB port in its trunk. .","title":"XBox teleoperation is not working"},{"location":"troubleshooting_guide/#battery-is-not-staying-charged","text":"Please review the troubleshooting section of the Battery Maintenance Guide .","title":"Battery is not staying charged"},{"location":"troubleshooting_guide/#rpc-transport-errors-stretch-doesnt-respond-to-commands","text":"If more than one instance of Stretch Body's Robot class is instantiated at a time, Stretch Body will report communication errors and will not always execute motion commands as expected. This is because Robot manages communications with the robot hardware and it doesn't support multiple writes to the USB devices. These errors can appear as Transport RX Error on RPC_ACK_SEND_BLOCK_MORE False 0 102 ---- Debug Exception --------------- New RPC ------------------------- Framer sent RPC_START_NEW_RPC ... or as IOError(None): None ... To check if a instance of Robot is already instantiated, you may use the Unix top command to monitor active processes. You may use the Unix pkill command to end the background instance of Robot. $ pkill -9 python As shipped, Stretch launches stretch_xbox_controller_teleop.py upon boot. It is necessary to turn off this automatic launch feature, otherwise your own Robot instance will conflict with this script. Additionally, if you are logged into multiple accounts, a Robot instance may be active in another user account. To turn it off, search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop'. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"RPC Transport Errors (Stretch doesn't respond to commands)"},{"location":"untethered_operation/","text":"Untethered Operation As a mobile manipulator, the Stretch RE1 can only go so far when tethered to the monitor, keyboard, and mouse setup. This guide will explain three methods of setting up the Stretch RE1 for untethered usage. These methods typically require a wireless network, but it is possible to set up any of these methods without a wireless network by setting up a hotspot . Remote Desktop Requirements This is the recommended approach if you are running Windows or MacOS. This method requires a Virtual Network Computing (VNC) package. Using any of the free or paid options available for Windows, MacOS, and Chrome will be fine since they all use the Remote Frame Buffer (RFB) protocol to communicate with the robot. If you're using Ubuntu, Remmina Remote Desktop Client will be installed by default. How To While the Stretch RE1 is tethered to the monitor, keyboard, and mouse setup, first verify that the robot is connected to the wireless network then install Vino VNC server using the following command: $ sudo apt install vino Go to System Settings. Select the Sharing tab and turn it on then, turn on Screen Sharing and choose a password. If you plan to connect to the robot from a Windows or MacOS machine, then open a terminal and run the following command. $ sudo gsettings set org.gnome.Vino require-encryption false Finally, we need the robot's IP address, username, and password. Open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. The robot's default username and password is printed on papers that came in the tools box alongside the robot. VNC will only function properly with an external display attached to the robot. Using a dummy HDMI dongle when operating the robot untethered via VNC is recommended. One possible dummy HDMI dongle can be found on Amazon here . On your computer, connect to the same wireless network as the robot and open the VNC package being used. Using the robot's IP address and username, initialize a new connection to the robot. The robot's desktop will open in a new window. SSH & X Server Requirements This is the recommended approach if you are running an Unix-based operating system, like Ubuntu or Arch Linux. This method requires both SSH and X Server to be installed. While most Unix-based operating systems have both installed by default, MacOS will only have SSH installed and Windows has neither installed by default. It is possible to install these tools for MacOS or Windows. How To While the Remote Desktop approach is easy to set up, graphics and interaction with the remote desktop is often slow. In this method, we will use SSH and X Server to accomplish the same a bit faster. SSH stands for Secure Shell, enabling one to remotely use the terminal (shell) of another machine. X Server is used on many Unix variants to render the Windowed GUI of applications. With SSH and X Server, it is possible to render a Windowed GUI of an application running on the robot on your computer's screen. The first step is to identify the robot's IP address on the local network. While the Stretch RE1 is tethered to the monitor, keyboard, and mouse, verify that the robot is connected to a wireless network. Then, open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. Using any other machine on the same local network, I can SSH into the robot using this IP address. Take note of the username and password of the robot. The default combo is printed on papers that came in the tools box alongside the robot. To SSH into the robot, run the following. It will require the password and may ask you to add the robot to the known hosts. $ ssh -X username@ip-address Now that you're SSH-ed into the robot, you can disconnect any wires from the robot. You can accomplish any of the same tasks through the terminal. For example, you can type in ipython and interact with the robot using Stretch Body, as explained in the Getting Started Guide . Furthermore, Windowed GUI applications that would have displayed on the monitor will now display on your SSH-ed machine. For example, we can open Rviz to visualize what the robot is seeing. Open two terminals and SSH into the robot as explained above. In the first, run roslaunch stretch_core stretch_driver.launch . You should see some information print out in the terminal. In the second, run rviz . A window will pop up and information about the robot can be visualized by clicking on Add -> RobotModel and Add -> By Topic -> /Scan . Additional information on how to use ROS tools can be found in ROS's tutorials or in our Stretch ROS guides . Moving files to/from the robot wirelessly It's common to need to move files to/from the robot wirelessly and a tool similar to SSH can help with this: Secure Copy (SCP). To send the files from your computer to the robot, run: $ scp ./filename username@ip-address:~/path/to/put/it/ To copy the files from the robot to your computer, run the reverse: $ scp username@ip-address:/path/to/filename ~/path/to/put/it/ This works for copying directories and their contents as well. ROS Remote Master Requirements This is the recommended approach if you are running Ubuntu 16.04/18.04/20.04 with ROS kinetic/melodic/noetic installed on your computer. This method will utilize the local installation of ROS tools, such as Rviz, rostopic, and rosservice, while retrieving data from the robot. How To If you are developing ROS code to test on the Stretch RE1 and you already have ROS installed on your Ubuntu computer, then there is an easier way of using Rviz than the method described in SSH & X Server . In the ROS world, this concept is known as \"remote master\". First, identify your robot's and computer's IP address on the network (e.g. using ifconfig ). These are robot-ip-address and computer-ip-address respectively. Next, run the following on the robot: $ export ROS_IP = robot-ip-address $ export ROS_MASTER_URI = http://robot-ip-address:11311/ Next, start the ROS launch files on the robot as you normally would. Finally, on your computer, run: $ export ROS_IP = computer-ip-address $ export ROS_MASTER_URI = http://robot-ip-address:11311 If you use ROS Remote Master often, you can export these environment variables in your bashrc . Tools like rostopic and rosservice can now be used on your computer as you would have on the robot. For example, you can use rostopic list on your computer to print out the topics available on the robot. Additional information can be found in the ROS Multiple Machines Tutorial . Visualizing remotely with RViz If you'd like to visualize the robot model on your computer using Rviz, you'll need to setup a ROS workspace with the Stretch Description package. First, copy over the ~/stretch_user directory from the robot to your computer (e.g. using Secure Copy ). Second, clone Stretch Install , and checkout the noetic branch if you are running ROS Noetic on the robot. Finally, run the stretch_create_ros_workspace.sh script. A ROS Workspace with the Stretch ROS packages is now set up on your computer. Furthermore, Stretch Description has been set up with your robot's calibrated URDF. We can now use remote master and Rviz to visualize what the robot is seeing on your computer. Open two terminals. In the first, SSH into the robot and run roslaunch stretch_core stretch_driver.launch . You should see some information print out in the terminal. In the second, run rviz . A window will pop up and information about the robot can be visualized by clicking on Add -> RobotModel and Add -> By Topic -> /Scan . Additional information on how to use Rviz can be found in ROS's tutorials or in our Stretch ROS guides . Additional Ideas Although the methods described above will enable you to wirelessly control the robot, there are a number of way to improve usability and security of your wireless connection. These ideas are listed here. Hotspot Often the trouble with wirelessly controlling the robot is the network. If your network is using industrial security like 2-factor authentication, there may be trouble connecting the robot to the network. If the network is servicing a large number of users, the connection may feel sluggish. The alternative is to skip the network by connecting directly to the robot. After starting a hotspot on the robot, you can follow instructions for any of the methods described above to control the robot. The trade-off is that while connected to the robot's hotspot, you will be unable to connect to the internet. To set up the robot's hotspot, visit the Ubuntu Wifi Settings page in the robot. Click on the hamburger menu in the top right and select \"Enable hotspot\". From your local machine, connect to the robot's hotspot and save the credentials. To change the hotspot's password or enable the hotspot automatically whenever the robot boots, see the following Stackoverflow post . VS Code Remote Development It is possible to simultaneously develop code on the robot while running wireless experiments using the Remote Development Extension provided by the VS Code IDE. If you're already using the VS Code IDE , navigate to the Extensions tab and search for Remote Development Extension by Microsoft . After installing, click on a green button in the bottom left of the screen and then select \"Remote-SSH: Connect to Host\". Setting this up for the first time will require you to know the robot's IP address and username. Add a new host with the information. While connecting, VS Code will ask you for the password of the robot. Once you are connected, you can open any folder and edit the code remotely. Combined with the method explained in SSH & X Server , this is a powerful method of iteratively developing code while testing it. Static IP Address Routers that serve wireless networks often dynamically assign IP address to machines that connect to the network. This means that your robot's IP address may have changed since the last time you turned it on. Since it becomes a pain to connect to the monitor, keyboard, and mouse setup every time to run ifconfig , many users prefer to assign the robot a static IP address. If you control the router, visit the router's settings page to set up the robot's static IP address. It is common at universities and companies to have staff dedicated to the management of the network. This staff will often be able to set up a static IP address for the robot. Public Key Authentication The method of SSH described in SSH & X Server uses basic password authentication when connecting. There is a better and more-secure method of SSH-ing into the robot called Public Key Authentication. This method will allow multiple developers to SSH into the robot without having to share the robot's admin password. The first step is to generate public and private keys on your computer. Linux and MacOS machines can simply open the terminal and run: $ ssh-keygen -t ed25519 -f <key_filepath_without_extension> -C \"<some comment>\" It will prompt you to enter a password. If you do, you'll need it to use the private key when you SSH into the robot. Next, we give the robot the public key. Linux and MacOS machines can run: $ ssh-copy-id -i <key_filepath_without_extension> username@ip-address This requires you to know the username and ip-address of the robot. Instructions on how to find this information is found in the SSH & X Server section. You may now SSH into the robot as normal, and no prompt for the robot's password will appear. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Untethered Operation"},{"location":"untethered_operation/#untethered-operation","text":"As a mobile manipulator, the Stretch RE1 can only go so far when tethered to the monitor, keyboard, and mouse setup. This guide will explain three methods of setting up the Stretch RE1 for untethered usage. These methods typically require a wireless network, but it is possible to set up any of these methods without a wireless network by setting up a hotspot .","title":"Untethered Operation"},{"location":"untethered_operation/#remote-desktop","text":"","title":"Remote Desktop"},{"location":"untethered_operation/#requirements","text":"This is the recommended approach if you are running Windows or MacOS. This method requires a Virtual Network Computing (VNC) package. Using any of the free or paid options available for Windows, MacOS, and Chrome will be fine since they all use the Remote Frame Buffer (RFB) protocol to communicate with the robot. If you're using Ubuntu, Remmina Remote Desktop Client will be installed by default.","title":"Requirements"},{"location":"untethered_operation/#how-to","text":"While the Stretch RE1 is tethered to the monitor, keyboard, and mouse setup, first verify that the robot is connected to the wireless network then install Vino VNC server using the following command: $ sudo apt install vino Go to System Settings. Select the Sharing tab and turn it on then, turn on Screen Sharing and choose a password. If you plan to connect to the robot from a Windows or MacOS machine, then open a terminal and run the following command. $ sudo gsettings set org.gnome.Vino require-encryption false Finally, we need the robot's IP address, username, and password. Open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. The robot's default username and password is printed on papers that came in the tools box alongside the robot. VNC will only function properly with an external display attached to the robot. Using a dummy HDMI dongle when operating the robot untethered via VNC is recommended. One possible dummy HDMI dongle can be found on Amazon here . On your computer, connect to the same wireless network as the robot and open the VNC package being used. Using the robot's IP address and username, initialize a new connection to the robot. The robot's desktop will open in a new window.","title":"How To"},{"location":"untethered_operation/#ssh-x-server","text":"","title":"SSH &amp; X Server"},{"location":"untethered_operation/#requirements_1","text":"This is the recommended approach if you are running an Unix-based operating system, like Ubuntu or Arch Linux. This method requires both SSH and X Server to be installed. While most Unix-based operating systems have both installed by default, MacOS will only have SSH installed and Windows has neither installed by default. It is possible to install these tools for MacOS or Windows.","title":"Requirements"},{"location":"untethered_operation/#how-to_1","text":"While the Remote Desktop approach is easy to set up, graphics and interaction with the remote desktop is often slow. In this method, we will use SSH and X Server to accomplish the same a bit faster. SSH stands for Secure Shell, enabling one to remotely use the terminal (shell) of another machine. X Server is used on many Unix variants to render the Windowed GUI of applications. With SSH and X Server, it is possible to render a Windowed GUI of an application running on the robot on your computer's screen. The first step is to identify the robot's IP address on the local network. While the Stretch RE1 is tethered to the monitor, keyboard, and mouse, verify that the robot is connected to a wireless network. Then, open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. Using any other machine on the same local network, I can SSH into the robot using this IP address. Take note of the username and password of the robot. The default combo is printed on papers that came in the tools box alongside the robot. To SSH into the robot, run the following. It will require the password and may ask you to add the robot to the known hosts. $ ssh -X username@ip-address Now that you're SSH-ed into the robot, you can disconnect any wires from the robot. You can accomplish any of the same tasks through the terminal. For example, you can type in ipython and interact with the robot using Stretch Body, as explained in the Getting Started Guide . Furthermore, Windowed GUI applications that would have displayed on the monitor will now display on your SSH-ed machine. For example, we can open Rviz to visualize what the robot is seeing. Open two terminals and SSH into the robot as explained above. In the first, run roslaunch stretch_core stretch_driver.launch . You should see some information print out in the terminal. In the second, run rviz . A window will pop up and information about the robot can be visualized by clicking on Add -> RobotModel and Add -> By Topic -> /Scan . Additional information on how to use ROS tools can be found in ROS's tutorials or in our Stretch ROS guides .","title":"How To"},{"location":"untethered_operation/#moving-files-tofrom-the-robot-wirelessly","text":"It's common to need to move files to/from the robot wirelessly and a tool similar to SSH can help with this: Secure Copy (SCP). To send the files from your computer to the robot, run: $ scp ./filename username@ip-address:~/path/to/put/it/ To copy the files from the robot to your computer, run the reverse: $ scp username@ip-address:/path/to/filename ~/path/to/put/it/ This works for copying directories and their contents as well.","title":"Moving files to/from the robot wirelessly"},{"location":"untethered_operation/#ros-remote-master","text":"","title":"ROS Remote Master"},{"location":"untethered_operation/#requirements_2","text":"This is the recommended approach if you are running Ubuntu 16.04/18.04/20.04 with ROS kinetic/melodic/noetic installed on your computer. This method will utilize the local installation of ROS tools, such as Rviz, rostopic, and rosservice, while retrieving data from the robot.","title":"Requirements"},{"location":"untethered_operation/#how-to_2","text":"If you are developing ROS code to test on the Stretch RE1 and you already have ROS installed on your Ubuntu computer, then there is an easier way of using Rviz than the method described in SSH & X Server . In the ROS world, this concept is known as \"remote master\". First, identify your robot's and computer's IP address on the network (e.g. using ifconfig ). These are robot-ip-address and computer-ip-address respectively. Next, run the following on the robot: $ export ROS_IP = robot-ip-address $ export ROS_MASTER_URI = http://robot-ip-address:11311/ Next, start the ROS launch files on the robot as you normally would. Finally, on your computer, run: $ export ROS_IP = computer-ip-address $ export ROS_MASTER_URI = http://robot-ip-address:11311 If you use ROS Remote Master often, you can export these environment variables in your bashrc . Tools like rostopic and rosservice can now be used on your computer as you would have on the robot. For example, you can use rostopic list on your computer to print out the topics available on the robot. Additional information can be found in the ROS Multiple Machines Tutorial .","title":"How To"},{"location":"untethered_operation/#visualizing-remotely-with-rviz","text":"If you'd like to visualize the robot model on your computer using Rviz, you'll need to setup a ROS workspace with the Stretch Description package. First, copy over the ~/stretch_user directory from the robot to your computer (e.g. using Secure Copy ). Second, clone Stretch Install , and checkout the noetic branch if you are running ROS Noetic on the robot. Finally, run the stretch_create_ros_workspace.sh script. A ROS Workspace with the Stretch ROS packages is now set up on your computer. Furthermore, Stretch Description has been set up with your robot's calibrated URDF. We can now use remote master and Rviz to visualize what the robot is seeing on your computer. Open two terminals. In the first, SSH into the robot and run roslaunch stretch_core stretch_driver.launch . You should see some information print out in the terminal. In the second, run rviz . A window will pop up and information about the robot can be visualized by clicking on Add -> RobotModel and Add -> By Topic -> /Scan . Additional information on how to use Rviz can be found in ROS's tutorials or in our Stretch ROS guides .","title":"Visualizing remotely with RViz"},{"location":"untethered_operation/#additional-ideas","text":"Although the methods described above will enable you to wirelessly control the robot, there are a number of way to improve usability and security of your wireless connection. These ideas are listed here.","title":"Additional Ideas"},{"location":"untethered_operation/#hotspot","text":"Often the trouble with wirelessly controlling the robot is the network. If your network is using industrial security like 2-factor authentication, there may be trouble connecting the robot to the network. If the network is servicing a large number of users, the connection may feel sluggish. The alternative is to skip the network by connecting directly to the robot. After starting a hotspot on the robot, you can follow instructions for any of the methods described above to control the robot. The trade-off is that while connected to the robot's hotspot, you will be unable to connect to the internet. To set up the robot's hotspot, visit the Ubuntu Wifi Settings page in the robot. Click on the hamburger menu in the top right and select \"Enable hotspot\". From your local machine, connect to the robot's hotspot and save the credentials. To change the hotspot's password or enable the hotspot automatically whenever the robot boots, see the following Stackoverflow post .","title":"Hotspot"},{"location":"untethered_operation/#vs-code-remote-development","text":"It is possible to simultaneously develop code on the robot while running wireless experiments using the Remote Development Extension provided by the VS Code IDE. If you're already using the VS Code IDE , navigate to the Extensions tab and search for Remote Development Extension by Microsoft . After installing, click on a green button in the bottom left of the screen and then select \"Remote-SSH: Connect to Host\". Setting this up for the first time will require you to know the robot's IP address and username. Add a new host with the information. While connecting, VS Code will ask you for the password of the robot. Once you are connected, you can open any folder and edit the code remotely. Combined with the method explained in SSH & X Server , this is a powerful method of iteratively developing code while testing it.","title":"VS Code Remote Development"},{"location":"untethered_operation/#static-ip-address","text":"Routers that serve wireless networks often dynamically assign IP address to machines that connect to the network. This means that your robot's IP address may have changed since the last time you turned it on. Since it becomes a pain to connect to the monitor, keyboard, and mouse setup every time to run ifconfig , many users prefer to assign the robot a static IP address. If you control the router, visit the router's settings page to set up the robot's static IP address. It is common at universities and companies to have staff dedicated to the management of the network. This staff will often be able to set up a static IP address for the robot.","title":"Static IP Address"},{"location":"untethered_operation/#public-key-authentication","text":"The method of SSH described in SSH & X Server uses basic password authentication when connecting. There is a better and more-secure method of SSH-ing into the robot called Public Key Authentication. This method will allow multiple developers to SSH into the robot without having to share the robot's admin password. The first step is to generate public and private keys on your computer. Linux and MacOS machines can simply open the terminal and run: $ ssh-keygen -t ed25519 -f <key_filepath_without_extension> -C \"<some comment>\" It will prompt you to enter a password. If you do, you'll need it to use the private key when you SSH into the robot. Next, we give the robot the public key. Linux and MacOS machines can run: $ ssh-copy-id -i <key_filepath_without_extension> username@ip-address This requires you to know the username and ip-address of the robot. Instructions on how to find this information is found in the SSH & X Server section. You may now SSH into the robot as normal, and no prompt for the robot's password will appear. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Public Key Authentication"},{"location":"updating_software/","text":"Updating Stretch Software Stretch's software is improved with new features and bug fixes with each update. In this guide, we cover when and how to update the various software components on your Stretch RE1. When to Update We develop our software publicly on Github, allowing anyone to follow/propose the development of a code feature or bug fix. While we wholeheartedly welcome collaboration on Github, it is not necessary to be active on Github to follow our software releases. We announce every major release of software on our forum . These are stable releases with code that has been extensively tested on many Stretch RE1s. To be notified of new releases, create an account on the forum and click the bell icon in the top left of the announcements section . The forum is also available to report issues and ask questions about any of our software packages. How to Update Each Stretch RE1 is shipped with firmware, a Python SDK, and ROS packages developed specifically for Stretch. At the moment, there are three separate processes for updating each of these components. Stretch ROS Stretch ROS is the Robot Operating System (ROS) interface to the robot. Many robotics developers find ROS useful to bootstrap their robotics software developments. You may update it using the following commands: $ roscd stretch_core $ git pull Stretch Body Stretch Body is the Python SDK to the robot. It abstracts away the low level details of communication with the embedded devices and provides an intuitive API to working with the robot. You may update it using the following commands: $ pip install -U hello-robot-stretch-body $ pip install -U hello-robot-stretch-body-tools $ pip install -U hello-robot-stretch-factory $ pip3 install -U hello_robot_stretch_body_tools_py3 Stretch Firmware The firmware and the Python SDK (called Stretch Body) communicate on an established protocol. Therefore, it is important to maintain a protocol match between the different firmware and Stretch Body versions. Fortunately, there is a script that handles this automatically. In the command line, run the following command: $ RE1_firmware_updater.py --status This script will automatically determine what version is currently running on the robot and provide a recommendation for a next step. Follow the next steps provided by the firmware updater script. Ubuntu The operating system upon which Stretch RE1 is built is called Ubuntu. This operating system provides the underlying packages that power Stretch's software packages. Furthermore, users of Stretch depend on this operating system and the underlying packages to develop software on Stretch. Therefore, it is important to keep the OS and these underlying packages up to date. In the command line, run the following command: $ sudo apt update $ sudo apt upgrade Apt is the package manager that handles updates for all Ubuntu packages. Troubleshooting Firmware Mismatch Error When working with Stretch Body, if you see the following error: ---------------- Firmware protocol mismatch on /dev/XXXX. Protocol on board is pX. Valid protocol is: pX. Disabling device. Please upgrade the firmware and/or version of Stretch Body. ---------------- This error appears because the low level Python SDK and the firmware cannot communicate to each other. There is a protocol mismatch preventing communication between the two. Simply run the following script and follow its recommendations to upgrade/downgrade the firmware as necessary to match the protocol level of Stretch Body. $ RE1_firmware_updater.py --status All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Updating Stretch Software"},{"location":"updating_software/#updating-stretch-software","text":"Stretch's software is improved with new features and bug fixes with each update. In this guide, we cover when and how to update the various software components on your Stretch RE1.","title":"Updating Stretch Software"},{"location":"updating_software/#when-to-update","text":"We develop our software publicly on Github, allowing anyone to follow/propose the development of a code feature or bug fix. While we wholeheartedly welcome collaboration on Github, it is not necessary to be active on Github to follow our software releases. We announce every major release of software on our forum . These are stable releases with code that has been extensively tested on many Stretch RE1s. To be notified of new releases, create an account on the forum and click the bell icon in the top left of the announcements section . The forum is also available to report issues and ask questions about any of our software packages.","title":"When to Update"},{"location":"updating_software/#how-to-update","text":"Each Stretch RE1 is shipped with firmware, a Python SDK, and ROS packages developed specifically for Stretch. At the moment, there are three separate processes for updating each of these components.","title":"How to Update"},{"location":"updating_software/#stretch-ros","text":"Stretch ROS is the Robot Operating System (ROS) interface to the robot. Many robotics developers find ROS useful to bootstrap their robotics software developments. You may update it using the following commands: $ roscd stretch_core $ git pull","title":"Stretch ROS"},{"location":"updating_software/#stretch-body","text":"Stretch Body is the Python SDK to the robot. It abstracts away the low level details of communication with the embedded devices and provides an intuitive API to working with the robot. You may update it using the following commands: $ pip install -U hello-robot-stretch-body $ pip install -U hello-robot-stretch-body-tools $ pip install -U hello-robot-stretch-factory $ pip3 install -U hello_robot_stretch_body_tools_py3","title":"Stretch Body"},{"location":"updating_software/#stretch-firmware","text":"The firmware and the Python SDK (called Stretch Body) communicate on an established protocol. Therefore, it is important to maintain a protocol match between the different firmware and Stretch Body versions. Fortunately, there is a script that handles this automatically. In the command line, run the following command: $ RE1_firmware_updater.py --status This script will automatically determine what version is currently running on the robot and provide a recommendation for a next step. Follow the next steps provided by the firmware updater script.","title":"Stretch Firmware"},{"location":"updating_software/#ubuntu","text":"The operating system upon which Stretch RE1 is built is called Ubuntu. This operating system provides the underlying packages that power Stretch's software packages. Furthermore, users of Stretch depend on this operating system and the underlying packages to develop software on Stretch. Therefore, it is important to keep the OS and these underlying packages up to date. In the command line, run the following command: $ sudo apt update $ sudo apt upgrade Apt is the package manager that handles updates for all Ubuntu packages.","title":"Ubuntu"},{"location":"updating_software/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"updating_software/#firmware-mismatch-error","text":"When working with Stretch Body, if you see the following error: ---------------- Firmware protocol mismatch on /dev/XXXX. Protocol on board is pX. Valid protocol is: pX. Disabling device. Please upgrade the firmware and/or version of Stretch Body. ---------------- This error appears because the low level Python SDK and the firmware cannot communicate to each other. There is a protocol mismatch preventing communication between the two. Simply run the following script and follow its recommendations to upgrade/downgrade the firmware as necessary to match the protocol level of Stretch Body. $ RE1_firmware_updater.py --status All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Firmware Mismatch Error"},{"location":"stretch-body/","text":"Overview The stretch_body repository includes Python packages that allow a developer to interact with the hardware of the Stretch RE1 robot. These packages are: * hello-robot-stretch-body : python library to interface with Stretch RE1 * hello-robot-stretch-body-tools : useful commandline tools for using Stretch RE1 Python2 version of packages can be installed by: pip2 install -U hello-robot-stretch-body pip2 install -U hello-robot-stretch-body-tools Python3 version of packages can be installed by: pip3 install -U hello-robot-stretch-body pip3 install -U hello-robot-stretch-body-tools See docs.hello-robot.com for documentation on using Stretch RE1. In particular, see the Stretch Body User Guide for information on using these packages. Testing and Development See Stretch Body's README and Stretch Body Commandline Tool's README for information on testing/developing these packages. License Each subdirectory contains a LICENSE.md file that applies to the directory's contents. This software is intended for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. For further information including inquiries about dual licensing, please contact Hello Robot Inc.","title":"Installation"},{"location":"stretch-body/#overview","text":"The stretch_body repository includes Python packages that allow a developer to interact with the hardware of the Stretch RE1 robot. These packages are: * hello-robot-stretch-body : python library to interface with Stretch RE1 * hello-robot-stretch-body-tools : useful commandline tools for using Stretch RE1 Python2 version of packages can be installed by: pip2 install -U hello-robot-stretch-body pip2 install -U hello-robot-stretch-body-tools Python3 version of packages can be installed by: pip3 install -U hello-robot-stretch-body pip3 install -U hello-robot-stretch-body-tools See docs.hello-robot.com for documentation on using Stretch RE1. In particular, see the Stretch Body User Guide for information on using these packages.","title":"Overview"},{"location":"stretch-body/#testing-and-development","text":"See Stretch Body's README and Stretch Body Commandline Tool's README for information on testing/developing these packages.","title":"Testing and Development"},{"location":"stretch-body/#license","text":"Each subdirectory contains a LICENSE.md file that applies to the directory's contents. This software is intended for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. For further information including inquiries about dual licensing, please contact Hello Robot Inc.","title":"License"},{"location":"stretch-body/stretch_body_api/","text":"Stretch Body API Reference Stretch Body is the Python interface to working with the Stretch RE1. This page serves as a reference of the interfaces defined in the stretch_body library. See the Stretch Body Guide for a tutorial to working with this library. The Robot Class Using the Robot class The most common interface to Stretch is the Robot class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 11 import stretch_body.robot r = stretch_body . robot . Robot () if not r . startup (): exit () # failed to start robot! # home the joints to find zero, if necessary if not r . is_calibrated (): r . home () # interact with the robot here The startup() and home() methods starts communication with and homes each of the robot's devices, respectively. Through the Robot class, users can interact with all other devices on the robot. For example, continuing the example above: 12 13 14 15 16 17 18 19 20 21 22 23 # moving joints on the robot r . arm . pretty_print () r . lift . pretty_print () r . base . pretty_print () r . head . pretty_print () r . end_of_arm . pretty_print () # other devices on the robot r . wacc . pretty_print () r . pimu . pretty_print () r . stop () Each of these devices are defined in other modules within stretch_body . In the following section , we'll look at the API of these classes. The stop() method shuts down communication with the robot's devices. All of Robot's subroutines are documented below. stretch_body.robot.Robot ( Device ) API to the Stretch RE1 Robot __init__ ( self ) special startup ( self ) To be called once after class instantiation. Prepares devices for communications and motion Returns bool true if startup of robot succeeded stop ( self ) To be called once before exiting a program Cleanly stops down motion and communication get_status ( self ) Thread safe and atomic read of current Robot status data Returns as a dict. pretty_print ( self ) push_command ( self ) Cause all queued up RPC commands to be sent down to Devices follow_trajectory ( self ) stop_trajectory ( self ) is_calibrated ( self ) Returns true if homing-calibration has been run all joints that require it stow ( self ) Cause the robot to move to its stow position Blocking. home ( self ) Cause the robot to home its joints by moving to hardstops Blocking. The Device Classes The stretch_body library is modular in design. Each subcomponent of Stretch is defined in its own class and the Robot class provides an interface that ties all of these classes together. This modularity allows users to plug in new/modified subcomponents into the Robot interface by extending a device class. It is possible to interface with a single subcomponent of Stretch by initializing its device class directly. In this section, we'll look at the API of seven device classes: the arm , lift , base , head , end of arm , wacc , and pimu subcomponents of Stretch. Using the Arm class The interface to Stretch's telescoping arm is the Arm class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 import stretch_body.arm a = stretch_body . arm . Arm () a . motor . disable_sync_mode () if not a . startup (): exit () # failed to start arm! a . home () # interact with the arm here Since both Arm and Robot subclass Device , the same startup() and stop() methods are available here, as well as other Device methods such as home() . Using the Arm class, we can read the arm's current state and send commands to the joint. For example, continuing the example above: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 starting_position = a . status [ 'pos' ] # move out by 10cm a . move_to ( starting_position + 0.1 ) a . push_command () a . motor . wait_until_at_setpoint () # move back to starting position quickly a . move_to ( starting_position , v_m = 0.2 , a_m = 0.25 ) a . push_command () a . motor . wait_until_at_setpoint () a . move_by ( 0.1 ) # move out by 10cm a . push_command () a . motor . wait_until_at_setpoint () The move_to() and move_by() methods queue absolute and relative commands to the arm respectively, while the nonblocking push_command() method pushes the queued command to the hardware for execution. Arm's attribute motor , an instance of the Stepper class, has wait_until_at_setpoint() which blocks program execution until the joint reaches the commanded goal. With P1 or greater firmware installed, it is also possible to queue a waypoint trajectory for the arm to follow: 26 27 28 29 30 31 32 33 34 35 36 starting_position = a . status [ 'pos' ] # queue a trajectory consisting of four waypoints a . trajectory . add ( t_s = 0 , x_m = starting_position ) a . trajectory . add ( t_s = 3 , x_m = 0.15 ) a . trajectory . add ( t_s = 6 , x_m = 0.1 ) a . trajectory . add ( t_s = 9 , x_m = 0.2 ) # trigger trajectory execution a . follow_trajectory () import time ; time . sleep ( 9 ) Arm's attribute trajectory , an instance of the PrismaticTrajectory class, has add() which adds a single waypoint in a linear sliding trajectory. For a well formed trajectory (see is_valid() ), the follow_trajectory() method kicks off trajectory following for the telescoping arm. It is also possible to dynamically restrict the arm joint's range: 37 38 39 40 41 42 43 44 45 46 47 48 49 50 range_upper_limit = 0.3 # meters # set soft limits on arm's range a . set_soft_motion_limit_min ( 0 ) a . set_soft_motion_limit_max ( range_upper_limit ) a . push_command () # command the arm outside the valid range a . move_to ( 0.4 ) a . push_command () a . motor . wait_until_at_setpoint () print ( a . status [ 'pos' ]) # we should expect to see ~0.3 a . stop () The set_soft_motion_limit_min/max() methods form the basis of an experimental self-collision avoidance system built into Stretch Body. All of Arm's subroutines are documented below. stretch_body.arm.Arm ( Device ) API to the Stretch RE1 Arm __init__ ( self ) special startup ( self , threaded = True ) Starts machinery required to interface with this device Parameters threaded : bool whether a thread manages hardware polling/pushing in the background Returns bool whether the startup procedure succeeded stop ( self ) Shuts down machinery started in startup() pull_status ( self ) push_command ( self ) pretty_print ( self ) get_soft_motion_limits ( self ) Return the currently applied soft motion limits: [min, max] The soft motion limit restricts joint motion to be <= its physical limits. There are three types of limits: Hard: The physical limits Collision: Limits set by RobotCollision to avoid collisions User: Limits set by the user software The joint is limited to the most restrictive range of the Hard / Collision/ User values. Specifying a value of None for a limit indicates that no constraint exists for that limit type. This allows a User limits and Collision limits to coexist. For example, a user can temporarily restrict the range of motion beyond the current collision limits. Then, by commanding User limits of None, the joint limits will revert back to the collision settings. set_soft_motion_limit_min ( self , x , limit_type = 'user' ) x: value to set a joints limit to limit_type: 'user' or 'collision' set_soft_motion_limit_max ( self , x , limit_type = 'user' ) x: value to set a joints limit to limit_type: 'user' or 'collision' set_velocity ( self , v_m , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) move_to ( self , x_m , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) x_m: commanded absolute position (meters). x_m=0 is retracted. x_m=~0.5 is extended v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, retraction direction) req_calibration: Disallow motion prior to homing move_by ( self , x_m , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) x_m: commanded incremental motion (meters). v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, retraction direction) req_calibration: Disallow motion prior to homing follow_trajectory ( self , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True , move_to_start_point = True ) Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method. Parameters v_m : float velocity limit for trajectory in meters per second a_m : float acceleration limit for trajectory in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N : float force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N : float force threshold to stop motion (~Newtons, retraction direction) req_calibration : bool whether to allow motion prior to homing move_to_start_point : bool whether to move to the trajectory's start to avoid a jump, this time to move doesn't count against the trajectory's timeline update_trajectory ( self ) Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method. stop_trajectory ( self ) Stop waypoint trajectory immediately and resets hardware motor_current_to_translate_force ( self , i ) translate_force_to_motor_current ( self , f ) motor_rad_to_translate ( self , ang ) translate_to_motor_rad ( self , arm_m ) home ( self , single_stop = True , measuring = False ) Home to hardstops step_sentry ( self , robot ) Using the Lift class The interface to Stretch's lift is the Lift class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 import stretch_body.lift l = stretch_body . lift . Lift () l . motor . disable_sync_mode () if not l . startup (): exit () # failed to start lift! l . home () # interact with the lift here The startup() and home() methods are extended from the Device class. Reading the lift's current state and sending commands to the joint occurs similarly to the Arm : 11 12 13 14 15 16 starting_position = l . status [ 'pos' ] # move up by 10cm l . move_to ( starting_position + 0.1 ) l . push_command () l . motor . wait_until_at_setpoint () Lift's attribute status is a dictionary of the joint's current status. This state information is updated in the background in real time by default (disable by initializing as startup(threading=False) ). Use the pretty_print() method to print out this state info in a human interpretable format. Setting up waypoint trajectories for the lift is also similar to the Arm : 17 18 19 20 21 22 23 24 25 26 starting_position = l . status [ 'pos' ] # queue a trajectory consisting of three waypoints l . trajectory . add ( t_s = 0 , x_m = starting_position , v_m = 0.0 ) l . trajectory . add ( t_s = 3 , x_m = 0.5 , v_m = 0.0 ) l . trajectory . add ( t_s = 6 , x_m = 0.6 , v_m = 0.0 ) # trigger trajectory execution l . follow_trajectory () import time ; time . sleep ( 6 ) Lift's attribute trajectory is also an instance of the PrismaticTrajectory class, and by providing the instantaneous velocity argument v_m to the add() method, a cubic spline has been loaded into the joint's trajectory . The call to follow_trajectory() begins hardware tracking of the spline. Finally, setting soft motion limits for the lift's range happens using: 27 28 29 30 31 32 # cut out 0.2m from the top and bottom of the lift's range l . set_soft_motion_limit_min ( 0.2 ) l . set_soft_motion_limit_max ( 0.8 ) l . push_command () l . stop () The set_soft_motion_limit_min/max() methods perform clipping of the joint's range at the firmware level (can persist across reboots). All of Lift's subroutines are documented below. stretch_body.lift.Lift ( Device ) API to the Stretch RE1 Lift __init__ ( self ) special startup ( self , threaded = True ) Starts machinery required to interface with this device Parameters threaded : bool whether a thread manages hardware polling/pushing in the background Returns bool whether the startup procedure succeeded stop ( self ) Shuts down machinery started in startup() pull_status ( self ) push_command ( self ) pretty_print ( self ) get_soft_motion_limits ( self ) Return the currently applied soft motion limits: [min, max] The soft motion limit restricts joint motion to be <= its physical limits. There are three types of limits: Hard: The physical limits Collision: Limits set by RobotCollision to avoid collisions User: Limits set by the user software The joint is limited to the most restrictive range of the Hard / Collision/ User values. Specifying a value of None for a limit indicates that no constraint exists for that limit type. This allows a User limits and Collision limits to coexist. For example, a user can temporarily restrict the range of motion beyond the current collision limits. Then, by commanding User limits of None, the joint limits will revert back to the collision settings. set_soft_motion_limit_min ( self , x , limit_type = 'user' ) x: value to set a joints limit to limit_type: 'user' or 'collision' set_soft_motion_limit_max ( self , x , limit_type = 'user' ) x: value to set a joints limit to limit_type: 'user' or 'collision' set_velocity ( self , v_m , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) move_to ( self , x_m , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) x_m: commanded absolute position (meters). x_m=0 is down. x_m=~1.1 is up v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, down direction) req_calibration: Disallow motion prior to homing move_by ( self , x_m , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) x_m: commanded incremental motion (meters). v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, down direction) req_calibration: Disallow motion prior to homing follow_trajectory ( self , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True , move_to_start_point = True ) Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method. Parameters v_m : float velocity limit for trajectory in meters per second a_m : float acceleration limit for trajectory in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N : float force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N : float force threshold to stop motion (~Newtons, down direction) req_calibration : bool whether to allow motion prior to homing move_to_start_point : bool whether to move to the trajectory's start to avoid a jump, this time to move doesn't count against the trajectory's timeline update_trajectory ( self ) Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method. stop_trajectory ( self ) Stop waypoint trajectory immediately and resets hardware motor_current_to_translate_force ( self , i ) translate_force_to_motor_current ( self , f ) motor_rad_to_translate_m ( self , ang ) translate_to_motor_rad ( self , lift_m ) home ( self , measuring = False ) step_sentry ( self , robot ) Using the Base class Item Notes A Drive wheels 4 inch diameter, urethane rubber shore 60A B Cliff sensors Sharp GP2Y0A51SK0F, Analog, range 2-15 cm C Mecanum wheel Diameter 50mm The interface to Stretch's mobile base is the Base class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.base b = stretch_body . base . Base () b . left_wheel . disable_sync_mode () b . right_wheel . disable_sync_mode () if not b . startup (): exit () # failed to start base! # interact with the base here Stretch's mobile base is a differential drive configuration. The left and right wheels are accessible through Base's left_wheel and right_wheel attributes, both of which are instances of the Stepper class. The startup() method is extended from the Device class. Since the mobile base is unconstrained, there is no homing method. We can read the base's current state and send commands using: 10 11 12 13 14 15 16 17 18 19 20 b . pretty_print () # translate forward by 10cm b . translate_by ( 0.1 ) b . push_command () b . left_wheel . wait_until_at_setpoint () # rotate counter-clockwise by 90 degrees b . rotate_by ( 1.57 ) b . push_command () b . left_wheel . wait_until_at_setpoint () The pretty_print() method prints out mobile base state info in a human interpretable format. The translate_by() and rotate_by() methods send relative commands similar to the way move_by() behaves for the single degree of freedom joints. The mobile base also supports velocity control: 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # command the base to translate forward at 5cm / second b . set_translate_velocity ( 0.05 ) b . push_command () import time ; time . sleep ( 1 ) # command the base to rotate counter-clockwise at 0.1rad / second b . set_rotational_velocity ( 0.1 ) b . push_command () time . sleep ( 1 ) # command the base with translational and rotational velocities b . set_velocity ( 0.05 , 0.1 ) b . push_command () time . sleep ( 1 ) # stop base motion b . enable_freewheel_mode () b . push_command () The set_translate_velocity() / set_rotational_velocity() give velocity control over the translational/rotational components of the mobile base independently. The set_velocity() method gives control over both of these components simultaneously. To halt motion, you can command zero velocities or command the base into freewheel mode using enable_freewheel_mode() . The mobile base also supports waypoint trajectory following, but the waypoints are part of the SE2 group (a.k.a. each of the base's desired waypoints is defined as a (x, y) point and a theta orientation): 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # reset odometry calculation b . first_step = True b . pull_status () # queue a trajectory consisting of three waypoints b . trajectory . add ( time = 0 , x = 0.0 , y = 0.0 , theta = 0.0 ) b . trajectory . add ( time = 3 , x = 0.1 , y = 0.0 , theta = 0.0 ) b . trajectory . add ( time = 6 , x = 0.0 , y = 0.0 , theta = 0.0 ) # trigger trajectory execution b . follow_trajectory () import time ; time . sleep ( 6 ) print ( b . status [ 'x' ], b . status [ 'y' ], b . status [ 'theta' ]) # we should expect to see around (0.0, 0.0, 0.0 or 6.28) b . stop () Warning The Base's waypoint trajectory following has no notion of obstacles in the environment. It will blindly follow the commanded waypoints. For obstacle avoidance, perception and a path planner should be employed. Base's attribute trajectory is an instance of the DiffDriveTrajectory class. The call to follow_trajectory() begins hardware tracking of the spline. All of Base's subroutines are documented below. stretch_body.base.Base ( Device ) API to the Stretch RE1 Mobile Base __init__ ( self ) special startup ( self , threaded = True ) Starts machinery required to interface with this device Parameters threaded : bool whether a thread manages hardware polling/pushing in the background Returns bool whether the startup procedure succeeded stop ( self ) Shuts down machinery started in startup() pretty_print ( self ) enable_freewheel_mode ( self ) Force motors into freewheel enable_pos_incr_mode ( self ) Force motors into incremental position mode translate_by ( self , x_m , v_m = None , a_m = None , stiffness = None , contact_thresh_N = None ) Incremental translation of the base x_m: desired motion (m) v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N: force threshold to stop motion (TODO: Not yet implemented) rotate_by ( self , x_r , v_r = None , a_r = None , stiffness = None , contact_thresh_N = None ) Incremental rotation of the base x_r: desired motion (radians) v_r: velocity for trapezoidal motion profile (rad/s) a_r: acceleration for trapezoidal motion profile (rad/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N: force threshold to stop motion (Not yet implemented) set_translate_velocity ( self , v_m , a_m = None ) Command the bases translational velocity. Use care to prevent collisions / avoid runaways v_m: desired velocity (m/s) a_m: acceleration of motion profile (m/s^2) set_rotational_velocity ( self , v_r , a_r = None ) Command the bases rotational velocity. Use care to prevent collisions / avoid runaways v_r: desired rotational velocity (rad/s) a_r: acceleration of motion profile (rad/s^2) set_velocity ( self , v_m , w_r , a = None ) Command the bases translational and rotational velocities simultaneously. Use care to prevent collisions / avoid runaways v_m: desired velocity (m/s) w_r: desired rotational velocity (rad/s) a: acceleration of motion profile (m/s^2 and rad/s^2) follow_trajectory ( self , v_r = None , a_r = None , stiffness = None , contact_thresh_N = None ) Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method. Parameters v_r : float velocity limit for trajectory in motor space in meters per second a_r : float acceleration limit for trajectory in motor space in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N : float force threshold to stop motion (~Newtons) update_trajectory ( self ) Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method. stop_trajectory ( self ) Stop waypoint trajectory immediately and resets hardware step_sentry ( self , robot ) Only allow fast mobile base motion if the lift is low, the arm is retracted, and the wrist is stowed. This is intended to keep the center of mass low for increased stability and avoid catching the arm or tool on something. push_command ( self ) pull_status ( self ) Computes base odometery based on stepper positions / velocities motor_current_to_translation_force ( self , il , ir ) motor_current_to_rotation_torque ( self , il , ir ) translation_force_to_motor_current ( self , f_N ) rotation_torque_to_motor_current ( self , tq_Nm ) translate_to_motor_rad ( self , x_m ) motor_rad_to_translate ( self , x_r ) rotate_to_motor_rad ( self , x_r ) motor_rad_to_rotate ( self , x_r ) translation_to_rotation ( self , x_m ) rotation_to_translation ( self , x_r ) Using the Head class The interface to Stretch's head is the Head class. Stretch's head contains a Intel Realsense D435i depth camera, so the pan/tilt joints in the head allows Stretch to swivel and capture depth imagery of its surrounding. The head is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.head h = stretch_body . head . Head () if not h . startup (): exit () # failed to start head! h . home () # interact with the head here Head is a subclass of DynamixelXChain , which in turn subclasses the Device class. Therefore, some of Head's methods, such as startup() and home() methods are extended from the Device class, while other come from the DynamixelXChain class. Reading the head's current state and sending commands to its revolute joints (head pan and tilt) happens using: 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 starting_position = h . status [ 'head_pan' ][ 'pos' ] # look right by 90 degrees h . move_to ( 'head_pan' , starting_position + 1.57 ) h . get_joint ( 'head_pan' ) . wait_until_at_setpoint () # tilt up by 30 degrees h . move_by ( 'head_tilt' , - 1.57 / 3 ) h . get_joint ( 'head_tilt' ) . wait_until_at_setpoint () # look down towards the wheels h . pose ( 'wheels' ) import time ; time . sleep ( 3 ) # look ahead h . pose ( 'ahead' ) time . sleep ( 3 ) Head's attribute status is a dictionary of dictionaries, where each subdictionary is the status of one of the head's joints. This state information is updated in the background in real time by default (disable by initializing as startup(threading=False) ). Use the pretty_print() method to print out this state info in a human interpretable format. Commanding the head's revolute joints is done through the move_to() and move_by() methods. Notice that unlike the previous joints, no push command call is required here. These joints are Dynamixel servos, which behave differently than the Hello Robot steppers. Their commands are not queued; they're executed as soon as they're received. Head's two joints, the 'head_pan' and 'head_tilt', are instances of the DynamixelHelloXL430 class, and are retreiveable using the get_joint() method. They have the wait_until_at_setpoint() method, which blocks program execution until the joint reaches the commanded goal. The pose() method makes it easy to command the head to common head poses (e.g. looking 'ahead', at the end of arm 'tool', obstacles in front of the 'wheels', or 'up'). The head supports waypoint trajectories as well: 27 28 29 30 31 32 33 34 35 36 37 # queue a trajectory consisting of three waypoints h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 0 , x_r = 0.0 ) h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 3 , x_r =- 1.0 ) h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 6 , x_r = 0.0 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 0 , x_r = 0.1 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 3 , x_r =- 0.9 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 6 , x_r = 0.1 ) # trigger trajectory execution h . follow_trajectory () import time ; time . sleep ( 6 ) The head pan/tilt DynamixelHelloXL430 instances have an attribute trajectory , which is an instance of the RevoluteTrajectory class. The call to follow_trajectory() begins software tracking of the spline. Finally, setting soft motion limits for the head's pan/tilt range happens using: 38 39 40 41 42 43 44 45 46 # clip the head_pan's range h . get_joint ( 'head_pan' ) . set_soft_motion_limit_min ( - 1.0 ) h . get_joint ( 'head_pan' ) . set_soft_motion_limit_max ( 1.0 ) # clip the head_tilt's range h . get_joint ( 'head_tilt' ) . set_soft_motion_limit_min ( - 1.0 ) h . get_joint ( 'head_tilt' ) . set_soft_motion_limit_max ( 0.1 ) h . stop () The set_soft_motion_limit_min/max() methods perform clipping of the joint's range at the software level (cannot persist across reboots). All of Head's subroutines are documented below. stretch_body.head.Head ( DynamixelXChain ) API to the Stretch RE1 Head __init__ ( self ) special startup ( self , threaded = True ) Starts machinery required to interface with this device Parameters threaded : bool whether a thread manages hardware polling/pushing in the background Returns bool whether the startup procedure succeeded get_joint ( self , joint_name ) Retrieves joint by name. Parameters joint_name : str valid joints defined in joints Returns DynamixelHelloXL430 or None Motor object on valid joint name, else None move_to ( self , joint , x_r , v_r = None , a_r = None ) joint: Name of the joint to move ('head_pan' or 'head_tilt') x_r: commanded absolute position (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2) move_by ( self , joint , x_r , v_r = None , a_r = None ) joint: Name of the joint to move ('head_pan' or 'head_tilt') x_r: commanded incremental motion (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2) home ( self ) pose ( self , p , v_r = [ None , None ], a_r = [ None , None ]) p: Dictionary key to named pose (eg 'ahead') v_r: list, velocities for trapezoidal motion profile (rad/s). a_r: list, accelerations for trapezoidal motion profile (rad/s^2) Using the EndOfArm class The interface to Stretch's end of arm is the EndOfArm class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.end_of_arm e = stretch_body . end_of_arm . EndOfArm () if not e . startup ( threaded = True ): exit () # failed to start end of arm! # interact with the end of arm here e . stop () EndOfArm's subroutines are documented below. stretch_body.end_of_arm.EndOfArm ( DynamixelXChain ) The EndOfArm class allows for an extensible serial chain of Dynamixel X series devices It allows the specific type of device to be declared at runtime via the Yaml parameters In this way, a user can add their own custom Dynamixel based tools to the robot end-of-arm by simply deriving it from DynamixelHelloXL430 and declaring the class name / Python module name in the User YAML file __init__ ( self , name = 'end_of_arm' ) special startup ( self , threaded = True ) Starts machinery required to interface with this device Parameters threaded : bool whether a thread manages hardware polling/pushing in the background Returns bool whether the startup procedure succeeded get_joint ( self , joint_name ) Retrieves joint by name. Parameters joint_name : str valid joints defined as defined in params['devices'] Returns DynamixelHelloXL430 or None Motor object on valid joint name, else None move_to ( self , joint , x_r , v_r = None , a_r = None ) joint: name of joint (string) x_r: commanded absolute position (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2) move_by ( self , joint , x_r , v_r = None , a_r = None ) joint: name of joint (string) x_r: commanded incremental motion (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2) pose ( self , joint , p , v_r = None , a_r = None ) joint: name of joint (string) p: named pose of joint v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2) stow ( self ) home ( self , joint = None ) Home to hardstops is_tool_present ( self , class_name ) Return true if the given tool type is present (eg. StretchGripper) Allows for conditional logic when switching end-of-arm tools Using the Wacc class The interface to Stretch's wrist board is the Wacc (wrist + accelerometer) class. This board provides an Arduino and accelerometer sensor that is accessible from the Wacc class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.wacc w = stretch_body . wacc . Wacc () if not w . startup ( threaded = True ): exit () # failed to start wacc! # interact with the wacc here w . stop () Wacc's subroutines are documented below. stretch_body.wacc.Wacc ( WaccBase ) API to the Stretch RE1 Power and IMU board (Pimu) __init__ ( self ) special startup ( self , threaded = False ) First determine which protocol version the uC firmware is running. Based on that version, replaces PimuBase class inheritance with a inheritance to a child class of PimuBase that supports that protocol Using the Pimu class The interface to Stretch's power board is the Pimu (power + IMU) class. This board provides an 9 DOF IMUthat is accessible from the Pimu class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.pimu p = stretch_body . pimu . Pimu () if not p . startup ( threaded = True ): exit () # failed to start pimu! # interact with the pimu here p . stop () Pimu's subroutines are documented below. stretch_body.pimu.Pimu ( PimuBase ) API to the Stretch RE1 Power and IMU board (Pimu) __init__ ( self , event_reset = False ) special startup ( self , threaded = False ) First determine which protocol version the uC firmware is running. Based on that version, replaces PimuBase class inheritance with a inheritance to a child class of PimuBase that supports that protocol All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"API"},{"location":"stretch-body/stretch_body_api/#stretch-body-api-reference","text":"Stretch Body is the Python interface to working with the Stretch RE1. This page serves as a reference of the interfaces defined in the stretch_body library. See the Stretch Body Guide for a tutorial to working with this library.","title":"Stretch Body API Reference"},{"location":"stretch-body/stretch_body_api/#the-robot-class","text":"","title":"The Robot Class"},{"location":"stretch-body/stretch_body_api/#using-the-robot-class","text":"The most common interface to Stretch is the Robot class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 11 import stretch_body.robot r = stretch_body . robot . Robot () if not r . startup (): exit () # failed to start robot! # home the joints to find zero, if necessary if not r . is_calibrated (): r . home () # interact with the robot here The startup() and home() methods starts communication with and homes each of the robot's devices, respectively. Through the Robot class, users can interact with all other devices on the robot. For example, continuing the example above: 12 13 14 15 16 17 18 19 20 21 22 23 # moving joints on the robot r . arm . pretty_print () r . lift . pretty_print () r . base . pretty_print () r . head . pretty_print () r . end_of_arm . pretty_print () # other devices on the robot r . wacc . pretty_print () r . pimu . pretty_print () r . stop () Each of these devices are defined in other modules within stretch_body . In the following section , we'll look at the API of these classes. The stop() method shuts down communication with the robot's devices. All of Robot's subroutines are documented below.","title":"Using the Robot class"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot","text":"API to the Stretch RE1 Robot","title":"Robot"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.__init__","text":"","title":"__init__()"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.startup","text":"To be called once after class instantiation. Prepares devices for communications and motion","title":"startup()"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.startup--returns","text":"bool true if startup of robot succeeded","title":"Returns"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.stop","text":"To be called once before exiting a program Cleanly stops down motion and communication","title":"stop()"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.get_status","text":"Thread safe and atomic read of current Robot status data Returns as a dict.","title":"get_status()"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.pretty_print","text":"","title":"pretty_print()"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.push_command","text":"Cause all queued up RPC commands to be sent down to Devices","title":"push_command()"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.follow_trajectory","text":"","title":"follow_trajectory()"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.stop_trajectory","text":"","title":"stop_trajectory()"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.is_calibrated","text":"Returns true if homing-calibration has been run all joints that require it","title":"is_calibrated()"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.stow","text":"Cause the robot to move to its stow position Blocking.","title":"stow()"},{"location":"stretch-body/stretch_body_api/#stretch_body.robot.Robot.home","text":"Cause the robot to home its joints by moving to hardstops Blocking.","title":"home()"},{"location":"stretch-body/stretch_body_api/#the-device-classes","text":"The stretch_body library is modular in design. Each subcomponent of Stretch is defined in its own class and the Robot class provides an interface that ties all of these classes together. This modularity allows users to plug in new/modified subcomponents into the Robot interface by extending a device class. It is possible to interface with a single subcomponent of Stretch by initializing its device class directly. In this section, we'll look at the API of seven device classes: the arm , lift , base , head , end of arm , wacc , and pimu subcomponents of Stretch.","title":"The Device Classes"},{"location":"stretch-body/stretch_body_api/#using-the-arm-class","text":"The interface to Stretch's telescoping arm is the Arm class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 import stretch_body.arm a = stretch_body . arm . Arm () a . motor . disable_sync_mode () if not a . startup (): exit () # failed to start arm! a . home () # interact with the arm here Since both Arm and Robot subclass Device , the same startup() and stop() methods are available here, as well as other Device methods such as home() . Using the Arm class, we can read the arm's current state and send commands to the joint. For example, continuing the example above: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 starting_position = a . status [ 'pos' ] # move out by 10cm a . move_to ( starting_position + 0.1 ) a . push_command () a . motor . wait_until_at_setpoint () # move back to starting position quickly a . move_to ( starting_position , v_m = 0.2 , a_m = 0.25 ) a . push_command () a . motor . wait_until_at_setpoint () a . move_by ( 0.1 ) # move out by 10cm a . push_command () a . motor . wait_until_at_setpoint () The move_to() and move_by() methods queue absolute and relative commands to the arm respectively, while the nonblocking push_command() method pushes the queued command to the hardware for execution. Arm's attribute motor , an instance of the Stepper class, has wait_until_at_setpoint() which blocks program execution until the joint reaches the commanded goal. With P1 or greater firmware installed, it is also possible to queue a waypoint trajectory for the arm to follow: 26 27 28 29 30 31 32 33 34 35 36 starting_position = a . status [ 'pos' ] # queue a trajectory consisting of four waypoints a . trajectory . add ( t_s = 0 , x_m = starting_position ) a . trajectory . add ( t_s = 3 , x_m = 0.15 ) a . trajectory . add ( t_s = 6 , x_m = 0.1 ) a . trajectory . add ( t_s = 9 , x_m = 0.2 ) # trigger trajectory execution a . follow_trajectory () import time ; time . sleep ( 9 ) Arm's attribute trajectory , an instance of the PrismaticTrajectory class, has add() which adds a single waypoint in a linear sliding trajectory. For a well formed trajectory (see is_valid() ), the follow_trajectory() method kicks off trajectory following for the telescoping arm. It is also possible to dynamically restrict the arm joint's range: 37 38 39 40 41 42 43 44 45 46 47 48 49 50 range_upper_limit = 0.3 # meters # set soft limits on arm's range a . set_soft_motion_limit_min ( 0 ) a . set_soft_motion_limit_max ( range_upper_limit ) a . push_command () # command the arm outside the valid range a . move_to ( 0.4 ) a . push_command () a . motor . wait_until_at_setpoint () print ( a . status [ 'pos' ]) # we should expect to see ~0.3 a . stop () The set_soft_motion_limit_min/max() methods form the basis of an experimental self-collision avoidance system built into Stretch Body. All of Arm's subroutines are documented below.","title":"Using the Arm class"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm","text":"API to the Stretch RE1 Arm","title":"Arm"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.__init__","text":"","title":"__init__()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.startup","text":"Starts machinery required to interface with this device","title":"startup()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.startup--parameters","text":"threaded : bool whether a thread manages hardware polling/pushing in the background","title":"Parameters"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.startup--returns","text":"bool whether the startup procedure succeeded","title":"Returns"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.stop","text":"Shuts down machinery started in startup()","title":"stop()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.pull_status","text":"","title":"pull_status()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.push_command","text":"","title":"push_command()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.pretty_print","text":"","title":"pretty_print()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.get_soft_motion_limits","text":"Return the currently applied soft motion limits: [min, max] The soft motion limit restricts joint motion to be <= its physical limits. There are three types of limits: Hard: The physical limits Collision: Limits set by RobotCollision to avoid collisions User: Limits set by the user software The joint is limited to the most restrictive range of the Hard / Collision/ User values. Specifying a value of None for a limit indicates that no constraint exists for that limit type. This allows a User limits and Collision limits to coexist. For example, a user can temporarily restrict the range of motion beyond the current collision limits. Then, by commanding User limits of None, the joint limits will revert back to the collision settings.","title":"get_soft_motion_limits()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.set_soft_motion_limit_min","text":"x: value to set a joints limit to limit_type: 'user' or 'collision'","title":"set_soft_motion_limit_min()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.set_soft_motion_limit_max","text":"x: value to set a joints limit to limit_type: 'user' or 'collision'","title":"set_soft_motion_limit_max()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.set_velocity","text":"","title":"set_velocity()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.move_to","text":"x_m: commanded absolute position (meters). x_m=0 is retracted. x_m=~0.5 is extended v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, retraction direction) req_calibration: Disallow motion prior to homing","title":"move_to()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.move_by","text":"x_m: commanded incremental motion (meters). v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, retraction direction) req_calibration: Disallow motion prior to homing","title":"move_by()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.follow_trajectory","text":"Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method.","title":"follow_trajectory()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.follow_trajectory--parameters","text":"v_m : float velocity limit for trajectory in meters per second a_m : float acceleration limit for trajectory in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N : float force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N : float force threshold to stop motion (~Newtons, retraction direction) req_calibration : bool whether to allow motion prior to homing move_to_start_point : bool whether to move to the trajectory's start to avoid a jump, this time to move doesn't count against the trajectory's timeline","title":"Parameters"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.update_trajectory","text":"Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method.","title":"update_trajectory()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.stop_trajectory","text":"Stop waypoint trajectory immediately and resets hardware","title":"stop_trajectory()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.motor_current_to_translate_force","text":"","title":"motor_current_to_translate_force()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.translate_force_to_motor_current","text":"","title":"translate_force_to_motor_current()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.motor_rad_to_translate","text":"","title":"motor_rad_to_translate()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.translate_to_motor_rad","text":"","title":"translate_to_motor_rad()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.home","text":"Home to hardstops","title":"home()"},{"location":"stretch-body/stretch_body_api/#stretch_body.arm.Arm.step_sentry","text":"","title":"step_sentry()"},{"location":"stretch-body/stretch_body_api/#using-the-lift-class","text":"The interface to Stretch's lift is the Lift class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 import stretch_body.lift l = stretch_body . lift . Lift () l . motor . disable_sync_mode () if not l . startup (): exit () # failed to start lift! l . home () # interact with the lift here The startup() and home() methods are extended from the Device class. Reading the lift's current state and sending commands to the joint occurs similarly to the Arm : 11 12 13 14 15 16 starting_position = l . status [ 'pos' ] # move up by 10cm l . move_to ( starting_position + 0.1 ) l . push_command () l . motor . wait_until_at_setpoint () Lift's attribute status is a dictionary of the joint's current status. This state information is updated in the background in real time by default (disable by initializing as startup(threading=False) ). Use the pretty_print() method to print out this state info in a human interpretable format. Setting up waypoint trajectories for the lift is also similar to the Arm : 17 18 19 20 21 22 23 24 25 26 starting_position = l . status [ 'pos' ] # queue a trajectory consisting of three waypoints l . trajectory . add ( t_s = 0 , x_m = starting_position , v_m = 0.0 ) l . trajectory . add ( t_s = 3 , x_m = 0.5 , v_m = 0.0 ) l . trajectory . add ( t_s = 6 , x_m = 0.6 , v_m = 0.0 ) # trigger trajectory execution l . follow_trajectory () import time ; time . sleep ( 6 ) Lift's attribute trajectory is also an instance of the PrismaticTrajectory class, and by providing the instantaneous velocity argument v_m to the add() method, a cubic spline has been loaded into the joint's trajectory . The call to follow_trajectory() begins hardware tracking of the spline. Finally, setting soft motion limits for the lift's range happens using: 27 28 29 30 31 32 # cut out 0.2m from the top and bottom of the lift's range l . set_soft_motion_limit_min ( 0.2 ) l . set_soft_motion_limit_max ( 0.8 ) l . push_command () l . stop () The set_soft_motion_limit_min/max() methods perform clipping of the joint's range at the firmware level (can persist across reboots). All of Lift's subroutines are documented below.","title":"Using the Lift class"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift","text":"API to the Stretch RE1 Lift","title":"Lift"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.__init__","text":"","title":"__init__()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.startup","text":"Starts machinery required to interface with this device","title":"startup()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.startup--parameters","text":"threaded : bool whether a thread manages hardware polling/pushing in the background","title":"Parameters"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.startup--returns","text":"bool whether the startup procedure succeeded","title":"Returns"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.stop","text":"Shuts down machinery started in startup()","title":"stop()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.pull_status","text":"","title":"pull_status()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.push_command","text":"","title":"push_command()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.pretty_print","text":"","title":"pretty_print()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.get_soft_motion_limits","text":"Return the currently applied soft motion limits: [min, max] The soft motion limit restricts joint motion to be <= its physical limits. There are three types of limits: Hard: The physical limits Collision: Limits set by RobotCollision to avoid collisions User: Limits set by the user software The joint is limited to the most restrictive range of the Hard / Collision/ User values. Specifying a value of None for a limit indicates that no constraint exists for that limit type. This allows a User limits and Collision limits to coexist. For example, a user can temporarily restrict the range of motion beyond the current collision limits. Then, by commanding User limits of None, the joint limits will revert back to the collision settings.","title":"get_soft_motion_limits()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.set_soft_motion_limit_min","text":"x: value to set a joints limit to limit_type: 'user' or 'collision'","title":"set_soft_motion_limit_min()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.set_soft_motion_limit_max","text":"x: value to set a joints limit to limit_type: 'user' or 'collision'","title":"set_soft_motion_limit_max()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.set_velocity","text":"","title":"set_velocity()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.move_to","text":"x_m: commanded absolute position (meters). x_m=0 is down. x_m=~1.1 is up v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, down direction) req_calibration: Disallow motion prior to homing","title":"move_to()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.move_by","text":"x_m: commanded incremental motion (meters). v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, down direction) req_calibration: Disallow motion prior to homing","title":"move_by()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.follow_trajectory","text":"Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method.","title":"follow_trajectory()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.follow_trajectory--parameters","text":"v_m : float velocity limit for trajectory in meters per second a_m : float acceleration limit for trajectory in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N : float force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N : float force threshold to stop motion (~Newtons, down direction) req_calibration : bool whether to allow motion prior to homing move_to_start_point : bool whether to move to the trajectory's start to avoid a jump, this time to move doesn't count against the trajectory's timeline","title":"Parameters"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.update_trajectory","text":"Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method.","title":"update_trajectory()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.stop_trajectory","text":"Stop waypoint trajectory immediately and resets hardware","title":"stop_trajectory()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.motor_current_to_translate_force","text":"","title":"motor_current_to_translate_force()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.translate_force_to_motor_current","text":"","title":"translate_force_to_motor_current()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.motor_rad_to_translate_m","text":"","title":"motor_rad_to_translate_m()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.translate_to_motor_rad","text":"","title":"translate_to_motor_rad()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.home","text":"","title":"home()"},{"location":"stretch-body/stretch_body_api/#stretch_body.lift.Lift.step_sentry","text":"","title":"step_sentry()"},{"location":"stretch-body/stretch_body_api/#using-the-base-class","text":"Item Notes A Drive wheels 4 inch diameter, urethane rubber shore 60A B Cliff sensors Sharp GP2Y0A51SK0F, Analog, range 2-15 cm C Mecanum wheel Diameter 50mm The interface to Stretch's mobile base is the Base class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.base b = stretch_body . base . Base () b . left_wheel . disable_sync_mode () b . right_wheel . disable_sync_mode () if not b . startup (): exit () # failed to start base! # interact with the base here Stretch's mobile base is a differential drive configuration. The left and right wheels are accessible through Base's left_wheel and right_wheel attributes, both of which are instances of the Stepper class. The startup() method is extended from the Device class. Since the mobile base is unconstrained, there is no homing method. We can read the base's current state and send commands using: 10 11 12 13 14 15 16 17 18 19 20 b . pretty_print () # translate forward by 10cm b . translate_by ( 0.1 ) b . push_command () b . left_wheel . wait_until_at_setpoint () # rotate counter-clockwise by 90 degrees b . rotate_by ( 1.57 ) b . push_command () b . left_wheel . wait_until_at_setpoint () The pretty_print() method prints out mobile base state info in a human interpretable format. The translate_by() and rotate_by() methods send relative commands similar to the way move_by() behaves for the single degree of freedom joints. The mobile base also supports velocity control: 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # command the base to translate forward at 5cm / second b . set_translate_velocity ( 0.05 ) b . push_command () import time ; time . sleep ( 1 ) # command the base to rotate counter-clockwise at 0.1rad / second b . set_rotational_velocity ( 0.1 ) b . push_command () time . sleep ( 1 ) # command the base with translational and rotational velocities b . set_velocity ( 0.05 , 0.1 ) b . push_command () time . sleep ( 1 ) # stop base motion b . enable_freewheel_mode () b . push_command () The set_translate_velocity() / set_rotational_velocity() give velocity control over the translational/rotational components of the mobile base independently. The set_velocity() method gives control over both of these components simultaneously. To halt motion, you can command zero velocities or command the base into freewheel mode using enable_freewheel_mode() . The mobile base also supports waypoint trajectory following, but the waypoints are part of the SE2 group (a.k.a. each of the base's desired waypoints is defined as a (x, y) point and a theta orientation): 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # reset odometry calculation b . first_step = True b . pull_status () # queue a trajectory consisting of three waypoints b . trajectory . add ( time = 0 , x = 0.0 , y = 0.0 , theta = 0.0 ) b . trajectory . add ( time = 3 , x = 0.1 , y = 0.0 , theta = 0.0 ) b . trajectory . add ( time = 6 , x = 0.0 , y = 0.0 , theta = 0.0 ) # trigger trajectory execution b . follow_trajectory () import time ; time . sleep ( 6 ) print ( b . status [ 'x' ], b . status [ 'y' ], b . status [ 'theta' ]) # we should expect to see around (0.0, 0.0, 0.0 or 6.28) b . stop () Warning The Base's waypoint trajectory following has no notion of obstacles in the environment. It will blindly follow the commanded waypoints. For obstacle avoidance, perception and a path planner should be employed. Base's attribute trajectory is an instance of the DiffDriveTrajectory class. The call to follow_trajectory() begins hardware tracking of the spline. All of Base's subroutines are documented below.","title":"Using the Base class"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base","text":"API to the Stretch RE1 Mobile Base","title":"Base"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.__init__","text":"","title":"__init__()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.startup","text":"Starts machinery required to interface with this device","title":"startup()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.startup--parameters","text":"threaded : bool whether a thread manages hardware polling/pushing in the background","title":"Parameters"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.startup--returns","text":"bool whether the startup procedure succeeded","title":"Returns"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.stop","text":"Shuts down machinery started in startup()","title":"stop()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.pretty_print","text":"","title":"pretty_print()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.enable_freewheel_mode","text":"Force motors into freewheel","title":"enable_freewheel_mode()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.enable_pos_incr_mode","text":"Force motors into incremental position mode","title":"enable_pos_incr_mode()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.translate_by","text":"Incremental translation of the base x_m: desired motion (m) v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N: force threshold to stop motion (TODO: Not yet implemented)","title":"translate_by()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.rotate_by","text":"Incremental rotation of the base x_r: desired motion (radians) v_r: velocity for trapezoidal motion profile (rad/s) a_r: acceleration for trapezoidal motion profile (rad/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N: force threshold to stop motion (Not yet implemented)","title":"rotate_by()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.set_translate_velocity","text":"Command the bases translational velocity. Use care to prevent collisions / avoid runaways v_m: desired velocity (m/s) a_m: acceleration of motion profile (m/s^2)","title":"set_translate_velocity()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.set_rotational_velocity","text":"Command the bases rotational velocity. Use care to prevent collisions / avoid runaways v_r: desired rotational velocity (rad/s) a_r: acceleration of motion profile (rad/s^2)","title":"set_rotational_velocity()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.set_velocity","text":"Command the bases translational and rotational velocities simultaneously. Use care to prevent collisions / avoid runaways v_m: desired velocity (m/s) w_r: desired rotational velocity (rad/s) a: acceleration of motion profile (m/s^2 and rad/s^2)","title":"set_velocity()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.follow_trajectory","text":"Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method.","title":"follow_trajectory()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.follow_trajectory--parameters","text":"v_r : float velocity limit for trajectory in motor space in meters per second a_r : float acceleration limit for trajectory in motor space in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N : float force threshold to stop motion (~Newtons)","title":"Parameters"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.update_trajectory","text":"Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method.","title":"update_trajectory()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.stop_trajectory","text":"Stop waypoint trajectory immediately and resets hardware","title":"stop_trajectory()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.step_sentry","text":"Only allow fast mobile base motion if the lift is low, the arm is retracted, and the wrist is stowed. This is intended to keep the center of mass low for increased stability and avoid catching the arm or tool on something.","title":"step_sentry()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.push_command","text":"","title":"push_command()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.pull_status","text":"Computes base odometery based on stepper positions / velocities","title":"pull_status()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.motor_current_to_translation_force","text":"","title":"motor_current_to_translation_force()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.motor_current_to_rotation_torque","text":"","title":"motor_current_to_rotation_torque()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.translation_force_to_motor_current","text":"","title":"translation_force_to_motor_current()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.rotation_torque_to_motor_current","text":"","title":"rotation_torque_to_motor_current()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.translate_to_motor_rad","text":"","title":"translate_to_motor_rad()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.motor_rad_to_translate","text":"","title":"motor_rad_to_translate()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.rotate_to_motor_rad","text":"","title":"rotate_to_motor_rad()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.motor_rad_to_rotate","text":"","title":"motor_rad_to_rotate()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.translation_to_rotation","text":"","title":"translation_to_rotation()"},{"location":"stretch-body/stretch_body_api/#stretch_body.base.Base.rotation_to_translation","text":"","title":"rotation_to_translation()"},{"location":"stretch-body/stretch_body_api/#using-the-head-class","text":"The interface to Stretch's head is the Head class. Stretch's head contains a Intel Realsense D435i depth camera, so the pan/tilt joints in the head allows Stretch to swivel and capture depth imagery of its surrounding. The head is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.head h = stretch_body . head . Head () if not h . startup (): exit () # failed to start head! h . home () # interact with the head here Head is a subclass of DynamixelXChain , which in turn subclasses the Device class. Therefore, some of Head's methods, such as startup() and home() methods are extended from the Device class, while other come from the DynamixelXChain class. Reading the head's current state and sending commands to its revolute joints (head pan and tilt) happens using: 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 starting_position = h . status [ 'head_pan' ][ 'pos' ] # look right by 90 degrees h . move_to ( 'head_pan' , starting_position + 1.57 ) h . get_joint ( 'head_pan' ) . wait_until_at_setpoint () # tilt up by 30 degrees h . move_by ( 'head_tilt' , - 1.57 / 3 ) h . get_joint ( 'head_tilt' ) . wait_until_at_setpoint () # look down towards the wheels h . pose ( 'wheels' ) import time ; time . sleep ( 3 ) # look ahead h . pose ( 'ahead' ) time . sleep ( 3 ) Head's attribute status is a dictionary of dictionaries, where each subdictionary is the status of one of the head's joints. This state information is updated in the background in real time by default (disable by initializing as startup(threading=False) ). Use the pretty_print() method to print out this state info in a human interpretable format. Commanding the head's revolute joints is done through the move_to() and move_by() methods. Notice that unlike the previous joints, no push command call is required here. These joints are Dynamixel servos, which behave differently than the Hello Robot steppers. Their commands are not queued; they're executed as soon as they're received. Head's two joints, the 'head_pan' and 'head_tilt', are instances of the DynamixelHelloXL430 class, and are retreiveable using the get_joint() method. They have the wait_until_at_setpoint() method, which blocks program execution until the joint reaches the commanded goal. The pose() method makes it easy to command the head to common head poses (e.g. looking 'ahead', at the end of arm 'tool', obstacles in front of the 'wheels', or 'up'). The head supports waypoint trajectories as well: 27 28 29 30 31 32 33 34 35 36 37 # queue a trajectory consisting of three waypoints h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 0 , x_r = 0.0 ) h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 3 , x_r =- 1.0 ) h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 6 , x_r = 0.0 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 0 , x_r = 0.1 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 3 , x_r =- 0.9 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 6 , x_r = 0.1 ) # trigger trajectory execution h . follow_trajectory () import time ; time . sleep ( 6 ) The head pan/tilt DynamixelHelloXL430 instances have an attribute trajectory , which is an instance of the RevoluteTrajectory class. The call to follow_trajectory() begins software tracking of the spline. Finally, setting soft motion limits for the head's pan/tilt range happens using: 38 39 40 41 42 43 44 45 46 # clip the head_pan's range h . get_joint ( 'head_pan' ) . set_soft_motion_limit_min ( - 1.0 ) h . get_joint ( 'head_pan' ) . set_soft_motion_limit_max ( 1.0 ) # clip the head_tilt's range h . get_joint ( 'head_tilt' ) . set_soft_motion_limit_min ( - 1.0 ) h . get_joint ( 'head_tilt' ) . set_soft_motion_limit_max ( 0.1 ) h . stop () The set_soft_motion_limit_min/max() methods perform clipping of the joint's range at the software level (cannot persist across reboots). All of Head's subroutines are documented below.","title":"Using the Head class"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head","text":"API to the Stretch RE1 Head","title":"Head"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head.__init__","text":"","title":"__init__()"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head.startup","text":"Starts machinery required to interface with this device","title":"startup()"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head.startup--parameters","text":"threaded : bool whether a thread manages hardware polling/pushing in the background","title":"Parameters"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head.startup--returns","text":"bool whether the startup procedure succeeded","title":"Returns"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head.get_joint","text":"Retrieves joint by name.","title":"get_joint()"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head.get_joint--parameters","text":"joint_name : str valid joints defined in joints","title":"Parameters"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head.get_joint--returns","text":"DynamixelHelloXL430 or None Motor object on valid joint name, else None","title":"Returns"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head.move_to","text":"joint: Name of the joint to move ('head_pan' or 'head_tilt') x_r: commanded absolute position (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2)","title":"move_to()"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head.move_by","text":"joint: Name of the joint to move ('head_pan' or 'head_tilt') x_r: commanded incremental motion (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2)","title":"move_by()"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head.home","text":"","title":"home()"},{"location":"stretch-body/stretch_body_api/#stretch_body.head.Head.pose","text":"p: Dictionary key to named pose (eg 'ahead') v_r: list, velocities for trapezoidal motion profile (rad/s). a_r: list, accelerations for trapezoidal motion profile (rad/s^2)","title":"pose()"},{"location":"stretch-body/stretch_body_api/#using-the-endofarm-class","text":"The interface to Stretch's end of arm is the EndOfArm class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.end_of_arm e = stretch_body . end_of_arm . EndOfArm () if not e . startup ( threaded = True ): exit () # failed to start end of arm! # interact with the end of arm here e . stop () EndOfArm's subroutines are documented below.","title":"Using the EndOfArm class"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm","text":"The EndOfArm class allows for an extensible serial chain of Dynamixel X series devices It allows the specific type of device to be declared at runtime via the Yaml parameters In this way, a user can add their own custom Dynamixel based tools to the robot end-of-arm by simply deriving it from DynamixelHelloXL430 and declaring the class name / Python module name in the User YAML file","title":"EndOfArm"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.__init__","text":"","title":"__init__()"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.startup","text":"Starts machinery required to interface with this device","title":"startup()"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.startup--parameters","text":"threaded : bool whether a thread manages hardware polling/pushing in the background","title":"Parameters"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.startup--returns","text":"bool whether the startup procedure succeeded","title":"Returns"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.get_joint","text":"Retrieves joint by name.","title":"get_joint()"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.get_joint--parameters","text":"joint_name : str valid joints defined as defined in params['devices']","title":"Parameters"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.get_joint--returns","text":"DynamixelHelloXL430 or None Motor object on valid joint name, else None","title":"Returns"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.move_to","text":"joint: name of joint (string) x_r: commanded absolute position (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2)","title":"move_to()"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.move_by","text":"joint: name of joint (string) x_r: commanded incremental motion (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2)","title":"move_by()"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.pose","text":"joint: name of joint (string) p: named pose of joint v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2)","title":"pose()"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.stow","text":"","title":"stow()"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.home","text":"Home to hardstops","title":"home()"},{"location":"stretch-body/stretch_body_api/#stretch_body.end_of_arm.EndOfArm.is_tool_present","text":"Return true if the given tool type is present (eg. StretchGripper) Allows for conditional logic when switching end-of-arm tools","title":"is_tool_present()"},{"location":"stretch-body/stretch_body_api/#using-the-wacc-class","text":"The interface to Stretch's wrist board is the Wacc (wrist + accelerometer) class. This board provides an Arduino and accelerometer sensor that is accessible from the Wacc class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.wacc w = stretch_body . wacc . Wacc () if not w . startup ( threaded = True ): exit () # failed to start wacc! # interact with the wacc here w . stop () Wacc's subroutines are documented below.","title":"Using the Wacc class"},{"location":"stretch-body/stretch_body_api/#stretch_body.wacc.Wacc","text":"API to the Stretch RE1 Power and IMU board (Pimu)","title":"Wacc"},{"location":"stretch-body/stretch_body_api/#stretch_body.wacc.Wacc.__init__","text":"","title":"__init__()"},{"location":"stretch-body/stretch_body_api/#stretch_body.wacc.Wacc.startup","text":"First determine which protocol version the uC firmware is running. Based on that version, replaces PimuBase class inheritance with a inheritance to a child class of PimuBase that supports that protocol","title":"startup()"},{"location":"stretch-body/stretch_body_api/#using-the-pimu-class","text":"The interface to Stretch's power board is the Pimu (power + IMU) class. This board provides an 9 DOF IMUthat is accessible from the Pimu class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.pimu p = stretch_body . pimu . Pimu () if not p . startup ( threaded = True ): exit () # failed to start pimu! # interact with the pimu here p . stop () Pimu's subroutines are documented below.","title":"Using the Pimu class"},{"location":"stretch-body/stretch_body_api/#stretch_body.pimu.Pimu","text":"API to the Stretch RE1 Power and IMU board (Pimu)","title":"Pimu"},{"location":"stretch-body/stretch_body_api/#stretch_body.pimu.Pimu.__init__","text":"","title":"__init__()"},{"location":"stretch-body/stretch_body_api/#stretch_body.pimu.Pimu.startup","text":"First determine which protocol version the uC firmware is running. Based on that version, replaces PimuBase class inheritance with a inheritance to a child class of PimuBase that supports that protocol All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"startup()"},{"location":"stretch-body/stretch_body_guide/","text":"Working with Stretch Body The Stretch_Body package provides a low level Python API to the Stretch RE1 hardware. The package is available on Git and installable via Pip . It encapsulates Mobile base Arm Lift Head actuators Wrist and tool actuators Wrist accelerometer and Arduino Base power and IMU board The robot's 3rd party hardware devices are intended to be accessed through ROS and not Stretch_Body. However, it is possible to directly access this hardware through open-source Python packages: Laser range finder: rplidar Respeaker: respeaker_python_library D435i: pyrealsense2 The Stretch_Body package is intended for advanced users who prefer to not use ROS to control the robot. It assumes a moderate level of experience programming robot sensors and actuators. Robot Interface The primary developer interface to Stretch_Body is the Robot class . As an example, the Python script below prints all Robot sensor and state data to the console every 250ms. 1 2 3 4 5 6 7 8 9 10 11 import time import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () for i in range ( 10 ): robot . pretty_print () time . sleep ( 0.25 ) robot . stop () Looking at this in detail: 2 import stretch_body.robot The package stretch_body includes the Python module for Robot as well as other Devices such as Lift and Arm. 4 5 robot = stretch_body . robot . Robot () robot . startup () Here we instantiate an instance of our Robot. The call to startup() opens the serial ports to the various devices, loads the Robot YAML parameters, and launches a few helper threads. 7 8 9 for i in range ( 10 ): robot . pretty_print () time . sleep ( 0.25 ) The call to pretty_print() prints to console all of the robot's sensor and state data. 11 robot . stop () Finally, the stop() method shuts down the Robot threads and cleanly closes the open serial ports. Units The Robot API uses SI units of: meters radians seconds Newtons Amps Volts Parameters may be named with a suffix to help describe the unit type. For example: pos_m : meters pos_r: radians The Robot Status The Robot derives from the Device class . It also encapsulates a number of other Devices: robot.head robot.arm robot.lift robot.base robot.wacc robot.pimu robot.end_of_arm All devices contain a Status dictionary. The Status contains the most recent sensor and state data of that device. For example, looking at the Arm class we see: class Arm ( Device ): def __init__ ( self ): ... self . status = { 'pos' : 0.0 , 'vel' : 0.0 , 'force' : 0.0 , \\ 'motor' : self . motor . status , 'timestamp_pc' : 0 } The Status dictionaries are automatically updated by a background thread of the Robot at 25Hz. The Status data can be accessed via the Robot. For example: if robot . arm . status [ 'pos' ] > 0.25 : print ( 'Arm extension greater than 0.25m' ) If an instantaneous snapshot of the entire Robot Status is needed, the get_status() method can be used instead: status = robot . get_status () if status [ 'arm' ][ 'pos' ] > 0.25 : print ( 'Arm extension greater than 0.25m' ) The Robot Command In contrast to the Robot Status which pulls data from the Devices, the Robot Command pushes data to the Devices. Consider the following example which extends and then retracts the arm by 0.1 meters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import time import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . arm . move_by ( 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . arm . move_by ( - 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . stop () A few important things are going on: 7 robot . arm . move_by ( 0.1 ) The move_by() method queues up an RPC command to the stepper motor controller. However, the command does not yet execute. 8 robot . push_command () The push_command() causes all queued up RPC commands to be executed at once. In this example we call sleep() to allow time for the motion to complete before initiating a new motion. NOTE : The Dynamixel servos do not use the Hello Robot RPC protocol. As such, the head, wrist, and gripper will move immediately upon issuing a motion command. The stepper actuators support a synchronous mode, allowing the base, arm, and lift to synchronously track trajectories. Thus, the following code will cause the base, arm, and lift to initiate motion simultaneously: robot . arm . move_by ( 0.1 ) robot . lift . move_by ( 0.1 ) robot . base . translate_by ( 0.1 ) robot . push_command () Commanding robot motion through the Stretch_Body interface is covered in more detail in the Robot Motion section. Stowing and Homing After power up the robot requires homing in order for its joint encoders to find their zero position. The homing procedure will run the robot through a series of moves to find these zeros. It can be done programatically: if not robot . is_calibrated (): robot . home () #blocking Or it can be done manually after boot using the command line tool: $ stretch_robot_home.py Likewise, stowing is a robot procedure that will cause it to move its arm and tool safely within the footprint of the base. robot . stow () #blocking Or it can be done manually from the command line when needed: $ stretch_robot_stow.py Scripting the Robot A simplified design pattern to script the Robot is as follows 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #!/usr/bin/env python import time import stretch_body.robot from stretch_body.hello_utils import ThreadServiceExit robot = stretch_body . robot . Robot () robot . startup () x_move_base = 0 x_move_arm = 0 x_move_lift = 0 x_move_head_pan = 0 x_move_head_tilt = 0 x_move_wrist_yaw = 0 x_move_gripper = 0 def update_my_behavior ( status ): #Update the joint commands based on the status data pass try : while True : #Get a snapshot of the robot status data status = robot . get_status () #Compute new position targets based on sensor data update_my_behavior ( status ) #Queue new targets to devices robot . base . translate_by ( x_move_base ) #or robot.base.rotate_by() robot . arm . move_by ( x_move_arm ) robot . lift . move_by ( x_move_lift ) robot . head . move_by ( 'head_pan' , x_move_head_pan ) robot . head . move_by ( 'head_tilt' , x_move_head_tilt ) robot . end_of_arm . move_by ( 'wrist_yaw' , x_move_wrist_yaw ) robot . end_of_arm . move_by ( 'stretch_gripper' , x_move_gripper ) #Synchronized send of new position targets robot . push_command () #Wait for next control cycle time . sleep ( 0.1 ) except ( KeyboardInterrupt , SystemExit , ThreadServiceExit ) pass robot . stop ()","title":"Quick Start"},{"location":"stretch-body/stretch_body_guide/#working-with-stretch-body","text":"The Stretch_Body package provides a low level Python API to the Stretch RE1 hardware. The package is available on Git and installable via Pip . It encapsulates Mobile base Arm Lift Head actuators Wrist and tool actuators Wrist accelerometer and Arduino Base power and IMU board The robot's 3rd party hardware devices are intended to be accessed through ROS and not Stretch_Body. However, it is possible to directly access this hardware through open-source Python packages: Laser range finder: rplidar Respeaker: respeaker_python_library D435i: pyrealsense2 The Stretch_Body package is intended for advanced users who prefer to not use ROS to control the robot. It assumes a moderate level of experience programming robot sensors and actuators.","title":"Working with Stretch Body"},{"location":"stretch-body/stretch_body_guide/#robot-interface","text":"The primary developer interface to Stretch_Body is the Robot class . As an example, the Python script below prints all Robot sensor and state data to the console every 250ms. 1 2 3 4 5 6 7 8 9 10 11 import time import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () for i in range ( 10 ): robot . pretty_print () time . sleep ( 0.25 ) robot . stop () Looking at this in detail: 2 import stretch_body.robot The package stretch_body includes the Python module for Robot as well as other Devices such as Lift and Arm. 4 5 robot = stretch_body . robot . Robot () robot . startup () Here we instantiate an instance of our Robot. The call to startup() opens the serial ports to the various devices, loads the Robot YAML parameters, and launches a few helper threads. 7 8 9 for i in range ( 10 ): robot . pretty_print () time . sleep ( 0.25 ) The call to pretty_print() prints to console all of the robot's sensor and state data. 11 robot . stop () Finally, the stop() method shuts down the Robot threads and cleanly closes the open serial ports.","title":"Robot Interface"},{"location":"stretch-body/stretch_body_guide/#units","text":"The Robot API uses SI units of: meters radians seconds Newtons Amps Volts Parameters may be named with a suffix to help describe the unit type. For example: pos_m : meters pos_r: radians","title":"Units"},{"location":"stretch-body/stretch_body_guide/#the-robot-status","text":"The Robot derives from the Device class . It also encapsulates a number of other Devices: robot.head robot.arm robot.lift robot.base robot.wacc robot.pimu robot.end_of_arm All devices contain a Status dictionary. The Status contains the most recent sensor and state data of that device. For example, looking at the Arm class we see: class Arm ( Device ): def __init__ ( self ): ... self . status = { 'pos' : 0.0 , 'vel' : 0.0 , 'force' : 0.0 , \\ 'motor' : self . motor . status , 'timestamp_pc' : 0 } The Status dictionaries are automatically updated by a background thread of the Robot at 25Hz. The Status data can be accessed via the Robot. For example: if robot . arm . status [ 'pos' ] > 0.25 : print ( 'Arm extension greater than 0.25m' ) If an instantaneous snapshot of the entire Robot Status is needed, the get_status() method can be used instead: status = robot . get_status () if status [ 'arm' ][ 'pos' ] > 0.25 : print ( 'Arm extension greater than 0.25m' )","title":"The Robot Status"},{"location":"stretch-body/stretch_body_guide/#the-robot-command","text":"In contrast to the Robot Status which pulls data from the Devices, the Robot Command pushes data to the Devices. Consider the following example which extends and then retracts the arm by 0.1 meters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import time import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . arm . move_by ( 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . arm . move_by ( - 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . stop () A few important things are going on: 7 robot . arm . move_by ( 0.1 ) The move_by() method queues up an RPC command to the stepper motor controller. However, the command does not yet execute. 8 robot . push_command () The push_command() causes all queued up RPC commands to be executed at once. In this example we call sleep() to allow time for the motion to complete before initiating a new motion. NOTE : The Dynamixel servos do not use the Hello Robot RPC protocol. As such, the head, wrist, and gripper will move immediately upon issuing a motion command. The stepper actuators support a synchronous mode, allowing the base, arm, and lift to synchronously track trajectories. Thus, the following code will cause the base, arm, and lift to initiate motion simultaneously: robot . arm . move_by ( 0.1 ) robot . lift . move_by ( 0.1 ) robot . base . translate_by ( 0.1 ) robot . push_command () Commanding robot motion through the Stretch_Body interface is covered in more detail in the Robot Motion section.","title":"The Robot Command"},{"location":"stretch-body/stretch_body_guide/#stowing-and-homing","text":"After power up the robot requires homing in order for its joint encoders to find their zero position. The homing procedure will run the robot through a series of moves to find these zeros. It can be done programatically: if not robot . is_calibrated (): robot . home () #blocking Or it can be done manually after boot using the command line tool: $ stretch_robot_home.py Likewise, stowing is a robot procedure that will cause it to move its arm and tool safely within the footprint of the base. robot . stow () #blocking Or it can be done manually from the command line when needed: $ stretch_robot_stow.py","title":"Stowing and Homing"},{"location":"stretch-body/stretch_body_guide/#scripting-the-robot","text":"A simplified design pattern to script the Robot is as follows 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #!/usr/bin/env python import time import stretch_body.robot from stretch_body.hello_utils import ThreadServiceExit robot = stretch_body . robot . Robot () robot . startup () x_move_base = 0 x_move_arm = 0 x_move_lift = 0 x_move_head_pan = 0 x_move_head_tilt = 0 x_move_wrist_yaw = 0 x_move_gripper = 0 def update_my_behavior ( status ): #Update the joint commands based on the status data pass try : while True : #Get a snapshot of the robot status data status = robot . get_status () #Compute new position targets based on sensor data update_my_behavior ( status ) #Queue new targets to devices robot . base . translate_by ( x_move_base ) #or robot.base.rotate_by() robot . arm . move_by ( x_move_arm ) robot . lift . move_by ( x_move_lift ) robot . head . move_by ( 'head_pan' , x_move_head_pan ) robot . head . move_by ( 'head_tilt' , x_move_head_tilt ) robot . end_of_arm . move_by ( 'wrist_yaw' , x_move_wrist_yaw ) robot . end_of_arm . move_by ( 'stretch_gripper' , x_move_gripper ) #Synchronized send of new position targets robot . push_command () #Wait for next control cycle time . sleep ( 0.1 ) except ( KeyboardInterrupt , SystemExit , ThreadServiceExit ) pass robot . stop ()","title":"Scripting the Robot"},{"location":"stretch-body/stretch_body_snippets/","text":"Coming soon.","title":"Snippets"},{"location":"stretch-body/tutorial_collision_avoidance/","text":"Working with the Collision Avoidance System In this tutorial we will discuss the simple collision avoidance system that runs as a part of Stretch Body. Note : This tutorial applies to Stretch Body version 0.1.x or greater. Overview Stretch Body includes a system to prevent inadvertent self-collisions. Note : Self collisions are still possible while using the collision-avoidance system. The factory default collision models are coarse and not necessarily complete. Joint Limits The collision avoidance system works by dynamically modifying the acceptable range of motion for each joint. By default, a joint's range is set to the physical hardstop limits. For example, the lift has a mechanical throw of 1.1m: >> $stretch_params .py | grep range | grep lift stretch_body.robot_params.factory_params param.lift.range_m [ 0 .0, 1 .1 ] A reduced range-of-motion can be set at run-time by setting the Soft Motion Limit. For example, to limit the lift range of motion to 0.3 meter off the base: import stretch_body.robot as robot r = robot . Robot () r . startup () r . lift . set_soft_motion_limit_min ( 0.3 ) We see in the API , the value of None is used to designated no soft limit. It is possible that when setting the Soft Motion Limit that the joints current position is outside of the specified range. In this case, the joint will move to the nearest soft limit so as to comply with the limits. This can be demonstrated by: import stretch_body.robot as robot import time r = robot . Robot () r . startup () #Move to 0.2 r . lift . move_to ( 0.2 ) r . push_command () time . sleep ( 5.0 ) #Will move to 0.3 r . lift . set_soft_motion_limit_min ( 0.3 ) Collision Models The RobotCollision class manages a set of RobotCollisionModels . Each RobotCollisionModel computes the soft limits for a subset of joints based on a simple geometric model. The step method of a RobotCollisionModel returns the desired joint limits given that model. For example, the base class is simply: class RobotCollisionModel ( Device ): def step ( self , status ): return { 'head_pan' : [ None , None ], 'head_tilt' : [ None , None ], 'lift' : [ None , None ], 'arm' : [ None , None ], 'wrist_yaw' : [ None , None ]} , where the value of None specifies that no-limit is specified and the full range-of-motion for the joint is acceptable. We could define a new collision model that simply limits the lift range of motion to 1 meter by: class MyCollisionModel ( Device ): def step ( self , status ): return { 'head_pan' : [ None , None ], 'head_tilt' : [ None , None ], 'lift' : [ None , 1.0 ], 'arm' : [ None , None ], 'wrist_yaw' : [ None , None ]} Each model is registered with the RobotCollision instance as a loadable plug-in. The Robot class calls the RobotCollision.step method periodically at approximately 10hz. RobotCollision.step computes the 'AND' of the limits specified across each Collision Model such that the most restrictive joint limits are set for each joint using the set_soft_motion_limit_min , set_soft_motion_limt_max methods. Default Collision Models The default collision models for Stretch Body are found in robot_collision_models.py . As of this writing, the provide models are: CollisionArmCamera: Avoid collision of the head camera with the arm CollisionStretchGripper: Avoid collision of the wrist-yaw and gripper with the base and ground Note : The provided collision models are coarse and are provided to avoid common potentially harmful collisions only. Using these models it is still possible to collide the robot with itself in some cases. Working with Models The collision models to be used by Stretch Body are defined with the robot_collision parameter. For example, we see in robot_params.py that the CollisionArmCamera is loaded by default \"robot_collision\" : { 'models' : [ 'collision_arm_camera' ]}, We also see that model collision_arm_camera is defined as: \"collision_arm_camera\" : { 'enabled' : 1 , 'py_class_name' : 'CollisionArmCamera' , 'py_module_name' : 'stretch_body.robot_collision_models' } This instructs RobotCollision to construct a model of type CollisionArmCamera and enable it by default. One can disable this model by default by specifying the following stretch_re1_user_params.yaml : collision_arm_camera : enabled : 0 The entire collision avoidance system can be disabled in stretch_re1_user_params.yaml by: robot : use_collision_manager : 0 A specific collision model can be enabled or disabled during runtime by: import stretch_body.robot r = stretch_body . robot . Robot () r . startup () ... #Do some work r . collision . disable_model ( 'collsion_arm_camera' ) ... #Do some work r . collision . enable_model ( 'collsion_arm_camera' ) Finally, if we want to also use the CollisionStretchGripper model, we can add to stretch_re1_user_params.py : robot_collision : models : - collision_arm_camera - collision_stretch_gripper Creating a Custom Collision Model It can be straightforward to create your own custom collision model. As an example, we will create a model that avoids collision of the arm with a table top by Prevent the lift from descending below the table top when the arm is extended Allow the lift to descend below the tabletop so long as the arm retracted This assumes the arm is initially above the table top. To start, in a file collision_arm_table.py we add: from stretch_body.robot_collision import * from stretch_body.hello_utils import * class CollisionArmTable ( RobotCollisionModel ): def __init__ ( self , collision_manager ): RobotCollisionModel . __init__ ( self , collision_manager , 'collision_arm_table' ) def step ( self , status ): limits = { 'lift' : [ None , None ], 'arm' : [ None , None ]} table_height = 0.5 #m arm_safe_retract = 0.1 #m safety_margin = .05 #m x_arm = status [ 'arm' ][ 'pos' ] x_lift = status [ 'lift' ][ 'pos' ] #Force arm to stay retracted if below table if x_lift < table_height : limits [ 'arm' ] = [ None , arm_safe_retract - safety_margin ] else : limits [ 'arm' ] = [ None , None ] #Force lift to stay above table unless arm is retracted if x_arm < arm_safe_retract : limits [ 'lift' ] = [ None , None ] else : limits [ 'lift' ] = [ table_height + safety_margin , None ] return limits In this example we include the safety_margin as a way to introduce some hysteresis around state changes to avoid toggling between the soft limits. The following command should be run in order to add the working directory to the PYTHONPATH env , This can also be added to our bashrc to permanently edit the path: >>$ export PYTHONPATH = $PYTHONPATH :/<path_to_modules> Next we configure RobotCollision to use our CollisionArmTable model in stretch_re1_user_yaml : robot_collision : models : - collision_arm_table collision_arm_table : enabled : 1 py_class_name : 'CollisionArmTable' py_module_name : 'collision_arm_table' Finally, test out the model by driving the arm and lift around using the XBox teleoperation tool: >>$ stretch_xbox_controller_teleop.py","title":"Collision Avoidance"},{"location":"stretch-body/tutorial_collision_avoidance/#working-with-the-collision-avoidance-system","text":"In this tutorial we will discuss the simple collision avoidance system that runs as a part of Stretch Body. Note : This tutorial applies to Stretch Body version 0.1.x or greater.","title":"Working with the Collision Avoidance System"},{"location":"stretch-body/tutorial_collision_avoidance/#overview","text":"Stretch Body includes a system to prevent inadvertent self-collisions. Note : Self collisions are still possible while using the collision-avoidance system. The factory default collision models are coarse and not necessarily complete.","title":"Overview"},{"location":"stretch-body/tutorial_collision_avoidance/#joint-limits","text":"The collision avoidance system works by dynamically modifying the acceptable range of motion for each joint. By default, a joint's range is set to the physical hardstop limits. For example, the lift has a mechanical throw of 1.1m: >> $stretch_params .py | grep range | grep lift stretch_body.robot_params.factory_params param.lift.range_m [ 0 .0, 1 .1 ] A reduced range-of-motion can be set at run-time by setting the Soft Motion Limit. For example, to limit the lift range of motion to 0.3 meter off the base: import stretch_body.robot as robot r = robot . Robot () r . startup () r . lift . set_soft_motion_limit_min ( 0.3 ) We see in the API , the value of None is used to designated no soft limit. It is possible that when setting the Soft Motion Limit that the joints current position is outside of the specified range. In this case, the joint will move to the nearest soft limit so as to comply with the limits. This can be demonstrated by: import stretch_body.robot as robot import time r = robot . Robot () r . startup () #Move to 0.2 r . lift . move_to ( 0.2 ) r . push_command () time . sleep ( 5.0 ) #Will move to 0.3 r . lift . set_soft_motion_limit_min ( 0.3 )","title":"Joint Limits"},{"location":"stretch-body/tutorial_collision_avoidance/#collision-models","text":"The RobotCollision class manages a set of RobotCollisionModels . Each RobotCollisionModel computes the soft limits for a subset of joints based on a simple geometric model. The step method of a RobotCollisionModel returns the desired joint limits given that model. For example, the base class is simply: class RobotCollisionModel ( Device ): def step ( self , status ): return { 'head_pan' : [ None , None ], 'head_tilt' : [ None , None ], 'lift' : [ None , None ], 'arm' : [ None , None ], 'wrist_yaw' : [ None , None ]} , where the value of None specifies that no-limit is specified and the full range-of-motion for the joint is acceptable. We could define a new collision model that simply limits the lift range of motion to 1 meter by: class MyCollisionModel ( Device ): def step ( self , status ): return { 'head_pan' : [ None , None ], 'head_tilt' : [ None , None ], 'lift' : [ None , 1.0 ], 'arm' : [ None , None ], 'wrist_yaw' : [ None , None ]} Each model is registered with the RobotCollision instance as a loadable plug-in. The Robot class calls the RobotCollision.step method periodically at approximately 10hz. RobotCollision.step computes the 'AND' of the limits specified across each Collision Model such that the most restrictive joint limits are set for each joint using the set_soft_motion_limit_min , set_soft_motion_limt_max methods.","title":"Collision Models"},{"location":"stretch-body/tutorial_collision_avoidance/#default-collision-models","text":"The default collision models for Stretch Body are found in robot_collision_models.py . As of this writing, the provide models are: CollisionArmCamera: Avoid collision of the head camera with the arm CollisionStretchGripper: Avoid collision of the wrist-yaw and gripper with the base and ground Note : The provided collision models are coarse and are provided to avoid common potentially harmful collisions only. Using these models it is still possible to collide the robot with itself in some cases.","title":"Default Collision Models"},{"location":"stretch-body/tutorial_collision_avoidance/#working-with-models","text":"The collision models to be used by Stretch Body are defined with the robot_collision parameter. For example, we see in robot_params.py that the CollisionArmCamera is loaded by default \"robot_collision\" : { 'models' : [ 'collision_arm_camera' ]}, We also see that model collision_arm_camera is defined as: \"collision_arm_camera\" : { 'enabled' : 1 , 'py_class_name' : 'CollisionArmCamera' , 'py_module_name' : 'stretch_body.robot_collision_models' } This instructs RobotCollision to construct a model of type CollisionArmCamera and enable it by default. One can disable this model by default by specifying the following stretch_re1_user_params.yaml : collision_arm_camera : enabled : 0 The entire collision avoidance system can be disabled in stretch_re1_user_params.yaml by: robot : use_collision_manager : 0 A specific collision model can be enabled or disabled during runtime by: import stretch_body.robot r = stretch_body . robot . Robot () r . startup () ... #Do some work r . collision . disable_model ( 'collsion_arm_camera' ) ... #Do some work r . collision . enable_model ( 'collsion_arm_camera' ) Finally, if we want to also use the CollisionStretchGripper model, we can add to stretch_re1_user_params.py : robot_collision : models : - collision_arm_camera - collision_stretch_gripper","title":"Working with Models"},{"location":"stretch-body/tutorial_collision_avoidance/#creating-a-custom-collision-model","text":"It can be straightforward to create your own custom collision model. As an example, we will create a model that avoids collision of the arm with a table top by Prevent the lift from descending below the table top when the arm is extended Allow the lift to descend below the tabletop so long as the arm retracted This assumes the arm is initially above the table top. To start, in a file collision_arm_table.py we add: from stretch_body.robot_collision import * from stretch_body.hello_utils import * class CollisionArmTable ( RobotCollisionModel ): def __init__ ( self , collision_manager ): RobotCollisionModel . __init__ ( self , collision_manager , 'collision_arm_table' ) def step ( self , status ): limits = { 'lift' : [ None , None ], 'arm' : [ None , None ]} table_height = 0.5 #m arm_safe_retract = 0.1 #m safety_margin = .05 #m x_arm = status [ 'arm' ][ 'pos' ] x_lift = status [ 'lift' ][ 'pos' ] #Force arm to stay retracted if below table if x_lift < table_height : limits [ 'arm' ] = [ None , arm_safe_retract - safety_margin ] else : limits [ 'arm' ] = [ None , None ] #Force lift to stay above table unless arm is retracted if x_arm < arm_safe_retract : limits [ 'lift' ] = [ None , None ] else : limits [ 'lift' ] = [ table_height + safety_margin , None ] return limits In this example we include the safety_margin as a way to introduce some hysteresis around state changes to avoid toggling between the soft limits. The following command should be run in order to add the working directory to the PYTHONPATH env , This can also be added to our bashrc to permanently edit the path: >>$ export PYTHONPATH = $PYTHONPATH :/<path_to_modules> Next we configure RobotCollision to use our CollisionArmTable model in stretch_re1_user_yaml : robot_collision : models : - collision_arm_table collision_arm_table : enabled : 1 py_class_name : 'CollisionArmTable' py_module_name : 'collision_arm_table' Finally, test out the model by driving the arm and lift around using the XBox teleoperation tool: >>$ stretch_xbox_controller_teleop.py","title":"Creating a Custom Collision Model"},{"location":"stretch-body/tutorial_command_line_tools/","text":"Command Line Tools The Stretch_Body package comes with a suite of command line tools that allow direct interaction with hardware subsystems. These can be useful when developing and debugging applications. They also serve as code examples when developing applications for Stretch_Body. These tools can be found by tab completion of 'stretch_' from a terminal. $ stretch_ stretch_about.py stretch_gripper_home.py stretch_lift_jog.py stretch_robot_dynamixel_reboot.py stretch_robot_stow.py stretch_wacc_scope.py stretch_arm_home.py stretch_gripper_jog.py stretch_pimu_jog.py stretch_robot_home.py stretch_robot_system_check.py stretch_wrist_yaw_home.py stretch_arm_jog.py stretch_hardware_echo.py stretch_pimu_scope.py stretch_robot_jog.py stretch_rp_lidar_jog.py stretch_wrist_yaw_jog.py stretch_audio_test.py stretch_head_jog.py stretch_respeaker_test.py stretch_robot_keyboard_teleop.py stretch_urdf_show.py stretch_xbox_controller_teleop.py stretch_base_jog.py stretch_lift_home.py stretch_robot_battery_check.py stretch_robot_monitor.py stretch_wacc_jog.py All tools accept '--help' as a command line argument to learn its function. For example: $ stretch_wacc_scope.py --help usage: stretch_wacc_scope.py [-h] [--ax] [--ay] [--az] [--a0] [--d0] [--d1] [--tap] Visualize Wacc (Wrist+Accel) board data with an oscilloscope optional arguments: -h, --help show this help message and exit --ax Scope accelerometer AX --ay Scope accelerometer AY --az Scope accelerometer AZ --a0 Scope analog-in-0 --d0 Scope digital-in-0 --d1 Scope digital-in-1 --tap Scope single tap Commonly Used Tools These are the tools a typical user will want to become familiar with. Tool Utility stretch_robot_home.py Commonly run after booting up the robot in-order to calibrate the joints stretch_robot_system_check.py Scans for all hardware devices and ensure they are present on the bus and reporting valid values. Useful to verify that the robot is in good working order prior to commanding motion. It will report all success in green, failures in red. stretch_robot_stow.py Useful to return the robot arm and tool to a safe position within the base footprint. It can also be useful if a program fails to exit cleanly and the robot joints are not backdriveable. It will restore them to their 'Safety' state. stretch_robot_battery_check.py Quick way to check the battery voltage / current consumption stretch_xbox_controller_teleop.py Useful to quickly test if a robot can achieve a task by manually teleoperating the robot stretch_robot_dynamixel_reboot.py This will reset all Dynamixels in the robot, which may be needed if a servo overheats during high use and enters an error state. The other tools are fairly self explanatory. They allow the user to quickly read a sensor value or control an individual hardware subsystem.","title":"Command line Tools"},{"location":"stretch-body/tutorial_command_line_tools/#command-line-tools","text":"The Stretch_Body package comes with a suite of command line tools that allow direct interaction with hardware subsystems. These can be useful when developing and debugging applications. They also serve as code examples when developing applications for Stretch_Body. These tools can be found by tab completion of 'stretch_' from a terminal. $ stretch_ stretch_about.py stretch_gripper_home.py stretch_lift_jog.py stretch_robot_dynamixel_reboot.py stretch_robot_stow.py stretch_wacc_scope.py stretch_arm_home.py stretch_gripper_jog.py stretch_pimu_jog.py stretch_robot_home.py stretch_robot_system_check.py stretch_wrist_yaw_home.py stretch_arm_jog.py stretch_hardware_echo.py stretch_pimu_scope.py stretch_robot_jog.py stretch_rp_lidar_jog.py stretch_wrist_yaw_jog.py stretch_audio_test.py stretch_head_jog.py stretch_respeaker_test.py stretch_robot_keyboard_teleop.py stretch_urdf_show.py stretch_xbox_controller_teleop.py stretch_base_jog.py stretch_lift_home.py stretch_robot_battery_check.py stretch_robot_monitor.py stretch_wacc_jog.py All tools accept '--help' as a command line argument to learn its function. For example: $ stretch_wacc_scope.py --help usage: stretch_wacc_scope.py [-h] [--ax] [--ay] [--az] [--a0] [--d0] [--d1] [--tap] Visualize Wacc (Wrist+Accel) board data with an oscilloscope optional arguments: -h, --help show this help message and exit --ax Scope accelerometer AX --ay Scope accelerometer AY --az Scope accelerometer AZ --a0 Scope analog-in-0 --d0 Scope digital-in-0 --d1 Scope digital-in-1 --tap Scope single tap","title":"Command Line Tools"},{"location":"stretch-body/tutorial_command_line_tools/#commonly-used-tools","text":"These are the tools a typical user will want to become familiar with. Tool Utility stretch_robot_home.py Commonly run after booting up the robot in-order to calibrate the joints stretch_robot_system_check.py Scans for all hardware devices and ensure they are present on the bus and reporting valid values. Useful to verify that the robot is in good working order prior to commanding motion. It will report all success in green, failures in red. stretch_robot_stow.py Useful to return the robot arm and tool to a safe position within the base footprint. It can also be useful if a program fails to exit cleanly and the robot joints are not backdriveable. It will restore them to their 'Safety' state. stretch_robot_battery_check.py Quick way to check the battery voltage / current consumption stretch_xbox_controller_teleop.py Useful to quickly test if a robot can achieve a task by manually teleoperating the robot stretch_robot_dynamixel_reboot.py This will reset all Dynamixels in the robot, which may be needed if a servo overheats during high use and enters an error state. The other tools are fairly self explanatory. They allow the user to quickly read a sensor value or control an individual hardware subsystem.","title":"Commonly Used Tools"},{"location":"stretch-body/tutorial_dynamixel_servos/","text":"Working with Dynamixel Servos In this tutorial we will cover the basics required to work with Dynamixel servos and Stretch. Note : This tutorial applies to Stretch Body v0.1.x or greater Overview Stretch comes with two Dynamixel buses - one for the head and one for the end-of-arm: $ ls /dev/hello-dynamixel-* /dev/hello-dynamixel-head /dev/hello-dynamixel-wrist Typically users will interact with these devices through either the Head or EndOfArm interfaces. The EndOfArm interface may be extended to support custom tools, as described in the Stretch Body Tool Change Tutorial. In some cases users will need to work directly with the servos from the command line. The sections below covers these tools Servo Tools Jogging the Servos You can directly command each servo using the command line tool RE1_dynamixel_servo_jog.py . This can be useful for debugging new servos added to the end-of-arm tool during system bring-up. For example, to command the head pan servo: $ RE1_dynamixel_jog.py /dev/hello-dynamixel-head 11 [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1080 ------ MENU ------- m: menu a: increment position 50 tick b: decrement position 50 tick A: increment position 500 ticks B: decrement position 500 ticks v: set profile velocity u: set profile acceleration z: zero position h: show homing offset o: zero homing offset q: got to position p: ping r: reboot w: set max pwm t: set max temp i: set id d: disable torque e: enable torque ------------------- Rebooting the Servos Under high-load conditions the servos may enter an error state to protect themselves from thermal overload. In this case, the red LED on the servo will flash (if visible). In addition, the servo will be unresponsive to motion commands. In this case, allow the overheating servo to cool down and reboot the servos using the stretch_robot_dynamixel_reboot.py tool: $ stretch_robot_dynamixel_reboot.py For use with S T R E T C H (TM) RESEARCH EDITION from Hello Robot Inc. ---- Rebooting Head ---- [Dynamixel ID:011] Reboot Succeeded. [Dynamixel ID:012] Reboot Succeeded. ---- Rebooting Wrist ---- [Dynamixel ID:013] Reboot Succeeded. [Dynamixel ID:014] Reboot Succeeded. Identify Servos on the Bus If it is unclear which servos are on the bus, and at what baud rate, you can use the RE1_dynamixel_id_scan.py tool. Here we see that the two head servos are at ID 11 and 12 at baud 57600. $ RE1_dynamixel_id_scan.py /dev/hello-dynamixel-head --baud 57600 Scanning bus /dev/hello-dynamixel-head at baud rate 57600 ---------------------------------------------------------- [Dynamixel ID:000] ping Failed. [Dynamixel ID:001] ping Failed. [Dynamixel ID:002] ping Failed. [Dynamixel ID:003] ping Failed. [Dynamixel ID:004] ping Failed. [Dynamixel ID:005] ping Failed. [Dynamixel ID:006] ping Failed. [Dynamixel ID:007] ping Failed. [Dynamixel ID:008] ping Failed. [Dynamixel ID:009] ping Failed. [Dynamixel ID:010] ping Failed. [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1080 [Dynamixel ID:012] ping Succeeded. Dynamixel model number : 1060 [Dynamixel ID:013] ping Failed. [Dynamixel ID:014] ping Failed. [Dynamixel ID:015] ping Failed. [Dynamixel ID:016] ping Failed. [Dynamixel ID:017] ping Failed. [Dynamixel ID:018] ping Failed. [Dynamixel ID:019] ping Failed. [Dynamixel ID:020] ping Failed. [Dynamixel ID:021] ping Failed. [Dynamixel ID:022] ping Failed. [Dynamixel ID:023] ping Failed. [Dynamixel ID:024] ping Failed. Setting the Servo Baud Rate Dynamixel servos come with baudrate=57600 from the factory. When adding your own servos to the end-of-arm tool, you may want to set the servo ID using the RE1_dynamixel_set_baud.py tool. For example: $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-wrist 13 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud Setting the Servo ID Dynamixel servos come with ID=1 from the factory. When adding your own servos to the end-of-arm tool, you may want to set the servo ID using the RE1_dynamixel_id_change.py tool. For example: $ RE1_dynamixel_id_change.py /dev/hello-dynamixel-wrist 1 13 --baud 115200 [Dynamixel ID:001] ping Succeeded. Dynamixel model number : 1080 Ready to change ID 1 to 13. Hit enter to continue: [Dynamixel ID:013] ping Succeeded. Dynamixel model number : 1080 Success at setting ID to 13 All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Dynamixel Servos"},{"location":"stretch-body/tutorial_dynamixel_servos/#working-with-dynamixel-servos","text":"In this tutorial we will cover the basics required to work with Dynamixel servos and Stretch. Note : This tutorial applies to Stretch Body v0.1.x or greater","title":"Working with Dynamixel Servos"},{"location":"stretch-body/tutorial_dynamixel_servos/#overview","text":"Stretch comes with two Dynamixel buses - one for the head and one for the end-of-arm: $ ls /dev/hello-dynamixel-* /dev/hello-dynamixel-head /dev/hello-dynamixel-wrist Typically users will interact with these devices through either the Head or EndOfArm interfaces. The EndOfArm interface may be extended to support custom tools, as described in the Stretch Body Tool Change Tutorial. In some cases users will need to work directly with the servos from the command line. The sections below covers these tools","title":"Overview"},{"location":"stretch-body/tutorial_dynamixel_servos/#servo-tools","text":"","title":"Servo Tools"},{"location":"stretch-body/tutorial_dynamixel_servos/#jogging-the-servos","text":"You can directly command each servo using the command line tool RE1_dynamixel_servo_jog.py . This can be useful for debugging new servos added to the end-of-arm tool during system bring-up. For example, to command the head pan servo: $ RE1_dynamixel_jog.py /dev/hello-dynamixel-head 11 [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1080 ------ MENU ------- m: menu a: increment position 50 tick b: decrement position 50 tick A: increment position 500 ticks B: decrement position 500 ticks v: set profile velocity u: set profile acceleration z: zero position h: show homing offset o: zero homing offset q: got to position p: ping r: reboot w: set max pwm t: set max temp i: set id d: disable torque e: enable torque -------------------","title":"Jogging the Servos"},{"location":"stretch-body/tutorial_dynamixel_servos/#rebooting-the-servos","text":"Under high-load conditions the servos may enter an error state to protect themselves from thermal overload. In this case, the red LED on the servo will flash (if visible). In addition, the servo will be unresponsive to motion commands. In this case, allow the overheating servo to cool down and reboot the servos using the stretch_robot_dynamixel_reboot.py tool: $ stretch_robot_dynamixel_reboot.py For use with S T R E T C H (TM) RESEARCH EDITION from Hello Robot Inc. ---- Rebooting Head ---- [Dynamixel ID:011] Reboot Succeeded. [Dynamixel ID:012] Reboot Succeeded. ---- Rebooting Wrist ---- [Dynamixel ID:013] Reboot Succeeded. [Dynamixel ID:014] Reboot Succeeded.","title":"Rebooting the Servos"},{"location":"stretch-body/tutorial_dynamixel_servos/#identify-servos-on-the-bus","text":"If it is unclear which servos are on the bus, and at what baud rate, you can use the RE1_dynamixel_id_scan.py tool. Here we see that the two head servos are at ID 11 and 12 at baud 57600. $ RE1_dynamixel_id_scan.py /dev/hello-dynamixel-head --baud 57600 Scanning bus /dev/hello-dynamixel-head at baud rate 57600 ---------------------------------------------------------- [Dynamixel ID:000] ping Failed. [Dynamixel ID:001] ping Failed. [Dynamixel ID:002] ping Failed. [Dynamixel ID:003] ping Failed. [Dynamixel ID:004] ping Failed. [Dynamixel ID:005] ping Failed. [Dynamixel ID:006] ping Failed. [Dynamixel ID:007] ping Failed. [Dynamixel ID:008] ping Failed. [Dynamixel ID:009] ping Failed. [Dynamixel ID:010] ping Failed. [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1080 [Dynamixel ID:012] ping Succeeded. Dynamixel model number : 1060 [Dynamixel ID:013] ping Failed. [Dynamixel ID:014] ping Failed. [Dynamixel ID:015] ping Failed. [Dynamixel ID:016] ping Failed. [Dynamixel ID:017] ping Failed. [Dynamixel ID:018] ping Failed. [Dynamixel ID:019] ping Failed. [Dynamixel ID:020] ping Failed. [Dynamixel ID:021] ping Failed. [Dynamixel ID:022] ping Failed. [Dynamixel ID:023] ping Failed. [Dynamixel ID:024] ping Failed.","title":"Identify Servos on the Bus"},{"location":"stretch-body/tutorial_dynamixel_servos/#setting-the-servo-baud-rate","text":"Dynamixel servos come with baudrate=57600 from the factory. When adding your own servos to the end-of-arm tool, you may want to set the servo ID using the RE1_dynamixel_set_baud.py tool. For example: $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-wrist 13 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud","title":"Setting the Servo Baud Rate"},{"location":"stretch-body/tutorial_dynamixel_servos/#setting-the-servo-id","text":"Dynamixel servos come with ID=1 from the factory. When adding your own servos to the end-of-arm tool, you may want to set the servo ID using the RE1_dynamixel_id_change.py tool. For example: $ RE1_dynamixel_id_change.py /dev/hello-dynamixel-wrist 1 13 --baud 115200 [Dynamixel ID:001] ping Succeeded. Dynamixel model number : 1080 Ready to change ID 1 to 13. Hit enter to continue: [Dynamixel ID:013] ping Succeeded. Dynamixel model number : 1080 Success at setting ID to 13 All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Setting the Servo ID"},{"location":"stretch-body/tutorial_parameter_management/","text":"Working With Parameters In this tutorial we will discuss how parameters are managed in Stretch Body and show examples of how to customize your robot by overriding parameters. Note : This tutorial applies to Stretch Body version 0.1.x or greater. Overview Stretch Body shares a global set of parameters across all of its Python Devices. A quick way to see what parameters are available are with the stretch_params.py tool: $ stretch_params.py # ################################## Parameters for stretch-re1-1039 ###################################### Origin Parameter Value ---------------------------------------------------------------------------------------------------------- stretch_re1_factory_params.yaml param.head_pan.req_calibration 0 stretch_re1_factory_params.yaml param.head_tilt.pwm_limit 885 ... The tool display each parameter's value as well as which parameter file it was loaded from. By grepping the tool's output you can query specific settings. For example, to query contact thresholds for the arm: $ stretch_params.py | grep arm | grep contact_thresh stretch_re1_factory_params.yaml param.arm.contact_thresh_max_N [-100, 100] stretch_re1_factory_params.yaml param.arm.contact_thresh_N [-64.46241590881348, 66.51084520568847] Now if you want to override the default contact thresholds for the arm, you could add the following to your stretch_re1_user_params.yaml : arm : contact_thresh_N : [ -80.0 , 80.0 ] Run the tool again and we see: $ stretch_params.py | grep arm | grep contact_thresh stretch_re1_factory_params.yaml param.arm.contact_thresh_max_N [-100, 100] stretch_re1_factory_params.yaml param.arm.contact_thresh_N [-80, 80] Data Organization Parameters' data sources may be either a Python dictionary or a YAML file. The robot's YAML files are found under $HELLO_FLEET_PATH/$HELLO_FLEET_ID . The Python dictionaries may come from any Python module on the Python path. There are three types of parameters: Factory Parameters stretch_re1_factory_params.yaml : These are common factory settings shared across RE1s as well as factory calibration data that is specific to your robot. stretch_body.robot_params.py : These are common factory settings shared across RE1s that may be automatically updated over time as new versions of Stretch Body are released. External Parameters <external_module>.params.py : These are parameters for devices outside of Stretch Body (such as the devices found in the Stretch Tool Share) User Parameters stretch_re1_user_params.yaml : These are user customizations of the robot's settings As shown below, the parameters are loaded into the robot_params dictionary in a specific order, starting with stretch_re1_factory_params.yaml . Loading of subsequent parameters overwrites earlier parameters. As such, the stretch_re1_user_params.yaml parameters can overwrite any factory parameters or external parameters. You can configure which external parameters' data sources are loaded, and their order, in your stretch_re1_user_params.yaml . For example: factory_params : stretch_re1_factory_params.yaml params : - stretch_tool_share.usbcam_wrist_v1.params - stretch_tool_share.stretch_dex_wrist_beta.params Here we see that the name of the factory parameters file is stretch_re1_factory_params.yaml . We also see that two external parameter sets will be loaded. In this example, the order of parameter precedence would be: stretch_re1_user_params.yaml stretch_tool_share.stretch_dex_wrist_beta.params.py stretch_tool_share.usbcam_wrist_v1.params.py stretch_body.robot_params.py stretch_re1_factory_params.yaml Working with Parameters Programmatically Stretch Body is organized as a set of classes that extend the base Device class. Each Device has access to a set of global parameters that are stored within the Device as a dictionary. These are: device.params : the parameters for the specific device device.robot_params : global set of parameters For example, let's look at the Robot class: class Robot ( Device ): def __init__ ( self ): Device . __init__ ( self , 'robot' ) ... When instantiating its Device base class it loads the robot parameters of the various YAML files and Python dictionaries. class Device : def __init__ ( self , name ): self . name = name self . user_params , self . robot_params = RobotParams . get_params () try : self . params = self . robot_params [ self . name ] except KeyError : print ( 'No device params found for %s ' % name ) self . params = {} We can explore these parameters via iPython. In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . params Out [ 3 ]: { 'batch_name' : 'Irma' , 'log_to_console' : 0 , 'serial_no' : 'stretch-re1-1039' , 'stow' : { 'arm' : 0.0 , 'head_pan' : 0.0 , 'head_tilt' : 0.0 , 'lift' : 0.2 , 'stretch_gripper' : 0 , 'wrist_yaw' : 3.4 }, 'tool' : 'tool_none' , 'use_arm' : 1 , 'use_base' : 1 , 'use_end_of_arm' : 1 , 'use_head' : 1 , 'use_lift' : 1 , 'use_monitor' : 1 , 'use_pimu' : 1 , 'use_sentry' : 1 , 'use_wacc' : 1 , 'verbose' : 0 } In [ 4 ]: r . arm . params Out [ 4 ]: { 'chain_pitch' : 0.0167 , 'chain_sprocket_teeth' : 10 , 'contact_thresh_N' : [ - 80 , 80 ], 'contact_thresh_max_N' : [ - 100 , 100 ], 'force_N_per_A' : 55.9 , 'gr_spur' : 3.875 , 'homing_force_N' : [ - 60 , 80 ], 'i_feedforward' : 0 , 'motion' : { 'default' : { 'accel_m' : 0.14 , 'vel_m' : 0.14 }, 'fast' : { 'accel_m' : 0.2 , 'vel_m' : 0.25 }, 'max' : { 'accel_m' : 0.3 , 'vel_m' : 0.3 }, 'slow' : { 'accel_m' : 0.07 , 'vel_m' : 0.06 }}, 'range_m' : [ 0.0 , 0.5202755326289126 ], 'verbose' : 0 } All devices have access the global parameter set, robot_params . For example, the arm can access the lift parameters: In [ 5 ]: r . arm . robot_params [ 'lift' ] Out [ 5 ]: { 'belt_pitch_m' : 0.005 , 'contact_thresh_N' : [ - 72.45217552185059 , 65.6581787109375 ], 'contact_thresh_max_N' : [ - 100 , 100 ], 'force_N_per_A' : 75.0 , 'homing_force_N' : [ - 70 , 70 ], 'i_feedforward' : 0.75 , 'motion' : { 'default' : { 'accel_m' : 0.15 , 'vel_m' : 0.095 }, 'fast' : { 'accel_m' : 0.2 , 'vel_m' : 0.12 }, 'max' : { 'accel_m' : 0.3 , 'vel_m' : 0.15 }, 'slow' : { 'accel_m' : 0.05 , 'vel_m' : 0.05 }}, 'pinion_t' : 12 , 'range_m' : [ 0.0 , 1.0983598164609882 ], 'verbose' : 0 } You can set any of the robot_params programmatically. For example to adjust the contact sensitivity for the arm: In [ 6 ]: r . arm . params [ 'contact_thresh_N' ] Out [ 6 ]: [ - 64.46241590881348 , 66.51084520568847 ] In [ 7 ]: r . arm . params [ 'contact_thresh_N' ] = [ - 80.0 , 80.0 ] In [ 8 ]: r . arm . params [ 'contact_thresh_N' ] Out [ 8 ]: [ - 80.0 , 80.0 ] Robot Parameters All robot data is stored in the stretch_user directory. The location of this directory can be found by: $ echo $HELLO_FLEET_PATH /home/hello-robot/stretch_user The robot data stored here is identified by the robot ID (eg, stretch-re1-1002) $ cd $HELLO_FLEET_PATH / $HELLO_FLEET_ID $ ls calibration_base_imu calibration_guarded_contact calibration_steppers calibration_D435i calibration_ros export_urdf udev stretch_re1_factory_params.yaml stretch_re1_user_params.yaml stretch_re1_tool_params.yaml A factory image of this data (as shipped), is stored read-only under /etc/hello-robot . This is only for backup and to support cloning the user environment for new users. Calibration Data The raw calibration data that was used in production for the robot is also stored for reference within the stretch_user directory. It isn't generally required for development. URDF Data A calibrated URDF, and associated mesh files, are provided in the 'export_urdf' directory. This is provided for users who don't wish to use ROS yet still want an accurate model of the robot. The stretch_urdf_view.py tool demonstrates how to visualize the URDF from Python. YAML Data Stretch_Body relies upon the following three primary YAML files: File Purpose stretch_re1_factory_params.yaml Factory settings for controller gains, calibrations, and system configuration. Read only stretch_re1_user_params.yaml User parameters that override the factory parameters stretch_re1_tool_params.yaml Settings and configuration data for optional 3rd party end-of-arm tools. Factory Parameters This stretch_re1_factory_params.yaml file contains the robot's 'factory' settings. This includes things such as PID parameters for motor controllers, calibration constants, and default joint velocities and accelerations. The user should not edit this file. Hello Robot retains an 'as shipped' version of this file should it ever get corrupted. It can be instructive to review this file when getting to know the Stretch_Body code base. User Parameters The factory settings should suffice for most use cases. However, the user is allowed to override the factory settings. This is done by using same YAML structure and name as is used in the stretch_re1_user_params.yaml file as in the factory file. For example, heres the stretch_re1_user_params.yaml file is overriding the factory default contact thresholds and motion speeds. factory_params : stretch_re1_factory_params.yaml tool_params : stretch_re1_tool_params.yaml lift : contact_thresh_N : [ -60 , 60 ] motion : default : { accel_m : 0.15 , vel_m : 0.095 } arm : contact_thresh_N : [ -80 , 80 ] motion : default : { accel_m : 0.14 , vel_m : 0.14 } base : motion : default : { accel_m : 0.1 , vel_m : 0.15 } End of Arm Tool Parameters The stretch_re1_tool_params.yaml file stores configuration parameters specific to the user's custom end-of-arm-tools. It is read by the Robot class and the parameter data is made accessible to the user's end-of-arm-tool class. More information on integrating custom hardware on the End of Arm Dynamixel bus can be found at the Extending Wrist DOF Tutorial All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Parameter Management"},{"location":"stretch-body/tutorial_parameter_management/#working-with-parameters","text":"In this tutorial we will discuss how parameters are managed in Stretch Body and show examples of how to customize your robot by overriding parameters. Note : This tutorial applies to Stretch Body version 0.1.x or greater.","title":"Working With Parameters"},{"location":"stretch-body/tutorial_parameter_management/#overview","text":"Stretch Body shares a global set of parameters across all of its Python Devices. A quick way to see what parameters are available are with the stretch_params.py tool: $ stretch_params.py # ################################## Parameters for stretch-re1-1039 ###################################### Origin Parameter Value ---------------------------------------------------------------------------------------------------------- stretch_re1_factory_params.yaml param.head_pan.req_calibration 0 stretch_re1_factory_params.yaml param.head_tilt.pwm_limit 885 ... The tool display each parameter's value as well as which parameter file it was loaded from. By grepping the tool's output you can query specific settings. For example, to query contact thresholds for the arm: $ stretch_params.py | grep arm | grep contact_thresh stretch_re1_factory_params.yaml param.arm.contact_thresh_max_N [-100, 100] stretch_re1_factory_params.yaml param.arm.contact_thresh_N [-64.46241590881348, 66.51084520568847] Now if you want to override the default contact thresholds for the arm, you could add the following to your stretch_re1_user_params.yaml : arm : contact_thresh_N : [ -80.0 , 80.0 ] Run the tool again and we see: $ stretch_params.py | grep arm | grep contact_thresh stretch_re1_factory_params.yaml param.arm.contact_thresh_max_N [-100, 100] stretch_re1_factory_params.yaml param.arm.contact_thresh_N [-80, 80]","title":"Overview"},{"location":"stretch-body/tutorial_parameter_management/#data-organization","text":"Parameters' data sources may be either a Python dictionary or a YAML file. The robot's YAML files are found under $HELLO_FLEET_PATH/$HELLO_FLEET_ID . The Python dictionaries may come from any Python module on the Python path. There are three types of parameters: Factory Parameters stretch_re1_factory_params.yaml : These are common factory settings shared across RE1s as well as factory calibration data that is specific to your robot. stretch_body.robot_params.py : These are common factory settings shared across RE1s that may be automatically updated over time as new versions of Stretch Body are released. External Parameters <external_module>.params.py : These are parameters for devices outside of Stretch Body (such as the devices found in the Stretch Tool Share) User Parameters stretch_re1_user_params.yaml : These are user customizations of the robot's settings As shown below, the parameters are loaded into the robot_params dictionary in a specific order, starting with stretch_re1_factory_params.yaml . Loading of subsequent parameters overwrites earlier parameters. As such, the stretch_re1_user_params.yaml parameters can overwrite any factory parameters or external parameters. You can configure which external parameters' data sources are loaded, and their order, in your stretch_re1_user_params.yaml . For example: factory_params : stretch_re1_factory_params.yaml params : - stretch_tool_share.usbcam_wrist_v1.params - stretch_tool_share.stretch_dex_wrist_beta.params Here we see that the name of the factory parameters file is stretch_re1_factory_params.yaml . We also see that two external parameter sets will be loaded. In this example, the order of parameter precedence would be: stretch_re1_user_params.yaml stretch_tool_share.stretch_dex_wrist_beta.params.py stretch_tool_share.usbcam_wrist_v1.params.py stretch_body.robot_params.py stretch_re1_factory_params.yaml","title":"Data Organization"},{"location":"stretch-body/tutorial_parameter_management/#working-with-parameters-programmatically","text":"Stretch Body is organized as a set of classes that extend the base Device class. Each Device has access to a set of global parameters that are stored within the Device as a dictionary. These are: device.params : the parameters for the specific device device.robot_params : global set of parameters For example, let's look at the Robot class: class Robot ( Device ): def __init__ ( self ): Device . __init__ ( self , 'robot' ) ... When instantiating its Device base class it loads the robot parameters of the various YAML files and Python dictionaries. class Device : def __init__ ( self , name ): self . name = name self . user_params , self . robot_params = RobotParams . get_params () try : self . params = self . robot_params [ self . name ] except KeyError : print ( 'No device params found for %s ' % name ) self . params = {} We can explore these parameters via iPython. In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . params Out [ 3 ]: { 'batch_name' : 'Irma' , 'log_to_console' : 0 , 'serial_no' : 'stretch-re1-1039' , 'stow' : { 'arm' : 0.0 , 'head_pan' : 0.0 , 'head_tilt' : 0.0 , 'lift' : 0.2 , 'stretch_gripper' : 0 , 'wrist_yaw' : 3.4 }, 'tool' : 'tool_none' , 'use_arm' : 1 , 'use_base' : 1 , 'use_end_of_arm' : 1 , 'use_head' : 1 , 'use_lift' : 1 , 'use_monitor' : 1 , 'use_pimu' : 1 , 'use_sentry' : 1 , 'use_wacc' : 1 , 'verbose' : 0 } In [ 4 ]: r . arm . params Out [ 4 ]: { 'chain_pitch' : 0.0167 , 'chain_sprocket_teeth' : 10 , 'contact_thresh_N' : [ - 80 , 80 ], 'contact_thresh_max_N' : [ - 100 , 100 ], 'force_N_per_A' : 55.9 , 'gr_spur' : 3.875 , 'homing_force_N' : [ - 60 , 80 ], 'i_feedforward' : 0 , 'motion' : { 'default' : { 'accel_m' : 0.14 , 'vel_m' : 0.14 }, 'fast' : { 'accel_m' : 0.2 , 'vel_m' : 0.25 }, 'max' : { 'accel_m' : 0.3 , 'vel_m' : 0.3 }, 'slow' : { 'accel_m' : 0.07 , 'vel_m' : 0.06 }}, 'range_m' : [ 0.0 , 0.5202755326289126 ], 'verbose' : 0 } All devices have access the global parameter set, robot_params . For example, the arm can access the lift parameters: In [ 5 ]: r . arm . robot_params [ 'lift' ] Out [ 5 ]: { 'belt_pitch_m' : 0.005 , 'contact_thresh_N' : [ - 72.45217552185059 , 65.6581787109375 ], 'contact_thresh_max_N' : [ - 100 , 100 ], 'force_N_per_A' : 75.0 , 'homing_force_N' : [ - 70 , 70 ], 'i_feedforward' : 0.75 , 'motion' : { 'default' : { 'accel_m' : 0.15 , 'vel_m' : 0.095 }, 'fast' : { 'accel_m' : 0.2 , 'vel_m' : 0.12 }, 'max' : { 'accel_m' : 0.3 , 'vel_m' : 0.15 }, 'slow' : { 'accel_m' : 0.05 , 'vel_m' : 0.05 }}, 'pinion_t' : 12 , 'range_m' : [ 0.0 , 1.0983598164609882 ], 'verbose' : 0 } You can set any of the robot_params programmatically. For example to adjust the contact sensitivity for the arm: In [ 6 ]: r . arm . params [ 'contact_thresh_N' ] Out [ 6 ]: [ - 64.46241590881348 , 66.51084520568847 ] In [ 7 ]: r . arm . params [ 'contact_thresh_N' ] = [ - 80.0 , 80.0 ] In [ 8 ]: r . arm . params [ 'contact_thresh_N' ] Out [ 8 ]: [ - 80.0 , 80.0 ]","title":"Working with Parameters Programmatically"},{"location":"stretch-body/tutorial_parameter_management/#robot-parameters","text":"All robot data is stored in the stretch_user directory. The location of this directory can be found by: $ echo $HELLO_FLEET_PATH /home/hello-robot/stretch_user The robot data stored here is identified by the robot ID (eg, stretch-re1-1002) $ cd $HELLO_FLEET_PATH / $HELLO_FLEET_ID $ ls calibration_base_imu calibration_guarded_contact calibration_steppers calibration_D435i calibration_ros export_urdf udev stretch_re1_factory_params.yaml stretch_re1_user_params.yaml stretch_re1_tool_params.yaml A factory image of this data (as shipped), is stored read-only under /etc/hello-robot . This is only for backup and to support cloning the user environment for new users.","title":"Robot Parameters"},{"location":"stretch-body/tutorial_parameter_management/#calibration-data","text":"The raw calibration data that was used in production for the robot is also stored for reference within the stretch_user directory. It isn't generally required for development.","title":"Calibration Data"},{"location":"stretch-body/tutorial_parameter_management/#urdf-data","text":"A calibrated URDF, and associated mesh files, are provided in the 'export_urdf' directory. This is provided for users who don't wish to use ROS yet still want an accurate model of the robot. The stretch_urdf_view.py tool demonstrates how to visualize the URDF from Python.","title":"URDF Data"},{"location":"stretch-body/tutorial_parameter_management/#yaml-data","text":"Stretch_Body relies upon the following three primary YAML files: File Purpose stretch_re1_factory_params.yaml Factory settings for controller gains, calibrations, and system configuration. Read only stretch_re1_user_params.yaml User parameters that override the factory parameters stretch_re1_tool_params.yaml Settings and configuration data for optional 3rd party end-of-arm tools.","title":"YAML Data"},{"location":"stretch-body/tutorial_parameter_management/#factory-parameters","text":"This stretch_re1_factory_params.yaml file contains the robot's 'factory' settings. This includes things such as PID parameters for motor controllers, calibration constants, and default joint velocities and accelerations. The user should not edit this file. Hello Robot retains an 'as shipped' version of this file should it ever get corrupted. It can be instructive to review this file when getting to know the Stretch_Body code base.","title":"Factory Parameters"},{"location":"stretch-body/tutorial_parameter_management/#user-parameters","text":"The factory settings should suffice for most use cases. However, the user is allowed to override the factory settings. This is done by using same YAML structure and name as is used in the stretch_re1_user_params.yaml file as in the factory file. For example, heres the stretch_re1_user_params.yaml file is overriding the factory default contact thresholds and motion speeds. factory_params : stretch_re1_factory_params.yaml tool_params : stretch_re1_tool_params.yaml lift : contact_thresh_N : [ -60 , 60 ] motion : default : { accel_m : 0.15 , vel_m : 0.095 } arm : contact_thresh_N : [ -80 , 80 ] motion : default : { accel_m : 0.14 , vel_m : 0.14 } base : motion : default : { accel_m : 0.1 , vel_m : 0.15 }","title":"User Parameters"},{"location":"stretch-body/tutorial_parameter_management/#end-of-arm-tool-parameters","text":"The stretch_re1_tool_params.yaml file stores configuration parameters specific to the user's custom end-of-arm-tools. It is read by the Robot class and the parameter data is made accessible to the user's end-of-arm-tool class. More information on integrating custom hardware on the End of Arm Dynamixel bus can be found at the Extending Wrist DOF Tutorial All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"End of Arm Tool Parameters"},{"location":"stretch-body/tutorial_robot_motion/","text":"Robot Motion Controlling the motion of the robot's actuators is typically done through the ROS interfaces. However it is also possible to control the robot directly through the stretch_body interfaces. Actuators are commanded by either a move_by or move_to command (the former being incremental, the latter being absolute). For example, a relative move using the default motion parameters of the arm looks like: 1 2 3 4 5 6 7 8 9 import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . arm . move_by ( 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . stop () Motion Profiles All joints support trapezoidal based motion generation. Other types of controllers are available (PID, velocity, etc) but they are not covered here . The trapezoidal motion controllers require three values: x: target position of joint v: maximum velocity of motion a: acceleration of motion We provide 'default' settings for the velocity and acceleration settings, as well as 'fast', and 'slow' settings. These values have been tuned to be appropriate for safe motion of the robot. These values can be seen in the 'stretch_re1_factory_params.yaml'. For example: arm : motion : fast : { accel_m : 0.2 , vel_m : 0.2 } default : { accel_m : 0.14 , vel_m : 0.14 } max : { accel_m : 1.0 , vel_m : 1.0 } slow : { accel_m : 0.07 , vel_m : 0.06 } To move the arm quickly instead: vel_fast_m = robot . arm . params [ 'motion' ][ 'fast' ][ 'vel_m' ] accel_fast_m = robot . arm . params [ 'motion' ][ 'fast' ][ 'accel_m' ] robot . arm . move_by ( x_m = 0.1 , v_m = vel_fast_m , a_m = accel_fast_m ) robot . push_command () The motion will fall back to the 'default' settings found in the YAML if no parameters are provided. Range of Motion All joints obey motion limits which are specified in the factory YAML. These limits have been set at the factory to prevent damage to the hardware. It is not recommended to set them to be greater than the factory specified values. However, they can be further limited if desired. For example. to prevent the lift from descending within 100mm of the base, one can override the factory setting in stretch_re1_user_params.yaml lift : range_m : [ 0.1 , 1.095 ] Control Modes Each joint has a default safety mode and default control mode. These are: Joint Default Safety Mode Default Control Mode left_wheel Freewheel Trapezoidal position control right_wheel Freewheel Trapezoidal position control lift Gravity compensated 'float' Trapezoidal position control arm Freewheel Trapezoidal position control head_pan Torque disabled Trapezoidal position control head_tilt Torque disabled Trapezoidal position control wrist_yaw Torque disabled Trapezoidal position control stretch_gripper Torque disabled Trapezoidal position control The actuator remains in Safety Mode when no program is running. When the <device>.startup() function is called it transitions to its Control Mode. It is placed back in Safety Mode when <device>.stop() is called. In addition, the Base supports a velocity control mode. The Base controllers will automatically switch between velocity and position based control. For example: robot . base . translate_by ( x_m = 0.5 ) robot . push_command () time . sleep ( 4.0 ) #wait robot . base . set_rotational_velocity ( v_r = 0.1 ) #switch to velocity controller robot . push_command () time . sleep ( 4.0 ) #wait robot . base . set_rotational_velocity ( v_r = 0.0 ) #stop motion robot . push_command () As shown, care should be taken to reduce commanded velocities to zero to avoid runaway. Runstop Runstop activation will cause the Base, Arm, and Lift to switch to Safety Mode and for motion commands will be ignored. The motion commands will resume smoothly when the runstop is deactivated. This is usually done via the runstop button. However, it can also be done via the Pimu interface: if robot . pimu . status [ 'runstop_event' ]: robot . pimu . runstop_event_reset () robot . push_command () Guarded Motion The Arm, Lift, and Base support a guarded motion function. It will automatically transition the actuator from Control mode to Safety mode when the exerted motor torque exceeds a threshold. This functionality is most useful for the Lift and the Arm. It allows these joints to safely stop upon contact. It can be used to: Safely stop when contacting an actuator hardstop Safely stop when making unexpected contact with the environment or a person Make a guarded motion where the robot reaches to a surface and then stops Each of these tasks have different force characteristics and may require different threshold settings. The factory defaults are set so as to allow freespace motion without a payload (without triggering a false positive stop). These thresholds are set in the factory YAML. For example: arm : contact_thresh_N : [ -50 , 50 ] contact_thresh_max_N : [ -80 , 80 ] A user can dynamically set the contact thresholds depending on the task requirements. For example, to make the arm extension motion more sensitive: robot . arm . move_by ( x_m = 0.1 , contact_thresh_pos_N = 30.0 ) If too sensitive, the joint may trigger false positives (e.g., stop without contact), and different thresholds may be needed in different portions of the workspace. When a guarded motion event has occurred it is reported in the Status: if robot . arm . motor . status [ 'in_guarded_event' ]: print ( 'Arm has made contact' ) The guarded event can be reset and motion resumed by simply sending a new motion command to the joint (that is not identical to the previous command). Here is a simple example of moving to contact, then moving back: robot . arm . move_to ( 0.5 ) #Reach all the way out robot . push_command () while robot . arm . status [ 'pos' ] < 0.5 : if robot . arm . motor . status [ 'in_guarded_event' ]: print ( 'Contact made at' , robot . arm . status [ 'pos' ]) break time . sleep ( 0.1 ) print ( 'Retracting...' ) robot . arm . move_to ( 0.0 ) robot . push_command () Note: The units of Newtons are approximations only and may not be accurate to real world contact forces. Synchronized Motion The Arm, Lift, and Base actuators have a hardware synchronization mechanism. This allows for controller commands to be time synchronized across joints. By default these are turned out in the factory YAML: hello-motor-arm : gains : { enable_sync_mode : 1 , ... } Motion Status It can be useful to poll the status of a joint during motion in order to modify the robot behavior, etc. The useful status values include: robot . arm . status [ 'pos' ] #Joint position robot . arm . status [ 'vel' ] #Joint velocity robot . arm . status [ 'force' ] #Joint force (derived from motor current) robot . arm . motor . status [ 'near_pos_setpoint' ] #Is sensed position near commanded position robot . arm . motor . status [ 'near_vel_setpoint' ] #Is sensed velocity near commanded velocity robot . arm . motor . status [ 'is_moving' ] #Is the joint in motion robot . arm . motor . status [ 'in_guarded_event' ] #Has a guarded event occured robot . arm . motor . status [ 'in_safety_event' ] #Has a safety event occured Update Rates The following update rates apply to Stretch: Item Rate Notes Status data for Arm, Lift, Base, Wacc, and Pimu 25Hz Polled automatically by Robot thread Status data for End of Arm and Head servos 15Hz Polled automatically by Robot thread Command data for Arm, Lift, Base, Wacc, Pimu N/A Commands are queued and executed upon calling robot.push_command( ) Command data for End of Arm and Head servos N/A Commands execute immediately Motion commands are non-blocking and it is the responsibility of the user code to poll the Robot Status to determine when and if a motion target has been achieved. The Stretch_Body interface is not designed to support high bandwidth control applications. The natural dynamics of the robot actuators do not support high bandwidth contorl, and the USB based interface limits high rate communication. In practice, a Python based control loop that calls push_command( ) at 1Hz to 10Hz is sufficiently matched to the robot natural dynamics.","title":"Robot Motion"},{"location":"stretch-body/tutorial_robot_motion/#robot-motion","text":"Controlling the motion of the robot's actuators is typically done through the ROS interfaces. However it is also possible to control the robot directly through the stretch_body interfaces. Actuators are commanded by either a move_by or move_to command (the former being incremental, the latter being absolute). For example, a relative move using the default motion parameters of the arm looks like: 1 2 3 4 5 6 7 8 9 import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . arm . move_by ( 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . stop ()","title":"Robot Motion"},{"location":"stretch-body/tutorial_robot_motion/#motion-profiles","text":"All joints support trapezoidal based motion generation. Other types of controllers are available (PID, velocity, etc) but they are not covered here . The trapezoidal motion controllers require three values: x: target position of joint v: maximum velocity of motion a: acceleration of motion We provide 'default' settings for the velocity and acceleration settings, as well as 'fast', and 'slow' settings. These values have been tuned to be appropriate for safe motion of the robot. These values can be seen in the 'stretch_re1_factory_params.yaml'. For example: arm : motion : fast : { accel_m : 0.2 , vel_m : 0.2 } default : { accel_m : 0.14 , vel_m : 0.14 } max : { accel_m : 1.0 , vel_m : 1.0 } slow : { accel_m : 0.07 , vel_m : 0.06 } To move the arm quickly instead: vel_fast_m = robot . arm . params [ 'motion' ][ 'fast' ][ 'vel_m' ] accel_fast_m = robot . arm . params [ 'motion' ][ 'fast' ][ 'accel_m' ] robot . arm . move_by ( x_m = 0.1 , v_m = vel_fast_m , a_m = accel_fast_m ) robot . push_command () The motion will fall back to the 'default' settings found in the YAML if no parameters are provided.","title":"Motion Profiles"},{"location":"stretch-body/tutorial_robot_motion/#range-of-motion","text":"All joints obey motion limits which are specified in the factory YAML. These limits have been set at the factory to prevent damage to the hardware. It is not recommended to set them to be greater than the factory specified values. However, they can be further limited if desired. For example. to prevent the lift from descending within 100mm of the base, one can override the factory setting in stretch_re1_user_params.yaml lift : range_m : [ 0.1 , 1.095 ]","title":"Range of Motion"},{"location":"stretch-body/tutorial_robot_motion/#control-modes","text":"Each joint has a default safety mode and default control mode. These are: Joint Default Safety Mode Default Control Mode left_wheel Freewheel Trapezoidal position control right_wheel Freewheel Trapezoidal position control lift Gravity compensated 'float' Trapezoidal position control arm Freewheel Trapezoidal position control head_pan Torque disabled Trapezoidal position control head_tilt Torque disabled Trapezoidal position control wrist_yaw Torque disabled Trapezoidal position control stretch_gripper Torque disabled Trapezoidal position control The actuator remains in Safety Mode when no program is running. When the <device>.startup() function is called it transitions to its Control Mode. It is placed back in Safety Mode when <device>.stop() is called. In addition, the Base supports a velocity control mode. The Base controllers will automatically switch between velocity and position based control. For example: robot . base . translate_by ( x_m = 0.5 ) robot . push_command () time . sleep ( 4.0 ) #wait robot . base . set_rotational_velocity ( v_r = 0.1 ) #switch to velocity controller robot . push_command () time . sleep ( 4.0 ) #wait robot . base . set_rotational_velocity ( v_r = 0.0 ) #stop motion robot . push_command () As shown, care should be taken to reduce commanded velocities to zero to avoid runaway.","title":"Control Modes"},{"location":"stretch-body/tutorial_robot_motion/#runstop","text":"Runstop activation will cause the Base, Arm, and Lift to switch to Safety Mode and for motion commands will be ignored. The motion commands will resume smoothly when the runstop is deactivated. This is usually done via the runstop button. However, it can also be done via the Pimu interface: if robot . pimu . status [ 'runstop_event' ]: robot . pimu . runstop_event_reset () robot . push_command ()","title":"Runstop"},{"location":"stretch-body/tutorial_robot_motion/#guarded-motion","text":"The Arm, Lift, and Base support a guarded motion function. It will automatically transition the actuator from Control mode to Safety mode when the exerted motor torque exceeds a threshold. This functionality is most useful for the Lift and the Arm. It allows these joints to safely stop upon contact. It can be used to: Safely stop when contacting an actuator hardstop Safely stop when making unexpected contact with the environment or a person Make a guarded motion where the robot reaches to a surface and then stops Each of these tasks have different force characteristics and may require different threshold settings. The factory defaults are set so as to allow freespace motion without a payload (without triggering a false positive stop). These thresholds are set in the factory YAML. For example: arm : contact_thresh_N : [ -50 , 50 ] contact_thresh_max_N : [ -80 , 80 ] A user can dynamically set the contact thresholds depending on the task requirements. For example, to make the arm extension motion more sensitive: robot . arm . move_by ( x_m = 0.1 , contact_thresh_pos_N = 30.0 ) If too sensitive, the joint may trigger false positives (e.g., stop without contact), and different thresholds may be needed in different portions of the workspace. When a guarded motion event has occurred it is reported in the Status: if robot . arm . motor . status [ 'in_guarded_event' ]: print ( 'Arm has made contact' ) The guarded event can be reset and motion resumed by simply sending a new motion command to the joint (that is not identical to the previous command). Here is a simple example of moving to contact, then moving back: robot . arm . move_to ( 0.5 ) #Reach all the way out robot . push_command () while robot . arm . status [ 'pos' ] < 0.5 : if robot . arm . motor . status [ 'in_guarded_event' ]: print ( 'Contact made at' , robot . arm . status [ 'pos' ]) break time . sleep ( 0.1 ) print ( 'Retracting...' ) robot . arm . move_to ( 0.0 ) robot . push_command () Note: The units of Newtons are approximations only and may not be accurate to real world contact forces.","title":"Guarded Motion"},{"location":"stretch-body/tutorial_robot_motion/#synchronized-motion","text":"The Arm, Lift, and Base actuators have a hardware synchronization mechanism. This allows for controller commands to be time synchronized across joints. By default these are turned out in the factory YAML: hello-motor-arm : gains : { enable_sync_mode : 1 , ... }","title":"Synchronized Motion"},{"location":"stretch-body/tutorial_robot_motion/#motion-status","text":"It can be useful to poll the status of a joint during motion in order to modify the robot behavior, etc. The useful status values include: robot . arm . status [ 'pos' ] #Joint position robot . arm . status [ 'vel' ] #Joint velocity robot . arm . status [ 'force' ] #Joint force (derived from motor current) robot . arm . motor . status [ 'near_pos_setpoint' ] #Is sensed position near commanded position robot . arm . motor . status [ 'near_vel_setpoint' ] #Is sensed velocity near commanded velocity robot . arm . motor . status [ 'is_moving' ] #Is the joint in motion robot . arm . motor . status [ 'in_guarded_event' ] #Has a guarded event occured robot . arm . motor . status [ 'in_safety_event' ] #Has a safety event occured","title":"Motion Status"},{"location":"stretch-body/tutorial_robot_motion/#update-rates","text":"The following update rates apply to Stretch: Item Rate Notes Status data for Arm, Lift, Base, Wacc, and Pimu 25Hz Polled automatically by Robot thread Status data for End of Arm and Head servos 15Hz Polled automatically by Robot thread Command data for Arm, Lift, Base, Wacc, Pimu N/A Commands are queued and executed upon calling robot.push_command( ) Command data for End of Arm and Head servos N/A Commands execute immediately Motion commands are non-blocking and it is the responsibility of the user code to poll the Robot Status to determine when and if a motion target has been achieved. The Stretch_Body interface is not designed to support high bandwidth control applications. The natural dynamics of the robot actuators do not support high bandwidth contorl, and the USB based interface limits high rate communication. In practice, a Python based control loop that calls push_command( ) at 1Hz to 10Hz is sufficiently matched to the robot natural dynamics.","title":"Update Rates"},{"location":"stretch-body/tutorial_robot_sensors/","text":"Sensors Base IMU Coming soon. Wrist Accelerometer Coming soon. Cliff Sensors Stretch has four IR cliff sensors pointed towards the floor. These report the distance to the floor, allowing for detection of thresholds, stair edges, etc. Relevant parameters in the factory YAML are pimu : config : cliff_LPF : 10.0 cliff_thresh : -50 cliff_zero : - 523.7940936279297 - 508.10246490478517 - 496.55742706298827 - 525.149652709961 stop_at_cliff : 0 The stop_at_cliff field causes the robot to execute a Runstop when the cliff sensor readings are out of bounds. Note: As configured at the factory, stop_at_cliff is set to zero and Stretch does not stop its motion based on the cliff sensor readings. Hello Robot makes no guarantees as to the reliability of Stretch's ability to avoid driving over ledges and stairs when this flag is enabled. The sensors are calibrated such that a zero value indicates the sensor is at the correct height from the floor surface. A negative value indicates a drop off such as a stair ledge while a positive value indicates an obstacle like a threshold or high pile carpet. The calibrated range values from the sensors can be read from the robot.pimu.status message. Relevant fields are: In [ 1 ]: robot . pimu . pretty_print () ------ Pimu ----- ... At Cliff [ False , False , False , False ] Cliff Range [ 2.043212890625 , 3.710906982421875 , 1.6026611328125 , 1.95098876953125 ] Cliff Event False ... A Cliff Event flag is set when any of the four sensor readings exceed cliff_thresh and stop_at_cliff is enabled. In the event of a Cliff Event, it must be reset by robot.pimu.cliff_event_reset() in order to reset the generated Runstop. The cliff detection logic can be found in the Pimu firmware .","title":"Robot Sensors"},{"location":"stretch-body/tutorial_robot_sensors/#sensors","text":"","title":"Sensors"},{"location":"stretch-body/tutorial_robot_sensors/#base-imu","text":"Coming soon.","title":"Base IMU"},{"location":"stretch-body/tutorial_robot_sensors/#wrist-accelerometer","text":"Coming soon.","title":"Wrist Accelerometer"},{"location":"stretch-body/tutorial_robot_sensors/#cliff-sensors","text":"Stretch has four IR cliff sensors pointed towards the floor. These report the distance to the floor, allowing for detection of thresholds, stair edges, etc. Relevant parameters in the factory YAML are pimu : config : cliff_LPF : 10.0 cliff_thresh : -50 cliff_zero : - 523.7940936279297 - 508.10246490478517 - 496.55742706298827 - 525.149652709961 stop_at_cliff : 0 The stop_at_cliff field causes the robot to execute a Runstop when the cliff sensor readings are out of bounds. Note: As configured at the factory, stop_at_cliff is set to zero and Stretch does not stop its motion based on the cliff sensor readings. Hello Robot makes no guarantees as to the reliability of Stretch's ability to avoid driving over ledges and stairs when this flag is enabled. The sensors are calibrated such that a zero value indicates the sensor is at the correct height from the floor surface. A negative value indicates a drop off such as a stair ledge while a positive value indicates an obstacle like a threshold or high pile carpet. The calibrated range values from the sensors can be read from the robot.pimu.status message. Relevant fields are: In [ 1 ]: robot . pimu . pretty_print () ------ Pimu ----- ... At Cliff [ False , False , False , False ] Cliff Range [ 2.043212890625 , 3.710906982421875 , 1.6026611328125 , 1.95098876953125 ] Cliff Event False ... A Cliff Event flag is set when any of the four sensor readings exceed cliff_thresh and stop_at_cliff is enabled. In the event of a Cliff Event, it must be reset by robot.pimu.cliff_event_reset() in order to reset the generated Runstop. The cliff detection logic can be found in the Pimu firmware .","title":"Cliff Sensors"},{"location":"stretch-body/tutorial_safe_coding/","text":"Safe Operation Features Stretch includes a number of built-in functions that help it maintain safe operating conditions. These functions can be disabled and enabled via the robot YAML parameters. Logging Upon instantiation, the Robot class opens a new log file for warning and informational messages to be written to. These timestamped logs are found under $HELLO_FLEET_DIRECTORY/log. The logging messages can be echoed to the console by setting: robot : log_to_console : 1 Runstop Functions YAML Function stop_at_low_voltage Trigger runstop / beep when voltage too low stop_at_high_current Trigger runstop when bus current too high stop_at_cliff Trigger runstop when a cliff sensor is outside of range stop_at_runstop Allow runstop to disable motors stop_at_tilt Trigger runstop when robot tilts too far Robot Monitor The Robot Monitor is a thread that monitors the Robot Status data for significant events. For example, it can monitor the error flags from the Dynamixel servos and notify when a thermal overload occurs. The Robot Monitor logs warnings to a log file by default. YAML Function monitor_base_bump_event Report when the accelerometer detects a bump event monitor_base_cliff_event Report when a cliff sensor event occurs monitor_current Report when the battery current exceeds desired range monitor_dynamixel_flags Report when a Dynamixel servo enters an error state monitor_guarded_contact Report when a guarded contact event occurs monitor_over_tilt_alert Report when an over-tilt event occurs monitor_runstop Report when the runstop is activated / deactivated monitor_voltage Report when the battery voltage is out of range monitor_wrist_single_tap Report when the wrist accelerometer reports a single tap event The YAML below illustrates the types of events that are can be configured. robot : log_to_console : 0 use_monitor : 1 use_sentry : 1 robot_monitor : monitor_base_bump_event : 1 monitor_base_cliff_event : 1 monitor_current : 1 monitor_dynamixel_flags : 1 monitor_guarded_contact : 1 monitor_over_tilt_alert : 1 monitor_runstop : 1 monitor_voltage : 1 monitor_wrist_single_tap : 1 robot_sentry : base_fan_control : 1 base_max_velocity : 1 stretch_gripper_overload : 1 wrist_yaw_overload : 1 Robot Sentry The Robot Sentry is a thread that can override and also generate commands to the robot hardware. It's purpose is to keep the robot operating within a safe regime. For example, the Robot Sentry monitors the position of the Lift and Arm and limits the maximum base velocity and acceleration (in order to reduce the chance of toppling). The Robot Sentry reports events to the log file as well. YAML Function base_fan_control Turn the fan on when CPU temp exceeds range base_max_velocity Limit the base velocity when robot CG is high stretch_gripper_overload Reset commanded position to prevent thermal overload during grasp wrist_yaw_overload Reset commanded position to prevent thermal overload during pushing","title":"Safe Coding"},{"location":"stretch-body/tutorial_safe_coding/#safe-operation-features","text":"Stretch includes a number of built-in functions that help it maintain safe operating conditions. These functions can be disabled and enabled via the robot YAML parameters.","title":"Safe Operation Features"},{"location":"stretch-body/tutorial_safe_coding/#logging","text":"Upon instantiation, the Robot class opens a new log file for warning and informational messages to be written to. These timestamped logs are found under $HELLO_FLEET_DIRECTORY/log. The logging messages can be echoed to the console by setting: robot : log_to_console : 1","title":"Logging"},{"location":"stretch-body/tutorial_safe_coding/#runstop-functions","text":"YAML Function stop_at_low_voltage Trigger runstop / beep when voltage too low stop_at_high_current Trigger runstop when bus current too high stop_at_cliff Trigger runstop when a cliff sensor is outside of range stop_at_runstop Allow runstop to disable motors stop_at_tilt Trigger runstop when robot tilts too far","title":"Runstop Functions"},{"location":"stretch-body/tutorial_safe_coding/#robot-monitor","text":"The Robot Monitor is a thread that monitors the Robot Status data for significant events. For example, it can monitor the error flags from the Dynamixel servos and notify when a thermal overload occurs. The Robot Monitor logs warnings to a log file by default. YAML Function monitor_base_bump_event Report when the accelerometer detects a bump event monitor_base_cliff_event Report when a cliff sensor event occurs monitor_current Report when the battery current exceeds desired range monitor_dynamixel_flags Report when a Dynamixel servo enters an error state monitor_guarded_contact Report when a guarded contact event occurs monitor_over_tilt_alert Report when an over-tilt event occurs monitor_runstop Report when the runstop is activated / deactivated monitor_voltage Report when the battery voltage is out of range monitor_wrist_single_tap Report when the wrist accelerometer reports a single tap event The YAML below illustrates the types of events that are can be configured. robot : log_to_console : 0 use_monitor : 1 use_sentry : 1 robot_monitor : monitor_base_bump_event : 1 monitor_base_cliff_event : 1 monitor_current : 1 monitor_dynamixel_flags : 1 monitor_guarded_contact : 1 monitor_over_tilt_alert : 1 monitor_runstop : 1 monitor_voltage : 1 monitor_wrist_single_tap : 1 robot_sentry : base_fan_control : 1 base_max_velocity : 1 stretch_gripper_overload : 1 wrist_yaw_overload : 1","title":"Robot Monitor"},{"location":"stretch-body/tutorial_safe_coding/#robot-sentry","text":"The Robot Sentry is a thread that can override and also generate commands to the robot hardware. It's purpose is to keep the robot operating within a safe regime. For example, the Robot Sentry monitors the position of the Lift and Arm and limits the maximum base velocity and acceleration (in order to reduce the chance of toppling). The Robot Sentry reports events to the log file as well. YAML Function base_fan_control Turn the fan on when CPU temp exceeds range base_max_velocity Limit the base velocity when robot CG is high stretch_gripper_overload Reset commanded position to prevent thermal overload during grasp wrist_yaw_overload Reset commanded position to prevent thermal overload during pushing","title":"Robot Sentry"},{"location":"stretch-body/tutorial_splined_trajectories/","text":"Coming soon","title":"Splined Trajectories"},{"location":"stretch-body/extending_wrist_dof/","text":"Extending the Wrist DOF In this tutorial we explore how to add additional degrees of freedom to the Stretch wrist. Stretch exposes a Dynamixel X-Series TTL control bus at the end of its arm. It uses the Dynamixel XL430-W250 for the WristYaw and the StretchGripper degrees of freedom that come standard with the robot. See the Hardware User Guide to learn how to mechanically attach additional DOFs to the robot. Note: Stretch is compatible with any Dynamixel X Series servo that utilizes the TTL level Multidrop Bus. Adding a Custom DOF Adding one or more custom Dynamixel X Series servos to Stretch wrist involves: Creating a new class that derives from DynamixelHelloXL430 Adding YAML parameters to stretch_re1_tool_params.yaml that configure the servo as desired Adding YAML parameters to stretch_re1_user_params.yaml that tell Stretch to include this class in its EndOfArm list of servos Let's create a new DOF called WristPitch in a file named wrist_pitch.py . Place the file somewhere on the $PYTHONPATH. from stretch_body.dynamixel_hello_XL430 import DynamixelHelloXL430 from stretch_body.hello_utils import * class WristPitch ( DynamixelHelloXL430 ): def __init__ ( self , chain = None ): DynamixelHelloXL430 . __init__ ( self , 'wrist_pitch' , chain ) self . poses = { 'tool_up' : deg_to_rad ( 45 ), 'tool_down' : deg_to_rad ( - 45 )} def pose ( self , p , v_r = None , a_r = None ): self . move_to ( self . poses [ p ], v_r , a_r ) Now let's copy in YAML parameters for your servo to your stretch_re1_tool_params.yaml in order to configure this servo. You may want to adapt these parameters to your application but the nominal values shown usually work well. Below we highlight some of the more useful parameters. wrist_pitch : id : 1 #ID on the Dynamixel bus range_t : #Range of servo, in ticks - 0 - 4096 req_calibration : 0 #Does the joint require homing after startup use_multiturn : 0 #Single turn or multi-turn mode of rotation zero_t : 2048 #Position in ticks that corresponds to zero radians For this example we are assuming a single turn joint that doesn't require hardstop based homing. We also assume the servo has the Robotis default ID of 1. At this point your WristPitch class is ready to use. Plug the servo into the cable leaving the Stretch WristYaw joint. Experiment with the API from iPython Python 2.7.17 ( default , Apr 15 2020 , 17 : 20 : 14 ) ... In [ 1 ]: import wrist_pitch In [ 2 ]: w = wrist_pitch . WristPitch () In [ 3 ]: w . startup () In [ 4 ]: w . move_by ( 0.1 ) In [ 5 ]: w . pose ( 'tool_up' ) In [ 6 ]: w . pose ( 'tool_down' ) Finally, you'll want to make your WristPitch available from stretch_body.robot Add the following YAML to your stretch_re1_user_params.yaml end_of_arm : devices : wrist_pitch : py_class_name : WristPitch py_module_name : wrist_pitch This tells stretch_body.robot to manage a wrist_ pitch.WristPitch instance and add it to the EndOfArm list of tools. Try it from iPython: Python 2.7.17 ( default , Jul 20 2020 , 15 : 37 : 01 ) ... In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm . move_by ( 'wrist_pitch' , 0.1 ) Additional Information The DynamixelHelloXL430 Class The DynamixelHelloXL430 class is the primary interface to the Dynamixel servos of the robot. While named 'XL430' for legacy reasons, this class should be compatible with other X Series servos so long as they have compatible Control Tables (see the Dynamixel documentation). The role of DynamixelHelloXL430 is to provide a calibrated interface to the servo in radians, manage homing to hardstops, and to expose an interface to stretch_body that is consistent with the robot's other DOF. A class, such as WristYaw , derives from DynamixelHelloXL430, and extends it to include functionality that is specific to that DOF. For example, we can see in WristYaw that it provides an interface to move to predetermined poses. The DynamixelXChain Class and EndOfArm Class The DynamixelXChain class manages a set of DynamixelHelloXL430 devices for stretch_body . It also provides synchronized read access to the servos in order to reduce bus communication bottlenecks The EndOfArm class is derived from DynamixelXChain. It includes functionality that allows it to read the YAML and instantiate custom DynamixelHelloXL430 devices as shown in the example above. Setting the Servo ID By default the Dynamixel servo has an ID of 1. Each servo on a bus must have a unique ID. You can scan the bus for IDs using the RE1_dynamixel_id_scan.py tool: >>$ RE1_dynamixel_id_scan.py /dev/hello-dynamixel-wrist [ Dynamixel ID:000 ] ping Failed. [ Dynamixel ID:001 ] ping Failed. [ Dynamixel ID:002 ] ping Failed. [ Dynamixel ID:003 ] ping Succeeded. Dynamixel model number : 1060 [ Dynamixel ID:004 ] ping Succeeded. Dynamixel model number : 1020 [ Dynamixel ID:005 ] ping Succeeded. Dynamixel model number : 1020 [ Dynamixel ID:006 ] ping Succeeded. Dynamixel model number : 1060 ... Here we see that devices with IDs 3-6 are on the bus. To change the ID for device 6 to 7 for example, use RE1_dynamixel_id_change.py >> $RE1_dynamixel_id_change .py /dev/hello-dynamixel-wrist 6 7 [ Dynamixel ID:006 ] ping Succeeded. Dynamixel model number : 1060 Ready to change ID to 7 . Hit enter to continue [ Dynamixel ID:007 ] ping Succeeded. Dynamixel model number : 1060 Success at setting ID to 7 Homing a Multi-Turn Servo By default the Dynamixel servos are configured to be single-turn devices. When in single turn mode, they do not require a homing procedure on startup. Multi-turn devices, such as the Stretch WristYaw and StretchGripper, require a homing procedure. The homing procedure moves the joint to one or both mechanical limits of the joint and, based on the detected hardstops, sets the joint's 'zero' point. Your custom DynamixelHelloXL430 device may use this functionality if desired. To do so, you'll modify the following YAML fields for the device: wrist_pitch : ... pwm_homing : #Set the force that the joint approaches the hardstop - -300 - 300 range_t : #Set the mechanical range of the joint in ticks - 0 - 9340 req_calibration : 1 #Don't allow the joint to move until it has been homed use_multiturn : 1 #Enable multi-turn mode on the servo zero_t : 7175 #Mark the position in the joint range to call zero As shown above, the robot expects a mechanical range of motion of 9340 ticks (as defined in the Dynamixel documentation). Once homed, the DynamixelHelloXL430 device will report pos=0 radians when the servo is at tick 7175. In order to home the joint you can simply: import wrist_pitch w = wrist_pitch . WristPitch () w . startup () w . home ( single_stop = True , move_to_zero = True ) This will cause it to move to just the first stop (at -300 PWM), and the move to zero (eg tick 7175) when done. Finally, if your custom device is registered with EndOfArm, it will automatically home along with the other joints when calling stretch_robot_home.py .","title":"Custom Wrist DOF"},{"location":"stretch-body/extending_wrist_dof/#extending-the-wrist-dof","text":"In this tutorial we explore how to add additional degrees of freedom to the Stretch wrist. Stretch exposes a Dynamixel X-Series TTL control bus at the end of its arm. It uses the Dynamixel XL430-W250 for the WristYaw and the StretchGripper degrees of freedom that come standard with the robot. See the Hardware User Guide to learn how to mechanically attach additional DOFs to the robot. Note: Stretch is compatible with any Dynamixel X Series servo that utilizes the TTL level Multidrop Bus.","title":"Extending the Wrist DOF"},{"location":"stretch-body/extending_wrist_dof/#adding-a-custom-dof","text":"Adding one or more custom Dynamixel X Series servos to Stretch wrist involves: Creating a new class that derives from DynamixelHelloXL430 Adding YAML parameters to stretch_re1_tool_params.yaml that configure the servo as desired Adding YAML parameters to stretch_re1_user_params.yaml that tell Stretch to include this class in its EndOfArm list of servos Let's create a new DOF called WristPitch in a file named wrist_pitch.py . Place the file somewhere on the $PYTHONPATH. from stretch_body.dynamixel_hello_XL430 import DynamixelHelloXL430 from stretch_body.hello_utils import * class WristPitch ( DynamixelHelloXL430 ): def __init__ ( self , chain = None ): DynamixelHelloXL430 . __init__ ( self , 'wrist_pitch' , chain ) self . poses = { 'tool_up' : deg_to_rad ( 45 ), 'tool_down' : deg_to_rad ( - 45 )} def pose ( self , p , v_r = None , a_r = None ): self . move_to ( self . poses [ p ], v_r , a_r ) Now let's copy in YAML parameters for your servo to your stretch_re1_tool_params.yaml in order to configure this servo. You may want to adapt these parameters to your application but the nominal values shown usually work well. Below we highlight some of the more useful parameters. wrist_pitch : id : 1 #ID on the Dynamixel bus range_t : #Range of servo, in ticks - 0 - 4096 req_calibration : 0 #Does the joint require homing after startup use_multiturn : 0 #Single turn or multi-turn mode of rotation zero_t : 2048 #Position in ticks that corresponds to zero radians For this example we are assuming a single turn joint that doesn't require hardstop based homing. We also assume the servo has the Robotis default ID of 1. At this point your WristPitch class is ready to use. Plug the servo into the cable leaving the Stretch WristYaw joint. Experiment with the API from iPython Python 2.7.17 ( default , Apr 15 2020 , 17 : 20 : 14 ) ... In [ 1 ]: import wrist_pitch In [ 2 ]: w = wrist_pitch . WristPitch () In [ 3 ]: w . startup () In [ 4 ]: w . move_by ( 0.1 ) In [ 5 ]: w . pose ( 'tool_up' ) In [ 6 ]: w . pose ( 'tool_down' ) Finally, you'll want to make your WristPitch available from stretch_body.robot Add the following YAML to your stretch_re1_user_params.yaml end_of_arm : devices : wrist_pitch : py_class_name : WristPitch py_module_name : wrist_pitch This tells stretch_body.robot to manage a wrist_ pitch.WristPitch instance and add it to the EndOfArm list of tools. Try it from iPython: Python 2.7.17 ( default , Jul 20 2020 , 15 : 37 : 01 ) ... In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm . move_by ( 'wrist_pitch' , 0.1 )","title":"Adding a Custom DOF"},{"location":"stretch-body/extending_wrist_dof/#additional-information","text":"","title":"Additional Information"},{"location":"stretch-body/extending_wrist_dof/#the-dynamixelhelloxl430-class","text":"The DynamixelHelloXL430 class is the primary interface to the Dynamixel servos of the robot. While named 'XL430' for legacy reasons, this class should be compatible with other X Series servos so long as they have compatible Control Tables (see the Dynamixel documentation). The role of DynamixelHelloXL430 is to provide a calibrated interface to the servo in radians, manage homing to hardstops, and to expose an interface to stretch_body that is consistent with the robot's other DOF. A class, such as WristYaw , derives from DynamixelHelloXL430, and extends it to include functionality that is specific to that DOF. For example, we can see in WristYaw that it provides an interface to move to predetermined poses.","title":"The DynamixelHelloXL430 Class"},{"location":"stretch-body/extending_wrist_dof/#the-dynamixelxchain-class-and-endofarm-class","text":"The DynamixelXChain class manages a set of DynamixelHelloXL430 devices for stretch_body . It also provides synchronized read access to the servos in order to reduce bus communication bottlenecks The EndOfArm class is derived from DynamixelXChain. It includes functionality that allows it to read the YAML and instantiate custom DynamixelHelloXL430 devices as shown in the example above.","title":"The DynamixelXChain Class and EndOfArm Class"},{"location":"stretch-body/extending_wrist_dof/#setting-the-servo-id","text":"By default the Dynamixel servo has an ID of 1. Each servo on a bus must have a unique ID. You can scan the bus for IDs using the RE1_dynamixel_id_scan.py tool: >>$ RE1_dynamixel_id_scan.py /dev/hello-dynamixel-wrist [ Dynamixel ID:000 ] ping Failed. [ Dynamixel ID:001 ] ping Failed. [ Dynamixel ID:002 ] ping Failed. [ Dynamixel ID:003 ] ping Succeeded. Dynamixel model number : 1060 [ Dynamixel ID:004 ] ping Succeeded. Dynamixel model number : 1020 [ Dynamixel ID:005 ] ping Succeeded. Dynamixel model number : 1020 [ Dynamixel ID:006 ] ping Succeeded. Dynamixel model number : 1060 ... Here we see that devices with IDs 3-6 are on the bus. To change the ID for device 6 to 7 for example, use RE1_dynamixel_id_change.py >> $RE1_dynamixel_id_change .py /dev/hello-dynamixel-wrist 6 7 [ Dynamixel ID:006 ] ping Succeeded. Dynamixel model number : 1060 Ready to change ID to 7 . Hit enter to continue [ Dynamixel ID:007 ] ping Succeeded. Dynamixel model number : 1060 Success at setting ID to 7","title":"Setting the Servo ID"},{"location":"stretch-body/extending_wrist_dof/#homing-a-multi-turn-servo","text":"By default the Dynamixel servos are configured to be single-turn devices. When in single turn mode, they do not require a homing procedure on startup. Multi-turn devices, such as the Stretch WristYaw and StretchGripper, require a homing procedure. The homing procedure moves the joint to one or both mechanical limits of the joint and, based on the detected hardstops, sets the joint's 'zero' point. Your custom DynamixelHelloXL430 device may use this functionality if desired. To do so, you'll modify the following YAML fields for the device: wrist_pitch : ... pwm_homing : #Set the force that the joint approaches the hardstop - -300 - 300 range_t : #Set the mechanical range of the joint in ticks - 0 - 9340 req_calibration : 1 #Don't allow the joint to move until it has been homed use_multiturn : 1 #Enable multi-turn mode on the servo zero_t : 7175 #Mark the position in the joint range to call zero As shown above, the robot expects a mechanical range of motion of 9340 ticks (as defined in the Dynamixel documentation). Once homed, the DynamixelHelloXL430 device will report pos=0 radians when the servo is at tick 7175. In order to home the joint you can simply: import wrist_pitch w = wrist_pitch . WristPitch () w . startup () w . home ( single_stop = True , move_to_zero = True ) This will cause it to move to just the first stop (at -300 PWM), and the move to zero (eg tick 7175) when done. Finally, if your custom device is registered with EndOfArm, it will automatically home along with the other joints when calling stretch_robot_home.py .","title":"Homing a Multi-Turn Servo"},{"location":"stretch-body/jupyter/jupyter_getting_started/","text":"Jupyter Notebook Jupyter is a free, open-source, interactive web tool known as a computational notebook, which researchers can use to combine software code, computational output, explanatory text and multimedia resources in a single document. Launch a Jupyter Notebook App (Linux, MacOS) For Linux and MacOS systems, open a new terminal window. Enter the startup folder by typing cd /some folder name Type jupyter notebook to launch the Jupyter Notebook App. The notebook interface will appear in a new browser window or tab. Launch a Jupyter Notebook App (Windows) Double-click on the Jupyter Notebook desktop launcher (icon shows [IPy]) to start the Jupyter Notebook App. The notebook interface will appear in a new browser window or tab. A secondary terminal window (used only for error logging and for shut down) will be also opened. Executing a notebook Launch the Jupyter Notebook App (see previous section). In the Notebook Dashboard navigate to find the notebook: clicking on its name will open it in a new browser tab. Click on the menu Help -> User Interface Tour for an overview of the Jupyter Notebook App user interface. You can run the notebook document step-by-step (one cell a time) by pressing shift + enter. You can run the whole notebook in a single step by clicking on the menu Cell -> Run All. To restart the kernel (i.e. the computational engine), click on the menu Kernel -> Restart. This can be useful to start over a computation from scratch (e.g. variables are deleted, open files are closed, etc\u2026). Closing a notebook When a notebook is opened, its \u201ccomputational engine\u201d (called the kernel) is automatically started. Closing the notebook browser tab, will not shut down the kernel, instead the kernel will keep running until is explicitly shut down. To shut down a kernel, go to the associated notebook and click on menu File -> Close and Halt. Alternatively, the Notebook Dashboard has a tab named Running that shows all the running notebooks (i.e. kernels) and allows shutting them down (by clicking on a Shutdown button). Shut down the Jupyter Notebook App Closing the browser (or the tab) will not close the Jupyter Notebook App. To completely shut it down you need to close the associated terminal.","title":"Jupyter Notebook"},{"location":"stretch-body/jupyter/jupyter_getting_started/#jupyter-notebook","text":"Jupyter is a free, open-source, interactive web tool known as a computational notebook, which researchers can use to combine software code, computational output, explanatory text and multimedia resources in a single document.","title":"Jupyter Notebook"},{"location":"stretch-body/jupyter/jupyter_getting_started/#launch-a-jupyter-notebook-app-linux-macos","text":"For Linux and MacOS systems, open a new terminal window. Enter the startup folder by typing cd /some folder name Type jupyter notebook to launch the Jupyter Notebook App. The notebook interface will appear in a new browser window or tab.","title":"Launch a Jupyter Notebook App (Linux, MacOS)"},{"location":"stretch-body/jupyter/jupyter_getting_started/#launch-a-jupyter-notebook-app-windows","text":"Double-click on the Jupyter Notebook desktop launcher (icon shows [IPy]) to start the Jupyter Notebook App. The notebook interface will appear in a new browser window or tab. A secondary terminal window (used only for error logging and for shut down) will be also opened.","title":"Launch a Jupyter Notebook App (Windows)"},{"location":"stretch-body/jupyter/jupyter_getting_started/#executing-a-notebook","text":"Launch the Jupyter Notebook App (see previous section). In the Notebook Dashboard navigate to find the notebook: clicking on its name will open it in a new browser tab. Click on the menu Help -> User Interface Tour for an overview of the Jupyter Notebook App user interface. You can run the notebook document step-by-step (one cell a time) by pressing shift + enter. You can run the whole notebook in a single step by clicking on the menu Cell -> Run All. To restart the kernel (i.e. the computational engine), click on the menu Kernel -> Restart. This can be useful to start over a computation from scratch (e.g. variables are deleted, open files are closed, etc\u2026).","title":"Executing a notebook"},{"location":"stretch-body/jupyter/jupyter_getting_started/#closing-a-notebook","text":"When a notebook is opened, its \u201ccomputational engine\u201d (called the kernel) is automatically started. Closing the notebook browser tab, will not shut down the kernel, instead the kernel will keep running until is explicitly shut down. To shut down a kernel, go to the associated notebook and click on menu File -> Close and Halt. Alternatively, the Notebook Dashboard has a tab named Running that shows all the running notebooks (i.e. kernels) and allows shutting them down (by clicking on a Shutdown button).","title":"Closing a notebook"},{"location":"stretch-body/jupyter/jupyter_getting_started/#shut-down-the-jupyter-notebook-app","text":"Closing the browser (or the tab) will not close the Jupyter Notebook App. To completely shut it down you need to close the associated terminal.","title":"Shut down the Jupyter Notebook App"},{"location":"stretch-factory/","text":"Overview The Stretch Factory package provides low-level Python tools for debug, testing, and calibration of the Hello Robot Stretch RE1. These tools are provided for reference only and are intended to be used under the guidance of Hello Robot support engineers. This package can be installed by: pip install hello-robot-stretch-factory The available Stretch Factory tools can be found by tab completing after typing 'RE1_'. For example: RE1_base_calibrate_imu_collect.py RE1_dynamixel_reboot.py RE1_stepper_calibration_YAML_to_flash.py RE1_base_calibrate_imu_process.py RE1_dynamixel_set_baud.py RE1_stepper_jog.py RE1_base_calibrate_wheel_separation.py RE1_firmware_updater.py RE1_stepper_mechaduino_menu.py RE1_cliff_sensor_calibrate.py RE1_gripper_calibrate.py RE1_timestamp_manager_analyze.py RE1_clock_manager_analyze.py RE1_head_calibrate_pan.py RE1_usb_reset.py RE1_dynamixel_id_change.py RE1_hello_dynamixel_jog.py RE1_wacc_calibrate.py RE1_dynamixel_id_scan.py RE1_stepper_calibration_flash_to_YAML.py RE1_dynamixel_jog.py RE1_stepper_calibration_run.py For useage of these tools, try for example: RE1_dynamixel_id_scan.py --help","title":"Overview"},{"location":"stretch-factory/#overview","text":"The Stretch Factory package provides low-level Python tools for debug, testing, and calibration of the Hello Robot Stretch RE1. These tools are provided for reference only and are intended to be used under the guidance of Hello Robot support engineers. This package can be installed by: pip install hello-robot-stretch-factory The available Stretch Factory tools can be found by tab completing after typing 'RE1_'. For example: RE1_base_calibrate_imu_collect.py RE1_dynamixel_reboot.py RE1_stepper_calibration_YAML_to_flash.py RE1_base_calibrate_imu_process.py RE1_dynamixel_set_baud.py RE1_stepper_jog.py RE1_base_calibrate_wheel_separation.py RE1_firmware_updater.py RE1_stepper_mechaduino_menu.py RE1_cliff_sensor_calibrate.py RE1_gripper_calibrate.py RE1_timestamp_manager_analyze.py RE1_clock_manager_analyze.py RE1_head_calibrate_pan.py RE1_usb_reset.py RE1_dynamixel_id_change.py RE1_hello_dynamixel_jog.py RE1_wacc_calibrate.py RE1_dynamixel_id_scan.py RE1_stepper_calibration_flash_to_YAML.py RE1_dynamixel_jog.py RE1_stepper_calibration_run.py For useage of these tools, try for example: RE1_dynamixel_id_scan.py --help","title":"Overview"},{"location":"stretch-firmware/","text":"Overview The Stretch Firmware repository provides the Arduino based firmware for the Stretch robot. Minor version updates to Stretch Body may occasionally require the robot's firmware to also be updated. The repository includes three the firmware for the three primary Stretch PCBA types: hello_stepper: firmware for stepper motor controller based on the Mechaduino project hello_wacc: firmware for wrist accelerometer board (Wacc) in the wrist hello_pimu: firmware for power and imu board (Pimu) in the base License For details, see the LICENSE.md file in the root directory. All materials within this repository are licensed with the GNU General Public License v3.0 (GNU GPLv3) except where other third-party licenses must apply. We thank people who have contributed to this work via open-source code and open hardware. We especially thank the Mechaduino project and Tropical Labs . The motor controller firmware and hardware are derived from the excellent firmware and hardware created for the Mechaduino project by Tropical Labs.","title":"Overview"},{"location":"stretch-firmware/#overview","text":"The Stretch Firmware repository provides the Arduino based firmware for the Stretch robot. Minor version updates to Stretch Body may occasionally require the robot's firmware to also be updated. The repository includes three the firmware for the three primary Stretch PCBA types: hello_stepper: firmware for stepper motor controller based on the Mechaduino project hello_wacc: firmware for wrist accelerometer board (Wacc) in the wrist hello_pimu: firmware for power and imu board (Pimu) in the base","title":"Overview"},{"location":"stretch-firmware/#license","text":"For details, see the LICENSE.md file in the root directory. All materials within this repository are licensed with the GNU General Public License v3.0 (GNU GPLv3) except where other third-party licenses must apply. We thank people who have contributed to this work via open-source code and open hardware. We especially thank the Mechaduino project and Tropical Labs . The motor controller firmware and hardware are derived from the excellent firmware and hardware created for the Mechaduino project by Tropical Labs.","title":"License"},{"location":"stretch-firmware/tutorial_data_transfer/","text":"NOTE It is possible to brick the Wacc board by incorrectly configuring the hardware peripherals of the SAMD uC. Therefore, when integrating your custom hardware into the Wacc we strongly recommend emulating the Wacc board until the functionality is complete. The tutorial Wacc Emulation describes how to configure an Adafruit Metro M0 Express to behave as a stand-in for a Wacc board. NOTE : These tutorials may require the latest version of Stretch Body. If necessary, please update your install. Integrating Custom Data In this tutorial we explore how to plumb custom data to and from the Arduino based Stretch Wacc (Wrist + Accelerometer) board. This enables users to integrate custom sensors and actuators on to the Wrist Expansion header . How Data Transfer Happens in Stretch Body Data is transferred between Stretch Body Python and the Arduino based firmware using USB based serial. As an example, consider the transfer of a Status data message from the Wacc to Stretch Body. This involves: Stretch Body requests new Status data via wacc.pull_status() This generates an RPC call to the Wacc board The status data on the Wacc board gets 'packed' and transmitted back to Stretch Body Stretch Body unpacks the data into the status dictionary of the Wacc Python class . Similarly, data can go the other direction (e.g., Command messages ). Fortunately, the data transfer is managed automatically for the developer. In order to integrate your custom data you will: Extend the firmware Status and Command structs to include your data Derive your own class from the Stretch Body Wacc class that packs and unpacks your custom data Calculator Example As a simple example we will extend the Wacc to be an embedded calculator. The implementation is found in the Wacc_Calc Arduino sketch and the corresponding WaccCalc Python class . Arduino Define data structures First, we define the data to be sent back and forth in Common.h of the firmware. struct __attribute__ (( packed )) Calc_Command { float var1 ; float var2 ; uint8_t op ; }; struct __attribute__ (( packed )) Calc_Status { float result ; }; Our calculator will perform the computation: result=op(var1,var2) . Now add these structs to the Status and Command structs in Common.h : struct __attribute__ (( packed )) Wacc_Command { Calc_Command calc ; ... }; struct __attribute__ (( packed )) Wacc_Status { Calc_Status calc ; ... }; The ordering of the data is important. Your custom data should be at the start of the struct as the Python class will unpack this data first. Define calculator function Next we add the calculator function to Wacc.cpp : float my_calc ( uint8_t op , float var1 , float var2 ) { if ( op == 0 ) return var1 + var2 ; if ( op == 1 ) return var1 * var2 ; if ( op == 2 ) return var1 / var2 ; return 0 ; } Integrate calculator into the control loop Finally, we integrate our calculator into the embedded control loop in Wacc.cpp . The function stepWaccController() in Wacc.cpp is called by Timer5 at 700Hz. The calculator is fairly lightweight so its computation time should not interfere with the existing Wacc timing. Heavier computation would require careful integration with an eye to loop timing. Add the call to stepWaccController() -- just prior to the Status data being copied out for transmittal back. void stepWaccController () { ... stat . calc . result = my_calc ( cmd . calc . op , cmd . calc . var1 , cmd . calc . var2 ); memcpy (( uint8_t * ) ( & stat_out ),( uint8_t * ) ( & stat ), sizeof ( Wacc_Status )); } The variable cmd , which contains the command to the calculator, is automatically updated with fresh data via the RPC mechanism. Bump protocol versions The packet definition of data exchanged between Python and the Arduino is tagged with a protocol version. This allows the Python Device to ensure it is exchanging compatible data. The mainline release of Stretch Firmware starts with protocol version 0 and increments with each new protocol release. To avoid conflicts, for this tutorial we pick an arbitrary large number (99). In Common.h , we bump from Protocol '0' #define FIRMWARE_VERSION \"Wacc.v0.0.1p0\" to Protocol '99' #define FIRMWARE_VERSION \"Wacc.v0.0.1p99\" Python Now we will implement WaccCalc which derives from the Wacc Python class . from stretch_body.wacc import * from stretch_body.transport import * class WaccCalc ( Wacc ): \"\"\" This class demonstrates how to extend the Wacc class with custom data See the corresponding tutorial for more information. \"\"\" def __init__ ( self , verbose = False ): Wacc . __init__ ( self , verbose = verbose , ext_status_cb = self . ext_unpack_status , #Set callback to unpack status ext_command_cb = self . ext_pack_command ) #Set callback to pack command self . _command [ 'calc' ] = { 'op' : 0 , 'var1' : 0 , 'var2' : 0 } #Extend command dictionary with custom fields self . status [ 'calc' ] = 0.0 #Extend status dictionary with custom fields self . valid_firmware_protocol = 'pMyCalc' def calculate ( self , op , var1 , var2 ): \"\"\" 0: addition 1: multiplication 2: division \"\"\" self . _command [ 'calc' ][ 'op' ] = int ( op ) self . _command [ 'calc' ][ 'var1' ] = float ( var1 ) self . _command [ 'calc' ][ 'var2' ] = float ( var2 ) self . _dirty_command = True def pretty_print ( self ): Wacc . pretty_print ( self ) print 'Calc:' , self . status [ 'calc' ] def ext_unpack_status ( self , s ): \"\"\" s: byte array to unpack return: number of bytes unpacked \"\"\" sidx = 0 self . status [ 'calc' ] = unpack_float_t ( s [ sidx :]) return 4 def ext_pack_command ( self , s , sidx ): \"\"\" s: byte array to pack in to sidx: index to start packing at return: new sidx \"\"\" pack_float_t ( s , sidx , self . _command [ 'calc' ][ 'var1' ]) sidx += 4 pack_float_t ( s , sidx , self . _command [ 'calc' ][ 'var2' ]) sidx += 4 pack_uint8_t ( s , sidx , self . _command [ 'calc' ][ 'op' ]) sidx += 1 return sidx The class registers two callbacks for packing Command data and unpacking Status data. They are fairly self-explanatory and can be easily extended to match your custom data. Looking at the unpacking code: def ext_unpack_status ( self , s ): \"\"\" s: byte array to unpack return: number of bytes unpacked \"\"\" sidx = 0 self . status [ 'calc' ] = unpack_float_t ( s [ sidx :]) return 4 , we see the use of unpack_float_t . This, and other functions to unpack data, are found in stretch_body.transport . It is important that the data types and order match exactly those declared in the firmware. For example in Common.h we have: struct __attribute__ (( packed )) Calc_Command { float var1 ; float var2 ; uint8_t op ; }; , and on the Python side we have pack_float_t ( s , sidx , self . _command [ 'calc' ][ 'var1' ]) sidx += 4 pack_float_t ( s , sidx , self . _command [ 'calc' ][ 'var2' ]) sidx += 4 pack_uint8_t ( s , sidx , self . _command [ 'calc' ][ 'op' ]) sidx += 1 Test the Calculator - iPython We're ready to try out our calculator. First, Install and setup the Arduino IDE if it isn't already as described in the Updating Firmware tutorial . Open the Wacc_Calc Arduino sketch in the Arduino IDE. Select the hello_wacc board, the ttyACMx port that maps to the Wacc board. Then burn the firmware as described in the the Updating Firmware tutorial . Now, lets try it out: >>$ cd ~/repos/stretch_firmware/tutorial/python/ >>$ ipython And from iPython In [ 1 ]: import wacc_calc In [ 2 ]: w = wacc_calc . WaccCalc () In [ 3 ]: w . startup () In [ 4 ]: w . calculate ( op = 0 , var1 = 100.0 , var2 = 200.0 ) In [ 5 ]: w . push_command () In [ 6 ]: w . pull_status () In [ 7 ]: print 'Result is' , w . status [ 'calc' ] Result is 300.0 In [ 8 ]: w . calculate ( op = 1 , var1 = 100.0 , var2 = 200.0 ) In [ 9 ]: w . push_command () In [ 10 ]: w . pull_status () In [ 11 ]: print 'Result is' , w . status [ 'calc' ] Result is 20000.0 In [ 12 ]: w . calculate ( op = 2 , var1 = 100.0 , var2 = 200.0 ) In [ 13 ]: w . push_command () In [ 14 ]: w . pull_status () In [ 15 ]: print 'Result is' , w . status [ 'calc' ] Result is 0.5 Test the Calculator - Script Alternatively you can use the provided tool, stretch_wacc_calc_jog.py . Here you can use the calculator through the menu. hello-robot@stretch-re1-100x:~$ cd repos/stretch_firmware/tutorial/python/ hello-robot@stretch-re1-100x:~/repos/stretch_firmware/tutorial/python$ ./stretch_wacc_calc_jog.py ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation ------------------- X ---Calculate Op ( Var1,Var2 ) --- Op = 0 : Add Op = 1 : Mult Op = 2 : Div Enter Op 1 Enter Var1 12 Enter Var2 13 Adding YAML Parameters The WaccCalc class can use the Stretch Body YAML files as well. For example, add to your stretch_re1_user_params.yaml : wacc : calc_scalar : 2.0 Now let's scale the commands to the Arduino according to this YAML parameter. In WaccCalc : def calculate ( self , op , var1 , var2 ): \"\"\" 0: addition 1: multiplication 2: division \"\"\" self . _command [ 'calc' ][ 'op' ] = int ( op ) self . _command [ 'calc' ][ 'var1' ] = self . params [ 'calc_scalar' ] * float ( var1 ) self . _command [ 'calc' ][ 'var2' ] = self . params [ 'calc_scalar' ] * float ( var2 ) self . _dirty_command = True Run the iPython as above and you'll see the values multiplied by the YAML scalar. Final Steps We want the Stretch Body Robot to use WaccCalc and not Wacc . To do this, add the following to your stretch_re1_user_params.yaml : robot: custom_wacc: py_class_name: WaccCalc py_module_name: wacc_calc This tells Robot which module and class to create its Wacc instance from. Now, test that it works from iPython In [ 1 ]: import stretch_body.robot In [ 2 ]: robot = stretch_body . robot . Robot () Starting TransportConnection on : / dev / hello - wacc In [ 3 ]: robot . startup () In [ 4 ]: robot . wacc . calculate ( op = 0 , var1 = 100.0 , var2 = 200.0 ) In [ 5 ]: robot . push_command () In [ 6 ]: print 'Result' , robot . wacc . status [ 'calc' ] Result 300.0 In [ 7 ]: robot . stop ()","title":"Data Transfer"},{"location":"stretch-firmware/tutorial_data_transfer/#integrating-custom-data","text":"In this tutorial we explore how to plumb custom data to and from the Arduino based Stretch Wacc (Wrist + Accelerometer) board. This enables users to integrate custom sensors and actuators on to the Wrist Expansion header .","title":"Integrating Custom Data"},{"location":"stretch-firmware/tutorial_data_transfer/#how-data-transfer-happens-in-stretch-body","text":"Data is transferred between Stretch Body Python and the Arduino based firmware using USB based serial. As an example, consider the transfer of a Status data message from the Wacc to Stretch Body. This involves: Stretch Body requests new Status data via wacc.pull_status() This generates an RPC call to the Wacc board The status data on the Wacc board gets 'packed' and transmitted back to Stretch Body Stretch Body unpacks the data into the status dictionary of the Wacc Python class . Similarly, data can go the other direction (e.g., Command messages ). Fortunately, the data transfer is managed automatically for the developer. In order to integrate your custom data you will: Extend the firmware Status and Command structs to include your data Derive your own class from the Stretch Body Wacc class that packs and unpacks your custom data","title":"How Data Transfer Happens in Stretch Body"},{"location":"stretch-firmware/tutorial_data_transfer/#calculator-example","text":"As a simple example we will extend the Wacc to be an embedded calculator. The implementation is found in the Wacc_Calc Arduino sketch and the corresponding WaccCalc Python class .","title":"Calculator Example"},{"location":"stretch-firmware/tutorial_data_transfer/#arduino","text":"","title":"Arduino"},{"location":"stretch-firmware/tutorial_data_transfer/#define-data-structures","text":"First, we define the data to be sent back and forth in Common.h of the firmware. struct __attribute__ (( packed )) Calc_Command { float var1 ; float var2 ; uint8_t op ; }; struct __attribute__ (( packed )) Calc_Status { float result ; }; Our calculator will perform the computation: result=op(var1,var2) . Now add these structs to the Status and Command structs in Common.h : struct __attribute__ (( packed )) Wacc_Command { Calc_Command calc ; ... }; struct __attribute__ (( packed )) Wacc_Status { Calc_Status calc ; ... }; The ordering of the data is important. Your custom data should be at the start of the struct as the Python class will unpack this data first.","title":"Define data structures"},{"location":"stretch-firmware/tutorial_data_transfer/#define-calculator-function","text":"Next we add the calculator function to Wacc.cpp : float my_calc ( uint8_t op , float var1 , float var2 ) { if ( op == 0 ) return var1 + var2 ; if ( op == 1 ) return var1 * var2 ; if ( op == 2 ) return var1 / var2 ; return 0 ; }","title":"Define calculator function"},{"location":"stretch-firmware/tutorial_data_transfer/#integrate-calculator-into-the-control-loop","text":"Finally, we integrate our calculator into the embedded control loop in Wacc.cpp . The function stepWaccController() in Wacc.cpp is called by Timer5 at 700Hz. The calculator is fairly lightweight so its computation time should not interfere with the existing Wacc timing. Heavier computation would require careful integration with an eye to loop timing. Add the call to stepWaccController() -- just prior to the Status data being copied out for transmittal back. void stepWaccController () { ... stat . calc . result = my_calc ( cmd . calc . op , cmd . calc . var1 , cmd . calc . var2 ); memcpy (( uint8_t * ) ( & stat_out ),( uint8_t * ) ( & stat ), sizeof ( Wacc_Status )); } The variable cmd , which contains the command to the calculator, is automatically updated with fresh data via the RPC mechanism.","title":"Integrate calculator into the control loop"},{"location":"stretch-firmware/tutorial_data_transfer/#bump-protocol-versions","text":"The packet definition of data exchanged between Python and the Arduino is tagged with a protocol version. This allows the Python Device to ensure it is exchanging compatible data. The mainline release of Stretch Firmware starts with protocol version 0 and increments with each new protocol release. To avoid conflicts, for this tutorial we pick an arbitrary large number (99). In Common.h , we bump from Protocol '0' #define FIRMWARE_VERSION \"Wacc.v0.0.1p0\" to Protocol '99' #define FIRMWARE_VERSION \"Wacc.v0.0.1p99\"","title":"Bump protocol versions"},{"location":"stretch-firmware/tutorial_data_transfer/#python","text":"Now we will implement WaccCalc which derives from the Wacc Python class . from stretch_body.wacc import * from stretch_body.transport import * class WaccCalc ( Wacc ): \"\"\" This class demonstrates how to extend the Wacc class with custom data See the corresponding tutorial for more information. \"\"\" def __init__ ( self , verbose = False ): Wacc . __init__ ( self , verbose = verbose , ext_status_cb = self . ext_unpack_status , #Set callback to unpack status ext_command_cb = self . ext_pack_command ) #Set callback to pack command self . _command [ 'calc' ] = { 'op' : 0 , 'var1' : 0 , 'var2' : 0 } #Extend command dictionary with custom fields self . status [ 'calc' ] = 0.0 #Extend status dictionary with custom fields self . valid_firmware_protocol = 'pMyCalc' def calculate ( self , op , var1 , var2 ): \"\"\" 0: addition 1: multiplication 2: division \"\"\" self . _command [ 'calc' ][ 'op' ] = int ( op ) self . _command [ 'calc' ][ 'var1' ] = float ( var1 ) self . _command [ 'calc' ][ 'var2' ] = float ( var2 ) self . _dirty_command = True def pretty_print ( self ): Wacc . pretty_print ( self ) print 'Calc:' , self . status [ 'calc' ] def ext_unpack_status ( self , s ): \"\"\" s: byte array to unpack return: number of bytes unpacked \"\"\" sidx = 0 self . status [ 'calc' ] = unpack_float_t ( s [ sidx :]) return 4 def ext_pack_command ( self , s , sidx ): \"\"\" s: byte array to pack in to sidx: index to start packing at return: new sidx \"\"\" pack_float_t ( s , sidx , self . _command [ 'calc' ][ 'var1' ]) sidx += 4 pack_float_t ( s , sidx , self . _command [ 'calc' ][ 'var2' ]) sidx += 4 pack_uint8_t ( s , sidx , self . _command [ 'calc' ][ 'op' ]) sidx += 1 return sidx The class registers two callbacks for packing Command data and unpacking Status data. They are fairly self-explanatory and can be easily extended to match your custom data. Looking at the unpacking code: def ext_unpack_status ( self , s ): \"\"\" s: byte array to unpack return: number of bytes unpacked \"\"\" sidx = 0 self . status [ 'calc' ] = unpack_float_t ( s [ sidx :]) return 4 , we see the use of unpack_float_t . This, and other functions to unpack data, are found in stretch_body.transport . It is important that the data types and order match exactly those declared in the firmware. For example in Common.h we have: struct __attribute__ (( packed )) Calc_Command { float var1 ; float var2 ; uint8_t op ; }; , and on the Python side we have pack_float_t ( s , sidx , self . _command [ 'calc' ][ 'var1' ]) sidx += 4 pack_float_t ( s , sidx , self . _command [ 'calc' ][ 'var2' ]) sidx += 4 pack_uint8_t ( s , sidx , self . _command [ 'calc' ][ 'op' ]) sidx += 1","title":"Python"},{"location":"stretch-firmware/tutorial_data_transfer/#test-the-calculator-ipython","text":"We're ready to try out our calculator. First, Install and setup the Arduino IDE if it isn't already as described in the Updating Firmware tutorial . Open the Wacc_Calc Arduino sketch in the Arduino IDE. Select the hello_wacc board, the ttyACMx port that maps to the Wacc board. Then burn the firmware as described in the the Updating Firmware tutorial . Now, lets try it out: >>$ cd ~/repos/stretch_firmware/tutorial/python/ >>$ ipython And from iPython In [ 1 ]: import wacc_calc In [ 2 ]: w = wacc_calc . WaccCalc () In [ 3 ]: w . startup () In [ 4 ]: w . calculate ( op = 0 , var1 = 100.0 , var2 = 200.0 ) In [ 5 ]: w . push_command () In [ 6 ]: w . pull_status () In [ 7 ]: print 'Result is' , w . status [ 'calc' ] Result is 300.0 In [ 8 ]: w . calculate ( op = 1 , var1 = 100.0 , var2 = 200.0 ) In [ 9 ]: w . push_command () In [ 10 ]: w . pull_status () In [ 11 ]: print 'Result is' , w . status [ 'calc' ] Result is 20000.0 In [ 12 ]: w . calculate ( op = 2 , var1 = 100.0 , var2 = 200.0 ) In [ 13 ]: w . push_command () In [ 14 ]: w . pull_status () In [ 15 ]: print 'Result is' , w . status [ 'calc' ] Result is 0.5","title":"Test the Calculator - iPython"},{"location":"stretch-firmware/tutorial_data_transfer/#test-the-calculator-script","text":"Alternatively you can use the provided tool, stretch_wacc_calc_jog.py . Here you can use the calculator through the menu. hello-robot@stretch-re1-100x:~$ cd repos/stretch_firmware/tutorial/python/ hello-robot@stretch-re1-100x:~/repos/stretch_firmware/tutorial/python$ ./stretch_wacc_calc_jog.py ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation ------------------- X ---Calculate Op ( Var1,Var2 ) --- Op = 0 : Add Op = 1 : Mult Op = 2 : Div Enter Op 1 Enter Var1 12 Enter Var2 13","title":"Test the Calculator - Script"},{"location":"stretch-firmware/tutorial_data_transfer/#_1","text":"","title":""},{"location":"stretch-firmware/tutorial_data_transfer/#adding-yaml-parameters","text":"The WaccCalc class can use the Stretch Body YAML files as well. For example, add to your stretch_re1_user_params.yaml : wacc : calc_scalar : 2.0 Now let's scale the commands to the Arduino according to this YAML parameter. In WaccCalc : def calculate ( self , op , var1 , var2 ): \"\"\" 0: addition 1: multiplication 2: division \"\"\" self . _command [ 'calc' ][ 'op' ] = int ( op ) self . _command [ 'calc' ][ 'var1' ] = self . params [ 'calc_scalar' ] * float ( var1 ) self . _command [ 'calc' ][ 'var2' ] = self . params [ 'calc_scalar' ] * float ( var2 ) self . _dirty_command = True Run the iPython as above and you'll see the values multiplied by the YAML scalar.","title":"Adding YAML Parameters"},{"location":"stretch-firmware/tutorial_data_transfer/#final-steps","text":"We want the Stretch Body Robot to use WaccCalc and not Wacc . To do this, add the following to your stretch_re1_user_params.yaml : robot: custom_wacc: py_class_name: WaccCalc py_module_name: wacc_calc This tells Robot which module and class to create its Wacc instance from. Now, test that it works from iPython In [ 1 ]: import stretch_body.robot In [ 2 ]: robot = stretch_body . robot . Robot () Starting TransportConnection on : / dev / hello - wacc In [ 3 ]: robot . startup () In [ 4 ]: robot . wacc . calculate ( op = 0 , var1 = 100.0 , var2 = 200.0 ) In [ 5 ]: robot . push_command () In [ 6 ]: print 'Result' , robot . wacc . status [ 'calc' ] Result 300.0 In [ 7 ]: robot . stop ()","title":"Final Steps"},{"location":"stretch-firmware/tutorial_i2c_sensor/","text":"NOTE It is possible to brick the Wacc board by incorrectly configuring the hardware peripherals of the SAMD uC. Therefore, when integrating your custom hardware into the Wacc we strongly recommend emulating the Wacc board until the functionality is complete. The tutorial Wacc Emulation describes how to configure an Adafruit Metro M0 Express to behave as a stand-in for a Wacc board. NOTE : These tutorials may require the latest version of Stretch Body. If necessary, please update your install. Integrating an I2C Device This tutorial illustrates the integration of a I2C device on to the Wrist Expansion header . It extends t. We recommend doing the Data Transfer tutorial first. Calculator via I2C In this tutorial we will run the calculator from the Data Transfer tutorial on an Adafruit Metro M0 Express (Arduino Zero) that is running as an I2C slave. It will take a calculator Command from the Wacc and return the result in Status message. Flash Firmware First, program the Metro with the provided sketch, zero_wacc_i2c . Be sure to: Select the board's port from the IDE under Tools/Port Select the board 'Arduino UNO' from the IDE under Tools/Board Next, program the Wacc with the provided sketch, hello_wacc_i2c . Be sure to: Select the board's port from the IDE under Tools/Port Select the board 'Adafruit M0 Express' from the IDE under Tools/Board Code Walk-through The code is straightforward and is a natural extension of the code described in the Data Transfer tutorial. A few sections to highlight in the hello_wacc_i2c sketch are: In setupWacc() we add code to configure the I2C. Wire . begin (); In Wacc.cpp we add the I2C code: #include <Wire.h> uint8_t i2c_out [ 9 ]; //I2C data out uint8_t i2c_in [ 9 ]; //I2C data in uint8_t ds_i2c_cnt = 0 ; //Down sample counter float FS_I2C = 10 ; //Rate to run transactions (Hz) int buf_idx = 0 ; void i2cTransaction () { //Send the commmand memcpy ( i2c_out , ( uint8_t * ) ( & cmd . calc ), sizeof ( Calc_Command )); Wire . beginTransmission ( 4 ); // transmit to device #4 for ( int i = 0 ; i < sizeof ( Calc_Command ); i ++ ) { Wire . write ( i2c_out [ i ]); } Wire . endTransmission (); //Get the result Wire . requestFrom ( 4 , sizeof ( Calc_Status )); int buf_idx = 0 ; while ( Wire . available () && buf_idx < sizeof ( Calc_Status )) // loop through all but the last { uint8_t x = Wire . read (); i2c_in [ buf_idx ++ ] = x ; } memcpy (( uint8_t * ) ( & stat . calc ), i2c_in , sizeof ( Calc_Status )); } Here, the 9 bytes of the Calc_Command are transferred out and the 4 bytes of the Calc_Status are received. Note: This simple communication protocol is not robust to handshaking errors, etc Note: The Wacc uses I2C to also communicate with its onboard accelerometer -- the ADXL343 . In our example we are using I2C address 4 to communicate with our Metro slave. The ADXL343 is configured to use addrex 0xA6 for a write and 0xA7 for a read. Finally, we call the i2cTransaction() function at a rate of FS_I2C by adding to stepWaccController() : if ( ds_i2c_cnt ++ >= ( FS_CTRL / FS_I2C )) { ds_i2c_cnt = 0 ; i2cTransaction (); } Wire Up the Boards Next, wire the Metro to the Expansion Header as: Stretch Expansion Header Uno SCL SCL SDA SDA GND GND Test the Calculator Now, test the setup using the provided tool, stretch_wacc_calc_jog.py . As shown below, The Metro performs the calculation of 12*13 and the result is report back to Stretch Body. hello-robot@stretch-re1-100x:~$ cd repos/stretch_firmware/tutorial/python/ hello-robot@stretch-re1-100x:~/repos/stretch_firmware/tutorial/python$ ./stretch_wacc_calc_jog.py ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation ------------------- X ---Calculate Op ( Var1,Var2 ) --- Op = 0 : Add Op = 1 : Mult Op = 2 : Div Enter Op 1 Enter Var1 12 Enter Var2 13 ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation ------------------- ------------------------------ Ax ( m/s^2 ) 0 .0488623343408 Ay ( m/s^2 ) 0 .155020624399 Az ( m/s^2 ) -10.0049753189 A0 349 D0 ( In ) 0 D1 ( In ) 1 D2 ( Out ) 70 D3 ( Out ) 0 Single Tap Count 26 State 0 Debug 0 Timestamp 1591588745 .27 Board version: Wacc.Guthrie.V1 Firmware version: Wacc.v0.0.1pMySPI Calc: 156 .0 ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation -------------------","title":"I2C Sensor"},{"location":"stretch-firmware/tutorial_i2c_sensor/#integrating-an-i2c-device","text":"This tutorial illustrates the integration of a I2C device on to the Wrist Expansion header . It extends t. We recommend doing the Data Transfer tutorial first.","title":"Integrating an I2C Device"},{"location":"stretch-firmware/tutorial_i2c_sensor/#calculator-via-i2c","text":"In this tutorial we will run the calculator from the Data Transfer tutorial on an Adafruit Metro M0 Express (Arduino Zero) that is running as an I2C slave. It will take a calculator Command from the Wacc and return the result in Status message.","title":"Calculator via I2C"},{"location":"stretch-firmware/tutorial_i2c_sensor/#flash-firmware","text":"First, program the Metro with the provided sketch, zero_wacc_i2c . Be sure to: Select the board's port from the IDE under Tools/Port Select the board 'Arduino UNO' from the IDE under Tools/Board Next, program the Wacc with the provided sketch, hello_wacc_i2c . Be sure to: Select the board's port from the IDE under Tools/Port Select the board 'Adafruit M0 Express' from the IDE under Tools/Board","title":"Flash Firmware"},{"location":"stretch-firmware/tutorial_i2c_sensor/#code-walk-through","text":"The code is straightforward and is a natural extension of the code described in the Data Transfer tutorial. A few sections to highlight in the hello_wacc_i2c sketch are: In setupWacc() we add code to configure the I2C. Wire . begin (); In Wacc.cpp we add the I2C code: #include <Wire.h> uint8_t i2c_out [ 9 ]; //I2C data out uint8_t i2c_in [ 9 ]; //I2C data in uint8_t ds_i2c_cnt = 0 ; //Down sample counter float FS_I2C = 10 ; //Rate to run transactions (Hz) int buf_idx = 0 ; void i2cTransaction () { //Send the commmand memcpy ( i2c_out , ( uint8_t * ) ( & cmd . calc ), sizeof ( Calc_Command )); Wire . beginTransmission ( 4 ); // transmit to device #4 for ( int i = 0 ; i < sizeof ( Calc_Command ); i ++ ) { Wire . write ( i2c_out [ i ]); } Wire . endTransmission (); //Get the result Wire . requestFrom ( 4 , sizeof ( Calc_Status )); int buf_idx = 0 ; while ( Wire . available () && buf_idx < sizeof ( Calc_Status )) // loop through all but the last { uint8_t x = Wire . read (); i2c_in [ buf_idx ++ ] = x ; } memcpy (( uint8_t * ) ( & stat . calc ), i2c_in , sizeof ( Calc_Status )); } Here, the 9 bytes of the Calc_Command are transferred out and the 4 bytes of the Calc_Status are received. Note: This simple communication protocol is not robust to handshaking errors, etc Note: The Wacc uses I2C to also communicate with its onboard accelerometer -- the ADXL343 . In our example we are using I2C address 4 to communicate with our Metro slave. The ADXL343 is configured to use addrex 0xA6 for a write and 0xA7 for a read. Finally, we call the i2cTransaction() function at a rate of FS_I2C by adding to stepWaccController() : if ( ds_i2c_cnt ++ >= ( FS_CTRL / FS_I2C )) { ds_i2c_cnt = 0 ; i2cTransaction (); }","title":"Code Walk-through"},{"location":"stretch-firmware/tutorial_i2c_sensor/#wire-up-the-boards","text":"Next, wire the Metro to the Expansion Header as: Stretch Expansion Header Uno SCL SCL SDA SDA GND GND","title":"Wire Up the Boards"},{"location":"stretch-firmware/tutorial_i2c_sensor/#test-the-calculator","text":"Now, test the setup using the provided tool, stretch_wacc_calc_jog.py . As shown below, The Metro performs the calculation of 12*13 and the result is report back to Stretch Body. hello-robot@stretch-re1-100x:~$ cd repos/stretch_firmware/tutorial/python/ hello-robot@stretch-re1-100x:~/repos/stretch_firmware/tutorial/python$ ./stretch_wacc_calc_jog.py ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation ------------------- X ---Calculate Op ( Var1,Var2 ) --- Op = 0 : Add Op = 1 : Mult Op = 2 : Div Enter Op 1 Enter Var1 12 Enter Var2 13 ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation ------------------- ------------------------------ Ax ( m/s^2 ) 0 .0488623343408 Ay ( m/s^2 ) 0 .155020624399 Az ( m/s^2 ) -10.0049753189 A0 349 D0 ( In ) 0 D1 ( In ) 1 D2 ( Out ) 70 D3 ( Out ) 0 Single Tap Count 26 State 0 Debug 0 Timestamp 1591588745 .27 Board version: Wacc.Guthrie.V1 Firmware version: Wacc.v0.0.1pMySPI Calc: 156 .0 ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation -------------------","title":"Test the Calculator"},{"location":"stretch-firmware/tutorial_serial_sensor/","text":"NOTE It is possible to brick the Wacc board by incorrectly configuring the hardware peripherals of the SAMD uC. Therefore, when integrating your custom hardware into the Wacc we strongly recommend emulating the Wacc board until the functionality is complete. The tutorial Wacc Emulation describes how to configure an Adafruit Metro M0 Express to behave as a stand-in for a Wacc board. NOTE : These tutorials may require the latest version of Stretch Body. If necessary, please update your install. Integrating a Serial Device This tutorial illustrates the integration of a UART device on to the Wrist Expansion header . We recommend first reading Data Transfer tutorial to understand how data is transfered back and forth from Stretch Body to the SAMD uC. In this tutorial we will extend the Stretch Body Wacc class to send 10 floats down to the custom serial device. The serial device will echo the 10 floats back up to Stretch Body. For the purposes of the tutorial we will wire the Wacc up in a loopback configuration as a stand-in for an actual physical serial device. Loopback Hardware Setup Connect the UART TX pin to the UART RX pin of the Stretch Expansion Header (or the Metro M0 if emulating the Wacc). Connector information for the Expansion Header is found in the Hardware Guide . Flash Firmware Pull down the latest version of Stretch Firmware >>$ cd ~/repos >>$ git clone https://github.com/hello-robot/stretch_firmware Next, program the (emulated) Wacc with the provided sketch, hello_wacc_serial . Be sure to: Select the board's port from the IDE under Tools/Port Select the board 'Hello Wacc' from the IDE under Tools/Board Firmware Code Walk-through First, in the sketch setup() we configure enable the SerialExt device SerialExt . begin ( 115200 ); Next, in Common.h we define Command data to send down from Stretch Body to the serial device. We also define Status data to report back to Stretch Body. For our example we'll send 10 floats down and 10 floats back up. struct __attribute__ (( packed )) SerialExtCommand { float data [ 10 ]; }; struct __attribute__ (( packed )) SerialExtStatus { float data [ 10 ]; }; In Wacc.cpp we add the code that will communicate with the serial device. Whenever Stretch Body pushes a new command down the Wacc, this function will get called. Here we are writing the Command data to the SerialExt port. We then send back in the Status message the data we read from SerialExt. As it is a physical loopback connection, the data back in Status will be the same as the Command message. void serial_comms () { char * data_down = ( char * ) & ( cmd . serial . data [ 0 ]); char * data_up = ( char * )( stat . serial . data ); for ( int i = 0 ; i < 40 ; i ++ ) { SerialExt . write ( data_down + i , 1 ); } for ( int i = 0 ; i < 40 ; i ++ ) { if ( SerialExt . available ()) { data_up [ i ] = SerialExt . read (); } } } Stretch Body Code Walk-through We provide an example class WaccSerialExt that extends the Wacc class of Stretch Body. This class provides two call backs that will get called on pull_status and push_command respectively. Here we see the packing and unpacking of the 10 floats found in Common.h def ext_unpack_status ( self , s ): \"\"\" s: byte array to unpack return: number of bytes unpacked \"\"\" sidx = 0 for i in range ( self . n_float ): self . status [ 'serial_ext' ][ i ] = unpack_float_t ( s [ sidx :]) sidx += 4 return sidx def ext_pack_command ( self , s , sidx ): \"\"\" s: byte array to pack in to sidx: index to start packing at return: new sidx \"\"\" for i in range ( self . n_float ): pack_float_t ( s , sidx , self . _command [ 'serial_ext' ][ i ]) sidx += 4 return sidx We also define a function that generates a new 'command' down to the serial device. In this case it just increments the 10 floats by one: def serial_data_increment ( self ): for i in range ( self . n_float ): self . _command [ 'serial_ext' ][ i ] = float ( self . _command [ 'serial_ext' ][ i ] + 1 ) self . _dirty_command = True Finally, we do a simple test of the class with the tool stretch_wacc_serial_jog.py from wacc_serial_ext import WaccSerialExt w = WaccSerialExt () w . startup () try : while True : print ( 'Hit enter to do TX/RX cycle' ) raw_input () w . serial_data_increment () w . push_command () print ( 'TX to SerialExt' , w . _command [ 'serial_ext' ]) w . pull_status () print ( 'RX from SerialExt' , w . status [ 'serial_ext' ]) except ( KeyboardInterrupt , SystemExit ): w . stop () Run it from the command line and verify that the 10 floats are being command down to your serial device, through the loopback connection, and back, up to the WaccSerialExt class: >>$ cd ~/repos/stretch_firmware/tutorial/python >>$ ./stretch_wacc_serial_jog.py Hit enter to do TX/RX cycle .. ( 'TX to SerialExt' , [ 2 .0, 3 .0, 4 .0, 5 .0, 6 .0, 7 .0, 8 .0, 9 .0, 10 .0, 11 .0 ]) ( 'RX from SerialExt' , [ 1 .0, 2 .0, 3 .0, 4 .0, 5 .0, 6 .0, 7 .0, 8 .0, 9 .0, 10 .0 ]) Hit enter to do TX/RX cycle ( 'TX to SerialExt' , [ 3 .0, 4 .0, 5 .0, 6 .0, 7 .0, 8 .0, 9 .0, 10 .0, 11 .0, 12 .0 ]) ( 'RX from SerialExt' , [ 2 .0, 3 .0, 4 .0, 5 .0, 6 .0, 7 .0, 8 .0, 9 .0, 10 .0, 11 .0 ]) Hit enter to do TX/RX cycle .. NOTE: It takes one control cycle for the command values to be reported back to the status","title":"Serial Sensor"},{"location":"stretch-firmware/tutorial_serial_sensor/#integrating-a-serial-device","text":"This tutorial illustrates the integration of a UART device on to the Wrist Expansion header . We recommend first reading Data Transfer tutorial to understand how data is transfered back and forth from Stretch Body to the SAMD uC. In this tutorial we will extend the Stretch Body Wacc class to send 10 floats down to the custom serial device. The serial device will echo the 10 floats back up to Stretch Body. For the purposes of the tutorial we will wire the Wacc up in a loopback configuration as a stand-in for an actual physical serial device.","title":"Integrating a Serial Device"},{"location":"stretch-firmware/tutorial_serial_sensor/#loopback-hardware-setup","text":"Connect the UART TX pin to the UART RX pin of the Stretch Expansion Header (or the Metro M0 if emulating the Wacc). Connector information for the Expansion Header is found in the Hardware Guide .","title":"Loopback Hardware Setup"},{"location":"stretch-firmware/tutorial_serial_sensor/#flash-firmware","text":"Pull down the latest version of Stretch Firmware >>$ cd ~/repos >>$ git clone https://github.com/hello-robot/stretch_firmware Next, program the (emulated) Wacc with the provided sketch, hello_wacc_serial . Be sure to: Select the board's port from the IDE under Tools/Port Select the board 'Hello Wacc' from the IDE under Tools/Board","title":"Flash Firmware"},{"location":"stretch-firmware/tutorial_serial_sensor/#firmware-code-walk-through","text":"First, in the sketch setup() we configure enable the SerialExt device SerialExt . begin ( 115200 ); Next, in Common.h we define Command data to send down from Stretch Body to the serial device. We also define Status data to report back to Stretch Body. For our example we'll send 10 floats down and 10 floats back up. struct __attribute__ (( packed )) SerialExtCommand { float data [ 10 ]; }; struct __attribute__ (( packed )) SerialExtStatus { float data [ 10 ]; }; In Wacc.cpp we add the code that will communicate with the serial device. Whenever Stretch Body pushes a new command down the Wacc, this function will get called. Here we are writing the Command data to the SerialExt port. We then send back in the Status message the data we read from SerialExt. As it is a physical loopback connection, the data back in Status will be the same as the Command message. void serial_comms () { char * data_down = ( char * ) & ( cmd . serial . data [ 0 ]); char * data_up = ( char * )( stat . serial . data ); for ( int i = 0 ; i < 40 ; i ++ ) { SerialExt . write ( data_down + i , 1 ); } for ( int i = 0 ; i < 40 ; i ++ ) { if ( SerialExt . available ()) { data_up [ i ] = SerialExt . read (); } } }","title":"Firmware Code Walk-through"},{"location":"stretch-firmware/tutorial_serial_sensor/#stretch-body-code-walk-through","text":"We provide an example class WaccSerialExt that extends the Wacc class of Stretch Body. This class provides two call backs that will get called on pull_status and push_command respectively. Here we see the packing and unpacking of the 10 floats found in Common.h def ext_unpack_status ( self , s ): \"\"\" s: byte array to unpack return: number of bytes unpacked \"\"\" sidx = 0 for i in range ( self . n_float ): self . status [ 'serial_ext' ][ i ] = unpack_float_t ( s [ sidx :]) sidx += 4 return sidx def ext_pack_command ( self , s , sidx ): \"\"\" s: byte array to pack in to sidx: index to start packing at return: new sidx \"\"\" for i in range ( self . n_float ): pack_float_t ( s , sidx , self . _command [ 'serial_ext' ][ i ]) sidx += 4 return sidx We also define a function that generates a new 'command' down to the serial device. In this case it just increments the 10 floats by one: def serial_data_increment ( self ): for i in range ( self . n_float ): self . _command [ 'serial_ext' ][ i ] = float ( self . _command [ 'serial_ext' ][ i ] + 1 ) self . _dirty_command = True Finally, we do a simple test of the class with the tool stretch_wacc_serial_jog.py from wacc_serial_ext import WaccSerialExt w = WaccSerialExt () w . startup () try : while True : print ( 'Hit enter to do TX/RX cycle' ) raw_input () w . serial_data_increment () w . push_command () print ( 'TX to SerialExt' , w . _command [ 'serial_ext' ]) w . pull_status () print ( 'RX from SerialExt' , w . status [ 'serial_ext' ]) except ( KeyboardInterrupt , SystemExit ): w . stop () Run it from the command line and verify that the 10 floats are being command down to your serial device, through the loopback connection, and back, up to the WaccSerialExt class: >>$ cd ~/repos/stretch_firmware/tutorial/python >>$ ./stretch_wacc_serial_jog.py Hit enter to do TX/RX cycle .. ( 'TX to SerialExt' , [ 2 .0, 3 .0, 4 .0, 5 .0, 6 .0, 7 .0, 8 .0, 9 .0, 10 .0, 11 .0 ]) ( 'RX from SerialExt' , [ 1 .0, 2 .0, 3 .0, 4 .0, 5 .0, 6 .0, 7 .0, 8 .0, 9 .0, 10 .0 ]) Hit enter to do TX/RX cycle ( 'TX to SerialExt' , [ 3 .0, 4 .0, 5 .0, 6 .0, 7 .0, 8 .0, 9 .0, 10 .0, 11 .0, 12 .0 ]) ( 'RX from SerialExt' , [ 2 .0, 3 .0, 4 .0, 5 .0, 6 .0, 7 .0, 8 .0, 9 .0, 10 .0, 11 .0 ]) Hit enter to do TX/RX cycle .. NOTE: It takes one control cycle for the command values to be reported back to the status","title":"Stretch Body Code Walk-through"},{"location":"stretch-firmware/tutorial_spi_sensor/","text":"NOTE It is possible to brick the Wacc board by incorrectly configuring the hardware peripherals of the SAMD uC. Therefore, when integrating your custom hardware into the Wacc we strongly recommend emulating the Wacc board until the functionality is complete. The tutorial Wacc Emulation describes how to configure an Adafruit Metro M0 Express to behave as a stand-in for a Wacc board. NOTE : These tutorials may require the latest version of Stretch Body. If necessary, please update your install. Integrating an SPI Device This tutorial illustrates the integration of a SPI device on to the Wrist Expansion header . It extends the Data Transfer tutorial. We recommend doing this tutorial prior to doing this one. Calculator via SPI In this tutorial we will run the calculator from the Data Transfer tutorial on an Adafruit Metro M0 Express (Arduino Zero) that is running as an SPI slave. It will take a calculator Command from the Wacc and return the result in Status message. Flash Firmware First, program the Metro with the provided sketch, zero_wacc_spi . Be sure to: Select the board's port from the IDE under Tools/Port Select the board 'Adafruit M0 Express' from the IDE under Tools/Board Next, program the Wacc with the provided sketch, hello_wacc_spi . Be sure to: Select the board's port from the IDE under Tools/Port Select the board 'Hello Wacc' from the IDE under Tools/Board Code Walk-through The code is straightforward and is a natural extension of the code described in the Data Transfer tutorial. A few sections to highlight in the hello_wacc_spi sketch are: First, in the sketch setup() we configure the slave select pin to be an output pinMode ( HEADER_SPI_SS , OUTPUT ); Next in setupWacc() we add code to configure the SPI SPISettings settingsA ( 100000 , MSBFIRST , SPI_MODE1 ); SPI . begin (); SPI . beginTransaction ( settingsA ); In Wacc.cpp we add the SPI code: #include <SPI.h> uint8_t spi_out [ 9 ]; //SPI data out uint8_t spi_in [ 9 ]; //SPI data in uint8_t ds_spi_cnt = 0 ; //Down sample counter float FS_SPI = 10 ; //Rate to run transactions (Hz) void spiTransaction () { digitalWrite ( HEADER_SPI_SS , LOW ); SPI . transfer ( 'X' ); //Mark start of transaction memcpy ( spi_out , ( uint8_t * ) ( & cmd . calc ), sizeof ( Calc_Command )); for ( uint8_t idx = 0 ; idx < 9 ; idx ++ ) spi_in [ idx ] = SPI . transfer ( spi_out [ idx ]); digitalWrite ( HEADER_SPI_SS , HIGH ); memcpy (( uint8_t * ) ( & stat . calc ), spi_in + 1 , sizeof ( Calc_Status )); } Here, the 9 bytes of the Calc_Command are transferred out and the 4 bytes of the Calc_Status are received. Note: This simple communication protocol is not robust, using an 'X' to demarcate the start of a transaction Finally, we call the spiTransaction() function at a rate of FS_SPI by adding to stepWaccController() : if ( ds_spi_cnt ++ >= ( FS_CTRL / FS_SPI )) { ds_spi_cnt = 0 ; spiTransaction (); } Wire Up the Boards Next, wire the Metro to the Expansion Header as: Stretch Expansion Header Uno SS SS MISO MISO MOSI MOSI SCK SCK GND GND Note: Other Arduino boards can be used. However 5V Arduinos boards will need their SPI lines level shifted to 3V3. Test the Calculator Now, test the setup using the provided tool, stretch_wacc_calc_jog.py . As shown below, The Arduino Uno performs the calculation of 12*13 and the result is report back to Stretch Body. hello-robot@stretch-re1-100x:~$ cd repos/stretch_firmware/tutorial/python/ hello-robot@stretch-re1-100x:~/repos/stretch_firmware/tutorial/python$ ./stretch_wacc_calc_jog.py ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation ------------------- X ---Calculate Op ( Var1,Var2 ) --- Op = 0 : Add Op = 1 : Mult Op = 2 : Div Enter Op 1 Enter Var1 12 Enter Var2 13 ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation ------------------- ------------------------------ Ax ( m/s^2 ) 0 .0488623343408 Ay ( m/s^2 ) 0 .155020624399 Az ( m/s^2 ) -10.0049753189 A0 349 D0 ( In ) 0 D1 ( In ) 1 D2 ( Out ) 70 D3 ( Out ) 0 Single Tap Count 26 State 0 Debug 0 Timestamp 1591588745 .27 Board version: Wacc.Guthrie.V1 Firmware version: Wacc.v0.0.1pMySPI Calc: 156 .0 ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation -------------------","title":"SPI Sensor"},{"location":"stretch-firmware/tutorial_spi_sensor/#integrating-an-spi-device","text":"This tutorial illustrates the integration of a SPI device on to the Wrist Expansion header . It extends the Data Transfer tutorial. We recommend doing this tutorial prior to doing this one.","title":"Integrating an SPI Device"},{"location":"stretch-firmware/tutorial_spi_sensor/#calculator-via-spi","text":"In this tutorial we will run the calculator from the Data Transfer tutorial on an Adafruit Metro M0 Express (Arduino Zero) that is running as an SPI slave. It will take a calculator Command from the Wacc and return the result in Status message.","title":"Calculator via SPI"},{"location":"stretch-firmware/tutorial_spi_sensor/#flash-firmware","text":"First, program the Metro with the provided sketch, zero_wacc_spi . Be sure to: Select the board's port from the IDE under Tools/Port Select the board 'Adafruit M0 Express' from the IDE under Tools/Board Next, program the Wacc with the provided sketch, hello_wacc_spi . Be sure to: Select the board's port from the IDE under Tools/Port Select the board 'Hello Wacc' from the IDE under Tools/Board","title":"Flash Firmware"},{"location":"stretch-firmware/tutorial_spi_sensor/#code-walk-through","text":"The code is straightforward and is a natural extension of the code described in the Data Transfer tutorial. A few sections to highlight in the hello_wacc_spi sketch are: First, in the sketch setup() we configure the slave select pin to be an output pinMode ( HEADER_SPI_SS , OUTPUT ); Next in setupWacc() we add code to configure the SPI SPISettings settingsA ( 100000 , MSBFIRST , SPI_MODE1 ); SPI . begin (); SPI . beginTransaction ( settingsA ); In Wacc.cpp we add the SPI code: #include <SPI.h> uint8_t spi_out [ 9 ]; //SPI data out uint8_t spi_in [ 9 ]; //SPI data in uint8_t ds_spi_cnt = 0 ; //Down sample counter float FS_SPI = 10 ; //Rate to run transactions (Hz) void spiTransaction () { digitalWrite ( HEADER_SPI_SS , LOW ); SPI . transfer ( 'X' ); //Mark start of transaction memcpy ( spi_out , ( uint8_t * ) ( & cmd . calc ), sizeof ( Calc_Command )); for ( uint8_t idx = 0 ; idx < 9 ; idx ++ ) spi_in [ idx ] = SPI . transfer ( spi_out [ idx ]); digitalWrite ( HEADER_SPI_SS , HIGH ); memcpy (( uint8_t * ) ( & stat . calc ), spi_in + 1 , sizeof ( Calc_Status )); } Here, the 9 bytes of the Calc_Command are transferred out and the 4 bytes of the Calc_Status are received. Note: This simple communication protocol is not robust, using an 'X' to demarcate the start of a transaction Finally, we call the spiTransaction() function at a rate of FS_SPI by adding to stepWaccController() : if ( ds_spi_cnt ++ >= ( FS_CTRL / FS_SPI )) { ds_spi_cnt = 0 ; spiTransaction (); }","title":"Code Walk-through"},{"location":"stretch-firmware/tutorial_spi_sensor/#wire-up-the-boards","text":"Next, wire the Metro to the Expansion Header as: Stretch Expansion Header Uno SS SS MISO MISO MOSI MOSI SCK SCK GND GND Note: Other Arduino boards can be used. However 5V Arduinos boards will need their SPI lines level shifted to 3V3.","title":"Wire Up the Boards"},{"location":"stretch-firmware/tutorial_spi_sensor/#test-the-calculator","text":"Now, test the setup using the provided tool, stretch_wacc_calc_jog.py . As shown below, The Arduino Uno performs the calculation of 12*13 and the result is report back to Stretch Body. hello-robot@stretch-re1-100x:~$ cd repos/stretch_firmware/tutorial/python/ hello-robot@stretch-re1-100x:~/repos/stretch_firmware/tutorial/python$ ./stretch_wacc_calc_jog.py ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation ------------------- X ---Calculate Op ( Var1,Var2 ) --- Op = 0 : Add Op = 1 : Mult Op = 2 : Div Enter Op 1 Enter Var1 12 Enter Var2 13 ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation ------------------- ------------------------------ Ax ( m/s^2 ) 0 .0488623343408 Ay ( m/s^2 ) 0 .155020624399 Az ( m/s^2 ) -10.0049753189 A0 349 D0 ( In ) 0 D1 ( In ) 1 D2 ( Out ) 70 D3 ( Out ) 0 Single Tap Count 26 State 0 Debug 0 Timestamp 1591588745 .27 Board version: Wacc.Guthrie.V1 Firmware version: Wacc.v0.0.1pMySPI Calc: 156 .0 ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off X: do calculation -------------------","title":"Test the Calculator"},{"location":"stretch-firmware/tutorial_updating_firmware/","text":"Updating Stretch Firmware Stretch has 6 Arduino based microcontroller boards that may require a firmware update: Board USB Device Arduino Sketch Left wheel stepper /dev/hello-motor-left-wheel hello_stepper.ino Right wheel stepper /dev/hello-motor-right-wheel hello_stepper.ino Lift stepper /dev/hello-motor-lift hello_stepper.ino Arm stepper /dev/hello-motor-arm hello_stepper.ino Pimu /dev/hello-pimu hello_pimu.ino Wacc /dev/hello-wacc hello_wacc.ino Firmware updates are managed through the RE1_firmware_updater.py tool, which uses the Arduino Cli tool to flash the firmware. Before doing an upgrade first ensure the latest Stretch Body is installed as well as Stretch Factory >>$ pip install hello-robot-stretch-factory --upgrade --no-cache-dir >>$ pip install hello-robot-stretch-body --upgrade --no-cache-dir Firmware Update Tool The firmware update tool will automatically recommend and install latest version of firmware found on GitHub. It will only recommend versions that are compatible with the currently installed Stretch Body. Note: The firmware updater only works on Ubuntu 18.04 currently. Attempting to use the latest version of the firmware updater in Ubuntu 20.04 will error out. >>$ RE1_firmware_updater.py --help usage: RE1_firmware_updater.py [ -h ] [ --current | --available | --recommended | --install | --install_version | --install_branch | --install_path INSTALL_PATH | --mgmt ] [ --pimu ] [ --wacc ] [ --arm ] [ --lift ] [ --left_wheel ] [ --right_wheel ] Upload Stretch firmware to microcontrollers optional arguments: -h, --help show this help message and exit --current Display the currently installed firmware versions --available Display the available firmware versions --recommended Display the recommended firmware --install Install the recommended firmware --install_version Install a specific firmware version --install_branch Install the HEAD of a specific branch --install_path INSTALL_PATH Install the firmware on the provided path ( eg ./stretch_firmware/arduino ) --mgmt Display overview on firmware management --pimu Upload Pimu firmware --wacc Upload Wacc firmware --arm Upload Arm Stepper firmware --lift Upload Lift Stepper firmware --left_wheel Upload Left Wheel Stepper firmware --right_wheel Upload Right Wheel Stepper firmware Updating to the Latest Firmware To update to the latest version of firmware: ```bash $ RE1_firmware_updater.py --install Collecting information... ################################## Recommended Firmware Updates DEVICE | INSTALLED | RECOMMENDED | ACTION HELLO-WACC | Wacc.v0.0.2p1 | Wacc.v0.0.1p0 | Downgrade recommended HELLO-MOTOR-LIFT | Stepper.v0.1.0p1 | Stepper.v0.0.4p0 | Downgrade recommended HELLO-PIMU | Pimu.v0.0.2p1 | Pimu.v0.0.1p0 | Downgrade recommended HELLO-MOTOR-ARM | Stepper.v0.1.0p1 | Stepper.v0.0.4p0 | Downgrade recommended HELLO-MOTOR-LEFT-WHEEL | Stepper.v0.1.0p1 | Stepper.v0.0.4p0 | Downgrade recommended HELLO-MOTOR-RIGHT-WHEEL | Stepper.v0.1.0p1 | Stepper.v0.0.4p0 | Downgrade recommended #################################### UPDATING FIRMWARE TO... HELLO-WACC | Downgrading to Wacc.v0.0.1p0 HELLO-MOTOR-LEFT-WHEEL | Downgrading to Stepper.v0.0.4p0 HELLO-MOTOR-RIGHT-WHEEL | Downgrading to Stepper.v0.0.4p0 HELLO-MOTOR-LIFT | Downgrading to Stepper.v0.0.4p0 HELLO-PIMU | Downgrading to Pimu.v0.0.1p0 HELLO-MOTOR-ARM | Downgrading to Stepper.v0.0.4p0 WARNING: (1) Updating robot firmware should only be done by experienced users WARNING: (2) Do not have other robot processes running during update WARNING: (3) Leave robot powered on during update WARNING: (4) Ensure Lift has support clamp in place WARNING: (5) Lift may make a loud noise during programming. This is normal. Proceed with update?? [y/N]: Review the recommendations and warnings before proceeding ('y'). If you prefer to only update one or more boards you can specify it on the command line. For example: ```bash RE1_firmware_updater.py --install --arm --wacc Other Useful Commands Running RE1_firmware_updater.py --current will report the currently install firmware: >> $RE1_firmware_updater .py --current ######################################## Currently Installed Firmware ######################################## ------------ HELLO-WACC ------------ Installed Firmware: Wacc.v0.0.2p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID ------------ HELLO-MOTOR-LIFT ------------ Installed Firmware: Stepper.v0.1.0p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID ------------ HELLO-PIMU ------------ Installed Firmware: Pimu.v0.0.2p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID ------------ HELLO-MOTOR-ARM ------------ Installed Firmware: Stepper.v0.1.0p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID ------------ HELLO-MOTOR-LEFT-WHEEL ------------ Installed Firmware: Stepper.v0.1.0p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID ------------ HELLO-MOTOR-RIGHT-WHEEL ------------ Installed Firmware: Stepper.v0.1.0p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID Running RE1_firmware_updater.py --available will list the available versions on GitHub: >>$ RE1_firmware_updater.py --available Collecting information... ####################### Currently Tagged Versions of Stretch Firmware on Master Branch ####################### ---- HELLO-WACC ---- Wacc.v0.0.1p0 ---- HELLO-MOTOR-LIFT ---- Stepper.v0.0.1p0 Stepper.v0.0.2p0 Stepper.v0.0.3p0 Stepper.v0.0.4p0 ---- HELLO-PIMU ---- Pimu.v0.0.1p0 ---- HELLO-MOTOR-ARM ---- Stepper.v0.0.1p0 Stepper.v0.0.2p0 Stepper.v0.0.3p0 Stepper.v0.0.4p0 ---- HELLO-MOTOR-LEFT-WHEEL ---- Stepper.v0.0.1p0 Stepper.v0.0.2p0 Stepper.v0.0.3p0 Stepper.v0.0.4p0 ---- HELLO-MOTOR-RIGHT-WHEEL ---- Stepper.v0.0.1p0 Stepper.v0.0.2p0 Stepper.v0.0.3p0 Stepper.v0.0.4p0 Appendix: Install Arduino CLI In some cases it may be necessary to manually install the Arduino command line tool Check if the Arduino Cli tool is already installed with version 1.6.21 of the SAMD package: >>$ arduino-cli core list ID Installed Latest Name arduino:samd 1 .6.21 1 .6.21 Arduino SAMD Boards ( 32 -bits ARM Cortex-M0+ ) If not: >>$ cd ~/repos >>$ git clone https://github.com/hello-robot/stretch_install >>$ cd stretch_install/factory >>$ ./stretch_install_arduino.sh","title":"Updating Firmware"},{"location":"stretch-firmware/tutorial_updating_firmware/#updating-stretch-firmware","text":"Stretch has 6 Arduino based microcontroller boards that may require a firmware update: Board USB Device Arduino Sketch Left wheel stepper /dev/hello-motor-left-wheel hello_stepper.ino Right wheel stepper /dev/hello-motor-right-wheel hello_stepper.ino Lift stepper /dev/hello-motor-lift hello_stepper.ino Arm stepper /dev/hello-motor-arm hello_stepper.ino Pimu /dev/hello-pimu hello_pimu.ino Wacc /dev/hello-wacc hello_wacc.ino Firmware updates are managed through the RE1_firmware_updater.py tool, which uses the Arduino Cli tool to flash the firmware. Before doing an upgrade first ensure the latest Stretch Body is installed as well as Stretch Factory >>$ pip install hello-robot-stretch-factory --upgrade --no-cache-dir >>$ pip install hello-robot-stretch-body --upgrade --no-cache-dir","title":"Updating Stretch Firmware"},{"location":"stretch-firmware/tutorial_updating_firmware/#firmware-update-tool","text":"The firmware update tool will automatically recommend and install latest version of firmware found on GitHub. It will only recommend versions that are compatible with the currently installed Stretch Body. Note: The firmware updater only works on Ubuntu 18.04 currently. Attempting to use the latest version of the firmware updater in Ubuntu 20.04 will error out. >>$ RE1_firmware_updater.py --help usage: RE1_firmware_updater.py [ -h ] [ --current | --available | --recommended | --install | --install_version | --install_branch | --install_path INSTALL_PATH | --mgmt ] [ --pimu ] [ --wacc ] [ --arm ] [ --lift ] [ --left_wheel ] [ --right_wheel ] Upload Stretch firmware to microcontrollers optional arguments: -h, --help show this help message and exit --current Display the currently installed firmware versions --available Display the available firmware versions --recommended Display the recommended firmware --install Install the recommended firmware --install_version Install a specific firmware version --install_branch Install the HEAD of a specific branch --install_path INSTALL_PATH Install the firmware on the provided path ( eg ./stretch_firmware/arduino ) --mgmt Display overview on firmware management --pimu Upload Pimu firmware --wacc Upload Wacc firmware --arm Upload Arm Stepper firmware --lift Upload Lift Stepper firmware --left_wheel Upload Left Wheel Stepper firmware --right_wheel Upload Right Wheel Stepper firmware","title":"Firmware Update Tool"},{"location":"stretch-firmware/tutorial_updating_firmware/#updating-to-the-latest-firmware","text":"To update to the latest version of firmware: ```bash $ RE1_firmware_updater.py --install Collecting information...","title":"Updating to the Latest Firmware"},{"location":"stretch-firmware/tutorial_updating_firmware/#recommended-firmware-updates","text":"","title":"################################## Recommended Firmware Updates"},{"location":"stretch-firmware/tutorial_updating_firmware/#device-installed-recommended-action","text":"HELLO-WACC | Wacc.v0.0.2p1 | Wacc.v0.0.1p0 | Downgrade recommended HELLO-MOTOR-LIFT | Stepper.v0.1.0p1 | Stepper.v0.0.4p0 | Downgrade recommended HELLO-PIMU | Pimu.v0.0.2p1 | Pimu.v0.0.1p0 | Downgrade recommended HELLO-MOTOR-ARM | Stepper.v0.1.0p1 | Stepper.v0.0.4p0 | Downgrade recommended HELLO-MOTOR-LEFT-WHEEL | Stepper.v0.1.0p1 | Stepper.v0.0.4p0 | Downgrade recommended HELLO-MOTOR-RIGHT-WHEEL | Stepper.v0.1.0p1 | Stepper.v0.0.4p0 | Downgrade recommended","title":"DEVICE                    | INSTALLED                 | RECOMMENDED               | ACTION"},{"location":"stretch-firmware/tutorial_updating_firmware/#updating-firmware-to","text":"HELLO-WACC | Downgrading to Wacc.v0.0.1p0 HELLO-MOTOR-LEFT-WHEEL | Downgrading to Stepper.v0.0.4p0 HELLO-MOTOR-RIGHT-WHEEL | Downgrading to Stepper.v0.0.4p0 HELLO-MOTOR-LIFT | Downgrading to Stepper.v0.0.4p0 HELLO-PIMU | Downgrading to Pimu.v0.0.1p0 HELLO-MOTOR-ARM | Downgrading to Stepper.v0.0.4p0 WARNING: (1) Updating robot firmware should only be done by experienced users WARNING: (2) Do not have other robot processes running during update WARNING: (3) Leave robot powered on during update WARNING: (4) Ensure Lift has support clamp in place WARNING: (5) Lift may make a loud noise during programming. This is normal. Proceed with update?? [y/N]: Review the recommendations and warnings before proceeding ('y'). If you prefer to only update one or more boards you can specify it on the command line. For example: ```bash RE1_firmware_updater.py --install --arm --wacc","title":"#################################### UPDATING FIRMWARE TO..."},{"location":"stretch-firmware/tutorial_updating_firmware/#other-useful-commands","text":"Running RE1_firmware_updater.py --current will report the currently install firmware: >> $RE1_firmware_updater .py --current ######################################## Currently Installed Firmware ######################################## ------------ HELLO-WACC ------------ Installed Firmware: Wacc.v0.0.2p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID ------------ HELLO-MOTOR-LIFT ------------ Installed Firmware: Stepper.v0.1.0p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID ------------ HELLO-PIMU ------------ Installed Firmware: Pimu.v0.0.2p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID ------------ HELLO-MOTOR-ARM ------------ Installed Firmware: Stepper.v0.1.0p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID ------------ HELLO-MOTOR-LEFT-WHEEL ------------ Installed Firmware: Stepper.v0.1.0p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID ------------ HELLO-MOTOR-RIGHT-WHEEL ------------ Installed Firmware: Stepper.v0.1.0p1 Installed Stretch Body supports protocols: p0 , p1 Installed protocol p1 : VALID Running RE1_firmware_updater.py --available will list the available versions on GitHub: >>$ RE1_firmware_updater.py --available Collecting information... ####################### Currently Tagged Versions of Stretch Firmware on Master Branch ####################### ---- HELLO-WACC ---- Wacc.v0.0.1p0 ---- HELLO-MOTOR-LIFT ---- Stepper.v0.0.1p0 Stepper.v0.0.2p0 Stepper.v0.0.3p0 Stepper.v0.0.4p0 ---- HELLO-PIMU ---- Pimu.v0.0.1p0 ---- HELLO-MOTOR-ARM ---- Stepper.v0.0.1p0 Stepper.v0.0.2p0 Stepper.v0.0.3p0 Stepper.v0.0.4p0 ---- HELLO-MOTOR-LEFT-WHEEL ---- Stepper.v0.0.1p0 Stepper.v0.0.2p0 Stepper.v0.0.3p0 Stepper.v0.0.4p0 ---- HELLO-MOTOR-RIGHT-WHEEL ---- Stepper.v0.0.1p0 Stepper.v0.0.2p0 Stepper.v0.0.3p0 Stepper.v0.0.4p0","title":"Other Useful Commands"},{"location":"stretch-firmware/tutorial_updating_firmware/#appendix-install-arduino-cli","text":"In some cases it may be necessary to manually install the Arduino command line tool Check if the Arduino Cli tool is already installed with version 1.6.21 of the SAMD package: >>$ arduino-cli core list ID Installed Latest Name arduino:samd 1 .6.21 1 .6.21 Arduino SAMD Boards ( 32 -bits ARM Cortex-M0+ ) If not: >>$ cd ~/repos >>$ git clone https://github.com/hello-robot/stretch_install >>$ cd stretch_install/factory >>$ ./stretch_install_arduino.sh","title":"Appendix: Install Arduino CLI"},{"location":"stretch-firmware/tutorial_wacc_emulation/","text":"Emulating the Wacc In this tutorial we describe how to emulate the Arduino based Stretch Wacc (Wrist + Accelerometer) board using an off-the-shelf Arduino. This enables users to develop and test custom code for the Wacc board prior to deploying it to the actual robot hardware. Emulation involves: Installing the Wacc firmware on an Arduino Zero compatible board ( Adafruit Metro M0 Express ) Mapping the UDEV rules to the Metro This tutorial assumes the Metro board is plugged into one of Stretch's external USB ports. It is also possible to install Stretch Body on a developer Ubuntu machine if the robot is not available (see below). Hardware We will emulate the Wacc on the Metro board as both boards use the Atmel SAMD21G18A-AUT processor. The primary difference between the Wacc and the Metro is that the Wacc integrates an ADXL343 3 axis accelerometer on its I2C bus. As this chip isn't interfaced to our emulation hardware, this data will be missing. The Wacc also lacks the On/Off switch and RGB LED of the Metro. Only a subset of its pins of the Wacc (shown below) are used compared to the Metro. You can attach your custom hardware to the Metro as if it were the Stretch Expansion Header. Firmware First, we'll install the factory Wacc firmware on the Metro. Custom Wacc firmware could be installed using the same process. First, download the firmware repo onto the development machine if it isn't already there: >>$ cd ~/repos >>$ git clone https://github.com/hello-robot/stretch_firmware Next, install and setup the Arduino IDE has described here . Now, with the Metro M0 plugged in to a USB port on Stretch: Open the hello_wacc sketch Select Tools/Board/Hello Wacc Select the Metro board under Tools/Port Upload the firmware. The red LED on the Metro should flash at 1Hz. Note: Take care to not accidentally burn firmware to the wrong board. You can check the mapping of boards to ports by: >>$ ls -l /dev/hello* Setup UDEV Next we need for the Metro to appear as a device named /dev/hello-wacc . For this: Run 'sudo dmesg -c' to clear the system log Hit the reset button on the Metro Run 'sudo dmesg | grep Serial You'll see the Metro serial number: >>$ sudo dmesg -c | grep Serial [ 810971 .303719 ] usb 1 -3: New USB device strings: Mfr = 1 , Product = 2 , SerialNumber = 3 [ 810971 .303725 ] usb 1 -3: SerialNumber: 9261CC655150484735202020FF0C270C Copy the serial number. Edit the udev file: >>$ sudo nano /etc/udev/rules.d/95-hello-arduino.rules Find the entry for hello-wacc and update ATTRS{serial} to the new serial number. KERNEL == \"ttyACM*\" , ATTRS { idVendor }== \"2341\" , ATTRS { idProduct }== \"804d\" ,MODE: = \"0666\" , ATTRS { serial }== \"SERIAL\" , SYMLINK += \"hello-wacc\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" , where SERIAL is the serial number captured from dmesg. Now reload the udev rule >>$ sudo udevadm control --reload Now hit the reset button of the Metro and check that it is mapped: >>$ ls -l /dev/hello-wacc lrwxrwxrwx 1 root root 7 Jun 10 20 :04 /dev/hello-wacc -> ttyACM0 Note: When switching back to Stretch's internal Wacc board you'll need to restore the UDEV file. This can be done by: >>$ sudo cp $HELLO_FLEET_PATH / $HELLO_FLEET_ID /udev/95-hello-arduino.rules /etc/udev/rules.d/ Test the Emulated Wacc Now, check that your emulated Wacc is working. You should see the Timestamp and A0 values moving when you hit 'Enter'. Now you're ready to integrate your custom hardware. >>$ stretch_wacc_jog.py ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off ------------------- ------------------------------ Ax ( m/s^2 ) 0 .0 Ay ( m/s^2 ) 0 .0 Az ( m/s^2 ) 0 .0 A0 375 D0 ( In ) 1 D1 ( In ) 1 D2 ( Out ) 0 D3 ( Out ) 0 Single Tap Count 0 State 0 Debug 0 Timestamp 1591846120 .85 Board version: Wacc.Guthrie.V1 Firmware version: Wacc.v0.0.1p0","title":"Wacc Emulaton"},{"location":"stretch-firmware/tutorial_wacc_emulation/#emulating-the-wacc","text":"In this tutorial we describe how to emulate the Arduino based Stretch Wacc (Wrist + Accelerometer) board using an off-the-shelf Arduino. This enables users to develop and test custom code for the Wacc board prior to deploying it to the actual robot hardware. Emulation involves: Installing the Wacc firmware on an Arduino Zero compatible board ( Adafruit Metro M0 Express ) Mapping the UDEV rules to the Metro This tutorial assumes the Metro board is plugged into one of Stretch's external USB ports. It is also possible to install Stretch Body on a developer Ubuntu machine if the robot is not available (see below).","title":"Emulating the Wacc"},{"location":"stretch-firmware/tutorial_wacc_emulation/#hardware","text":"We will emulate the Wacc on the Metro board as both boards use the Atmel SAMD21G18A-AUT processor. The primary difference between the Wacc and the Metro is that the Wacc integrates an ADXL343 3 axis accelerometer on its I2C bus. As this chip isn't interfaced to our emulation hardware, this data will be missing. The Wacc also lacks the On/Off switch and RGB LED of the Metro. Only a subset of its pins of the Wacc (shown below) are used compared to the Metro. You can attach your custom hardware to the Metro as if it were the Stretch Expansion Header.","title":"Hardware"},{"location":"stretch-firmware/tutorial_wacc_emulation/#firmware","text":"First, we'll install the factory Wacc firmware on the Metro. Custom Wacc firmware could be installed using the same process. First, download the firmware repo onto the development machine if it isn't already there: >>$ cd ~/repos >>$ git clone https://github.com/hello-robot/stretch_firmware Next, install and setup the Arduino IDE has described here . Now, with the Metro M0 plugged in to a USB port on Stretch: Open the hello_wacc sketch Select Tools/Board/Hello Wacc Select the Metro board under Tools/Port Upload the firmware. The red LED on the Metro should flash at 1Hz. Note: Take care to not accidentally burn firmware to the wrong board. You can check the mapping of boards to ports by: >>$ ls -l /dev/hello*","title":"Firmware"},{"location":"stretch-firmware/tutorial_wacc_emulation/#setup-udev","text":"Next we need for the Metro to appear as a device named /dev/hello-wacc . For this: Run 'sudo dmesg -c' to clear the system log Hit the reset button on the Metro Run 'sudo dmesg | grep Serial You'll see the Metro serial number: >>$ sudo dmesg -c | grep Serial [ 810971 .303719 ] usb 1 -3: New USB device strings: Mfr = 1 , Product = 2 , SerialNumber = 3 [ 810971 .303725 ] usb 1 -3: SerialNumber: 9261CC655150484735202020FF0C270C Copy the serial number. Edit the udev file: >>$ sudo nano /etc/udev/rules.d/95-hello-arduino.rules Find the entry for hello-wacc and update ATTRS{serial} to the new serial number. KERNEL == \"ttyACM*\" , ATTRS { idVendor }== \"2341\" , ATTRS { idProduct }== \"804d\" ,MODE: = \"0666\" , ATTRS { serial }== \"SERIAL\" , SYMLINK += \"hello-wacc\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" , where SERIAL is the serial number captured from dmesg. Now reload the udev rule >>$ sudo udevadm control --reload Now hit the reset button of the Metro and check that it is mapped: >>$ ls -l /dev/hello-wacc lrwxrwxrwx 1 root root 7 Jun 10 20 :04 /dev/hello-wacc -> ttyACM0 Note: When switching back to Stretch's internal Wacc board you'll need to restore the UDEV file. This can be done by: >>$ sudo cp $HELLO_FLEET_PATH / $HELLO_FLEET_ID /udev/95-hello-arduino.rules /etc/udev/rules.d/","title":"Setup UDEV"},{"location":"stretch-firmware/tutorial_wacc_emulation/#test-the-emulated-wacc","text":"Now, check that your emulated Wacc is working. You should see the Timestamp and A0 values moving when you hit 'Enter'. Now you're ready to integrate your custom hardware. >>$ stretch_wacc_jog.py ------ MENU ------- m: menu r: reset board a: set D2 on b: set D2 off c: set D3 on d: set D3 off ------------------- ------------------------------ Ax ( m/s^2 ) 0 .0 Ay ( m/s^2 ) 0 .0 Az ( m/s^2 ) 0 .0 A0 375 D0 ( In ) 1 D1 ( In ) 1 D2 ( Out ) 0 D3 ( Out ) 0 Single Tap Count 0 State 0 Debug 0 Timestamp 1591846120 .85 Board version: Wacc.Guthrie.V1 Firmware version: Wacc.v0.0.1p0","title":"Test the Emulated Wacc"},{"location":"stretch-hardware-guides/","text":"Overview The stretch_body repository includes Python packages that allow a developer to interact with the hardware of the Stretch RE1 robot. These packages are: * hello-robot-stretch-body : python library to interface with Stretch RE1 * hello-robot-stretch-body-tools : useful commandline tools for using Stretch RE1 Python2 version of packages can be installed by: pip2 install -U hello-robot-stretch-body pip2 install -U hello-robot-stretch-body-tools Python3 version of packages can be installed by: pip3 install -U hello-robot-stretch-body pip3 install -U hello-robot-stretch-body-tools See docs.hello-robot.com for documentation on using Stretch RE1. In particular, see the Stretch Body User Guide for information on using these packages. Testing and Development See Stretch Body's README and Stretch Body Commandline Tool's README for information on testing/developing these packages. License Each subdirectory contains a LICENSE.md file that applies to the directory's contents. This software is intended for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. For further information including inquiries about dual licensing, please contact Hello Robot Inc.","title":"Home"},{"location":"stretch-hardware-guides/#overview","text":"The stretch_body repository includes Python packages that allow a developer to interact with the hardware of the Stretch RE1 robot. These packages are: * hello-robot-stretch-body : python library to interface with Stretch RE1 * hello-robot-stretch-body-tools : useful commandline tools for using Stretch RE1 Python2 version of packages can be installed by: pip2 install -U hello-robot-stretch-body pip2 install -U hello-robot-stretch-body-tools Python3 version of packages can be installed by: pip3 install -U hello-robot-stretch-body pip3 install -U hello-robot-stretch-body-tools See docs.hello-robot.com for documentation on using Stretch RE1. In particular, see the Stretch Body User Guide for information on using these packages.","title":"Overview"},{"location":"stretch-hardware-guides/#testing-and-development","text":"See Stretch Body's README and Stretch Body Commandline Tool's README for information on testing/developing these packages.","title":"Testing and Development"},{"location":"stretch-hardware-guides/#license","text":"Each subdirectory contains a LICENSE.md file that applies to the directory's contents. This software is intended for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. For further information including inquiries about dual licensing, please contact Hello Robot Inc.","title":"License"},{"location":"stretch-ros/","text":"Overview The stretch_ros repository holds ROS related code for the Stretch RE1 mobile manipulator from Hello Robot Inc. For an overview of the capabilities in this repository, we recommend you look at the following forum post: https://forum.hello-robot.com/t/autonomy-video-details Please be aware that the code in this repository is currently under heavy development. Resource Description hello_helpers Miscellaneous helper code used across the stretch_ros repository stretch_calibration Creates and updates calibrated URDFs for the Stretch RE1 stretch_core Enables basic use of the Stretch RE1 from ROS stretch_deep_perception Demonstrations that use open deep learning models to perceive the world stretch_demos Demonstrations of simple autonomous manipulation stretch_description Generate and export URDFs stretch_funmap Demonstrations of Fast Unified Navigation, Manipulation And Planning (FUNMAP) stretch_gazebo Support for simulation of Stretch in the Gazebo simulator stretch_moveit_config Config files to use Stretch with the MoveIt Motion Planning Framework stretch_navigation Support for the ROS navigation stack, including move_base, gmapping, and AMCL Code Status & Development Plans We intend for the following high-level summary to provide guidance about the current state of the code and planned development activities. Directory Testing Status Notes hello_helpers GOOD stretch_calibration GOOD stretch_core GOOD stretch_deep_perception GOOD stretch_demos FAIR stretch_description GOOD stretch_funmap FAIR stretch_gazebo FAIR differs from stretch_core in its underlying controllers stretch_moveit_config FAIR does not support mobile base planning in ROS 1 stretch_navigation GOOD Licenses This software is intended for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. For further information, including inquiries about dual licensing, please contact Hello Robot Inc. For license details for this repository, see the LICENSE files found in the directories. A summary of the licenses follows: Directory License hello_helpers Apache 2.0 stretch_calibration GPLv3 stretch_core Apache 2.0 stretch_deep_perception Apache 2.0 stretch_demos Apache 2.0 stretch_description BSD 3-Clause Clear License stretch_funmap LGPLv3 stretch_gazebo Apache 2.0 stretch_moveit_config Apache 2.0 stretch_navigation Apache 2.0","title":"Overview"},{"location":"stretch-ros/#overview","text":"The stretch_ros repository holds ROS related code for the Stretch RE1 mobile manipulator from Hello Robot Inc. For an overview of the capabilities in this repository, we recommend you look at the following forum post: https://forum.hello-robot.com/t/autonomy-video-details Please be aware that the code in this repository is currently under heavy development. Resource Description hello_helpers Miscellaneous helper code used across the stretch_ros repository stretch_calibration Creates and updates calibrated URDFs for the Stretch RE1 stretch_core Enables basic use of the Stretch RE1 from ROS stretch_deep_perception Demonstrations that use open deep learning models to perceive the world stretch_demos Demonstrations of simple autonomous manipulation stretch_description Generate and export URDFs stretch_funmap Demonstrations of Fast Unified Navigation, Manipulation And Planning (FUNMAP) stretch_gazebo Support for simulation of Stretch in the Gazebo simulator stretch_moveit_config Config files to use Stretch with the MoveIt Motion Planning Framework stretch_navigation Support for the ROS navigation stack, including move_base, gmapping, and AMCL","title":"Overview"},{"location":"stretch-ros/#code-status-development-plans","text":"We intend for the following high-level summary to provide guidance about the current state of the code and planned development activities. Directory Testing Status Notes hello_helpers GOOD stretch_calibration GOOD stretch_core GOOD stretch_deep_perception GOOD stretch_demos FAIR stretch_description GOOD stretch_funmap FAIR stretch_gazebo FAIR differs from stretch_core in its underlying controllers stretch_moveit_config FAIR does not support mobile base planning in ROS 1 stretch_navigation GOOD","title":"Code Status &amp; Development Plans"},{"location":"stretch-ros/#licenses","text":"This software is intended for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. For further information, including inquiries about dual licensing, please contact Hello Robot Inc. For license details for this repository, see the LICENSE files found in the directories. A summary of the licenses follows: Directory License hello_helpers Apache 2.0 stretch_calibration GPLv3 stretch_core Apache 2.0 stretch_deep_perception Apache 2.0 stretch_demos Apache 2.0 stretch_description BSD 3-Clause Clear License stretch_funmap LGPLv3 stretch_gazebo Apache 2.0 stretch_moveit_config Apache 2.0 stretch_navigation Apache 2.0","title":"Licenses"},{"location":"stretch-ros/hello_helpers/","text":"Overview hello_helpers mostly consists of the hello_helpers Python module. This module provides various Python files used across stretch_ros that have not attained sufficient status to stand on their own. Capabilities fit_plane.py : Fits planes to 3D data. hello_misc.py : Various functions, including a helpful Python object with which to create ROS nodes. hello_ros_viz.py : Various helper functions for vizualizations using RViz. Typical Usage import hello_helpers.fit_plane as fp import hello_helpers.hello_misc as hm import hello_helpers.hello_ros_viz as hr License For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"hello_helpers"},{"location":"stretch-ros/hello_helpers/#overview","text":"hello_helpers mostly consists of the hello_helpers Python module. This module provides various Python files used across stretch_ros that have not attained sufficient status to stand on their own.","title":"Overview"},{"location":"stretch-ros/hello_helpers/#capabilities","text":"fit_plane.py : Fits planes to 3D data. hello_misc.py : Various functions, including a helpful Python object with which to create ROS nodes. hello_ros_viz.py : Various helper functions for vizualizations using RViz.","title":"Capabilities"},{"location":"stretch-ros/hello_helpers/#typical-usage","text":"import hello_helpers.fit_plane as fp import hello_helpers.hello_misc as hm import hello_helpers.hello_ros_viz as hr","title":"Typical Usage"},{"location":"stretch-ros/hello_helpers/#license","text":"For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"License"},{"location":"stretch-ros/hello_helpers/LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains software for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents are licensed under the Apache License, Version 2.0 (the \"License\"). You may not use the Contents except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, the Contents are distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"stretch-ros/stretch_calibration/","text":"Overview stretch_calibration provides tools for calibrating and managing the URDF for the Stretch RE1 robot from Hello Robot Inc. The code's primary role is to generate a geometric model (i.e., a URDF) of the robot's body that corresponds well with views of the body from the robot's 3D camera (i.e., a Intel RealSense D435i). The code achieves this objective by adjusting the geometry of the model to predict where the 3D camera will see markers (i.e., ArUco markers) on the robot's body. Hello Robot Inc. uses this code to calibrate each robot prior to shipping. Users may wish to recalibrate their robots to compensate for changes over time or take advantage of improvements to the calibration code. In addition, after changing a tool, this code can be used to generate a new calibrated URDF that incorporates the tool without performing a new calibration optimization. Checking the Current Calibration with New Observations Make sure the basic joint limit calibration has been performed. stretch_robot_home.py Make sure the uncalibrated URDF is up to date. rosrun stretch_calibration update_uncalibrated_urdf.sh Collect new observations roslaunch stretch_calibration collect_check_head_calibration_data.launch Test how well the current calibrated model fits the new observations rosrun stretch_calibration check_head_calibration.sh The total_error printed on the command line should be less than 0.05. If it is not, an error will be printed on the command line. In RViz the white markers represent the locations for the ArUco markers predicted by the calibrated URDF. The colored markers represent the observed locations of the ArUco markers on the robot's body. For a good fit, the white markers will be close to the colored markers. Visually Inspecting the Current Calibration The following command will allow you to visually inspect a calibration with Rviz. You can use RViz to see how well the robot's 3D body model matches point clouds from the 3D camera. While visualizing the 3D model and point clouds in RViz, you can use keyboard commands in the terminal to move the head around, the lift up and down, and the arm in and out. The keyboard commands will be printed in the terminal. A good calibration should result in a close correspondence between the robot's 3D body model and the point cloud throughout the ranges of motion for the head, lift, and arm. You may notice higher error when the head is looking upward due to challenges associated with head tilt backlash. You might also notice higher error when the arm is fully extended, since small angular errors can result in larger positional errors at the robot's wrist. Test the current head calibration roslaunch stretch_calibration simple_test_head_calibration.launch Examples of Good and Bad Visual Fit In the images below, examples of good and bad fit between the point cloud and the geometric model are presented side by side. To make the distinction clear, the images have green and red circles indicating where the fit is either good or bad. Calibrate the Stretch RE1 Make sure the basic joint limit calibration has been performed. stretch_robot_home.py Make sure the uncalibrated URDF is up to date. rosrun stretch_calibration update_uncalibrated_urdf.sh Collect head calibration data Put the robot on a flat surface. Give it room to move its arm and good lighting. Then, have the robot collect data using the command below. While the robot is collecting data, do not block its view of its markers. roslaunch stretch_calibration collect_head_calibration_data.launch Process head calibration data Specify how much data to use and the quality of the fit YAML file with parameters: stretch_ros/stretch_calibration/config/head_calibration_options.yaml More data and higher quality fitting result in optimizations that take longer When quickly testing things out ~3 minutes without visualization data_to_use: use_very_little_data fit_quality: fastest_lowest_quality When calibrating the robot ~1 hour without visualization data_to_use: use_all_data fit_quality: slow_high_quality Perform the optimization to fit the model to the collected data Without visualization (faster) roslaunch stretch_calibration process_head_calibration_data.launch With visualization (slower) roslaunch stretch_calibration process_head_calibration_data_with_visualization.launch Inspect the fit of the most recent head calibration rosrun stretch_calibration visualize_most_recent_head_calibration.sh Start using the newest head calibration rosrun stretch_calibration update_with_most_recent_calibration.sh Test the current head calibration roslaunch stretch_calibration simple_test_head_calibration.launch Use RViz to visually inspect the calibrated model. The robot's 3D body model should look similar to the structure of your robot. You may refer to the section above to see examples of good and bad fit. Generate a New URDF After Changing the Tool If you change the Stretch RE1's tool attached to the wrist and want to generate a new URDF for it, you can do so with xacro files in the /stretch_ros/stretch_description/urdf/ directory. Specifically, you can edit stretch_description.xacro to include a xacro other than the default stretch_gripper.xacro. After changing the tool xacro you will need to generate a new URDF and also update this new URDF with the previously optimized calibration parameters. To do so, follow the directions below: In a terminal start roscore. This will enable the main script to proceed and terminate without pressing Ctrl-C. roscore Next, in a different terminal terminal run rosrun stretch_calibration update_urdf_after_xacro_change.sh This will update the uncalibrated URDF with the current xacro files and then create a calibrated URDF using the most recent calibration parameters. Revert to a Previous Calibration When a new calibration is performed, it is timestamped and added to the calibration directory under \"stretch_user/\". If you'd like to revert to a previous calibration, you may run the following command. It will move the most recent calibration files to a reversion directory and update the calibration in the stretch_description package from the remaining most recent calibration files. Revert to the previous head calibration rosrun stretch_calibration revert_to_previous_calibration.sh License stretch_calibration is licensed with the GPLv3. Please see the LICENSE file for details. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"stretch_calibration"},{"location":"stretch-ros/stretch_calibration/#overview","text":"stretch_calibration provides tools for calibrating and managing the URDF for the Stretch RE1 robot from Hello Robot Inc. The code's primary role is to generate a geometric model (i.e., a URDF) of the robot's body that corresponds well with views of the body from the robot's 3D camera (i.e., a Intel RealSense D435i). The code achieves this objective by adjusting the geometry of the model to predict where the 3D camera will see markers (i.e., ArUco markers) on the robot's body. Hello Robot Inc. uses this code to calibrate each robot prior to shipping. Users may wish to recalibrate their robots to compensate for changes over time or take advantage of improvements to the calibration code. In addition, after changing a tool, this code can be used to generate a new calibrated URDF that incorporates the tool without performing a new calibration optimization.","title":"Overview"},{"location":"stretch-ros/stretch_calibration/#checking-the-current-calibration-with-new-observations","text":"Make sure the basic joint limit calibration has been performed. stretch_robot_home.py Make sure the uncalibrated URDF is up to date. rosrun stretch_calibration update_uncalibrated_urdf.sh Collect new observations roslaunch stretch_calibration collect_check_head_calibration_data.launch Test how well the current calibrated model fits the new observations rosrun stretch_calibration check_head_calibration.sh The total_error printed on the command line should be less than 0.05. If it is not, an error will be printed on the command line. In RViz the white markers represent the locations for the ArUco markers predicted by the calibrated URDF. The colored markers represent the observed locations of the ArUco markers on the robot's body. For a good fit, the white markers will be close to the colored markers.","title":"Checking the Current Calibration with New Observations"},{"location":"stretch-ros/stretch_calibration/#visually-inspecting-the-current-calibration","text":"The following command will allow you to visually inspect a calibration with Rviz. You can use RViz to see how well the robot's 3D body model matches point clouds from the 3D camera. While visualizing the 3D model and point clouds in RViz, you can use keyboard commands in the terminal to move the head around, the lift up and down, and the arm in and out. The keyboard commands will be printed in the terminal. A good calibration should result in a close correspondence between the robot's 3D body model and the point cloud throughout the ranges of motion for the head, lift, and arm. You may notice higher error when the head is looking upward due to challenges associated with head tilt backlash. You might also notice higher error when the arm is fully extended, since small angular errors can result in larger positional errors at the robot's wrist. Test the current head calibration roslaunch stretch_calibration simple_test_head_calibration.launch","title":"Visually Inspecting the Current Calibration"},{"location":"stretch-ros/stretch_calibration/#examples-of-good-and-bad-visual-fit","text":"In the images below, examples of good and bad fit between the point cloud and the geometric model are presented side by side. To make the distinction clear, the images have green and red circles indicating where the fit is either good or bad.","title":"Examples of Good and Bad Visual Fit"},{"location":"stretch-ros/stretch_calibration/#calibrate-the-stretch-re1","text":"Make sure the basic joint limit calibration has been performed. stretch_robot_home.py Make sure the uncalibrated URDF is up to date. rosrun stretch_calibration update_uncalibrated_urdf.sh Collect head calibration data Put the robot on a flat surface. Give it room to move its arm and good lighting. Then, have the robot collect data using the command below. While the robot is collecting data, do not block its view of its markers. roslaunch stretch_calibration collect_head_calibration_data.launch Process head calibration data Specify how much data to use and the quality of the fit YAML file with parameters: stretch_ros/stretch_calibration/config/head_calibration_options.yaml More data and higher quality fitting result in optimizations that take longer When quickly testing things out ~3 minutes without visualization data_to_use: use_very_little_data fit_quality: fastest_lowest_quality When calibrating the robot ~1 hour without visualization data_to_use: use_all_data fit_quality: slow_high_quality Perform the optimization to fit the model to the collected data Without visualization (faster) roslaunch stretch_calibration process_head_calibration_data.launch With visualization (slower) roslaunch stretch_calibration process_head_calibration_data_with_visualization.launch Inspect the fit of the most recent head calibration rosrun stretch_calibration visualize_most_recent_head_calibration.sh Start using the newest head calibration rosrun stretch_calibration update_with_most_recent_calibration.sh Test the current head calibration roslaunch stretch_calibration simple_test_head_calibration.launch Use RViz to visually inspect the calibrated model. The robot's 3D body model should look similar to the structure of your robot. You may refer to the section above to see examples of good and bad fit.","title":"Calibrate the Stretch RE1"},{"location":"stretch-ros/stretch_calibration/#generate-a-new-urdf-after-changing-the-tool","text":"If you change the Stretch RE1's tool attached to the wrist and want to generate a new URDF for it, you can do so with xacro files in the /stretch_ros/stretch_description/urdf/ directory. Specifically, you can edit stretch_description.xacro to include a xacro other than the default stretch_gripper.xacro. After changing the tool xacro you will need to generate a new URDF and also update this new URDF with the previously optimized calibration parameters. To do so, follow the directions below: In a terminal start roscore. This will enable the main script to proceed and terminate without pressing Ctrl-C. roscore Next, in a different terminal terminal run rosrun stretch_calibration update_urdf_after_xacro_change.sh This will update the uncalibrated URDF with the current xacro files and then create a calibrated URDF using the most recent calibration parameters.","title":"Generate a New URDF After Changing the Tool"},{"location":"stretch-ros/stretch_calibration/#revert-to-a-previous-calibration","text":"When a new calibration is performed, it is timestamped and added to the calibration directory under \"stretch_user/\". If you'd like to revert to a previous calibration, you may run the following command. It will move the most recent calibration files to a reversion directory and update the calibration in the stretch_description package from the remaining most recent calibration files. Revert to the previous head calibration rosrun stretch_calibration revert_to_previous_calibration.sh","title":"Revert to a Previous Calibration"},{"location":"stretch-ros/stretch_calibration/#license","text":"stretch_calibration is licensed with the GPLv3. Please see the LICENSE file for details. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"License"},{"location":"stretch-ros/stretch_calibration/LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains software for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents include free software and other kinds of works: you can redistribute them and/or modify them under the terms of the GNU General Public License v3.0 (GNU GPLv3) as published by the Free Software Foundation. The Contents are distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License v3.0 (GNU GPLv3) for more details, which can be found via the following link: https://www.gnu.org/licenses/gpl-3.0.html For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"stretch-ros/stretch_core/","text":"Overview stretch_core provides the core ROS interfaces to the Stretch RE1 mobile manipulator from Hello Robot Inc. It includes the following nodes: stretch_driver : node that communicates with the low-level Python library (stretch_body) to interface with the Stretch RE1 detect_aruco_markers : node that detects and estimates the pose of ArUco markers, including the markers on the robot's body d435i_ * : various nodes to help use the Stretch RE1's 3D camera keyboard_teleop : node that provides a keyboard interface to control the robot's joints License For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"stretch_core"},{"location":"stretch-ros/stretch_core/#overview","text":"stretch_core provides the core ROS interfaces to the Stretch RE1 mobile manipulator from Hello Robot Inc. It includes the following nodes: stretch_driver : node that communicates with the low-level Python library (stretch_body) to interface with the Stretch RE1 detect_aruco_markers : node that detects and estimates the pose of ArUco markers, including the markers on the robot's body d435i_ * : various nodes to help use the Stretch RE1's 3D camera keyboard_teleop : node that provides a keyboard interface to control the robot's joints","title":"Overview"},{"location":"stretch-ros/stretch_core/#license","text":"For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"License"},{"location":"stretch-ros/stretch_core/LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains software for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents are licensed under the Apache License, Version 2.0 (the \"License\"). You may not use the Contents except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, the Contents are distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"stretch-ros/stretch_deep_perception/","text":"Overview stretch_deep_perception provides demonstration code that uses open deep learning models to perceive the world. This code depends on the stretch_deep_perception_models repository, which should be installed under ~/stretch_user/ on your Stretch RE1 robot. Link to the stretch_deep_perception_models repository: https://github.com/hello-robot/stretch_deep_perception_models Getting Started Demos There are four demonstrations for you to try. Face Estimation Demo First, try running the face detection demonstration via the following command: roslaunch stretch_deep_perception stretch_detect_faces.launch RViz should show you the robot, the point cloud from the camera, and information about detected faces. If it detects a face, it should show a 3D planar model of the face and 3D facial landmarks. These deep learning models come from OpenCV and the Open Model Zoo (https://github.com/opencv/open_model_zoo). You can use the keyboard_teleop commands within the terminal that you ran roslaunch in order to move the robot's head around to see your face. i (tilt up) j (pan left) l (pan right) , (tilt down) Pan left and pan right are in terms of the robot's left and the robot's right. Now shut down everything that was launched by pressing q and Ctrl-C in the terminal. Object Detection Demo Second, try running the object detection demo, which uses the tiny YOLO v3 object detection network (https://pjreddie.com/darknet/yolo/). RViz will display planar detection regions. Detection class labels will be printed to the terminal. roslaunch stretch_deep_perception stretch_detect_objects.launch Once you're ready for the next demo, shut down everything that was launched by pressing q and Ctrl-C in the terminal. Body Landmark Detection Demo Third, try running the body landmark point detection demo. The deep learning model comes from the Open Model Zoo (https://github.com/opencv/open_model_zoo). RViz will display colored 3D points on body landmarks. The network also provides information to connect these landmarks, but this demo code does not currently use it. roslaunch stretch_deep_perception stretch_detect_body_landmarks.launch Once you're ready for the next demo, shut down everything that was launched by pressing q and Ctrl-C in the terminal. Nearest Mouth Detection Demo Finally, try running the nearest mouth detection demo. RViz will display a 3D frame of reference estimated for the nearest mouth detected by the robot. Sometimes the point cloud will make it difficult to see. Disabling the point cloud view in RViz will make it more visible. We have used this frame of reference to deliver food near a person's mouth. This has the potential to be useful for assistive feeding. However, use of this detector in this way could be risky. Please be very careful and aware that you are using it at your own risk. A less risky use of this detection is for object delivery. stretch_demos has a demonstration that delivers an object based on this frame of reference by holding out the object some distance from the mouth location and below the mouth location with respect to the world frame. This works well and is inspired by similar methods used with the robot EL-E at Georgia Tech [1]. roslaunch stretch_deep_perception stretch_detect_nearest_mouth.launch References [1] Hand It Over or Set It Down: A User Study of Object Delivery with an Assistive Mobile Manipulator, Young Sang Choi, Tiffany L. Chen, Advait Jain, Cressel Anderson, Jonathan D. Glass, and Charles C. Kemp, IEEE International Symposium on Robot and Human Interactive Communication (RO-MAN), 2009. http://pwp.gatech.edu/hrl/wp-content/uploads/sites/231/2016/05/roman2009_delivery.pdf License For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"stretch_deep_perception"},{"location":"stretch-ros/stretch_deep_perception/#overview","text":"stretch_deep_perception provides demonstration code that uses open deep learning models to perceive the world. This code depends on the stretch_deep_perception_models repository, which should be installed under ~/stretch_user/ on your Stretch RE1 robot. Link to the stretch_deep_perception_models repository: https://github.com/hello-robot/stretch_deep_perception_models","title":"Overview"},{"location":"stretch-ros/stretch_deep_perception/#getting-started-demos","text":"There are four demonstrations for you to try.","title":"Getting Started Demos"},{"location":"stretch-ros/stretch_deep_perception/#face-estimation-demo","text":"First, try running the face detection demonstration via the following command: roslaunch stretch_deep_perception stretch_detect_faces.launch RViz should show you the robot, the point cloud from the camera, and information about detected faces. If it detects a face, it should show a 3D planar model of the face and 3D facial landmarks. These deep learning models come from OpenCV and the Open Model Zoo (https://github.com/opencv/open_model_zoo). You can use the keyboard_teleop commands within the terminal that you ran roslaunch in order to move the robot's head around to see your face. i (tilt up) j (pan left) l (pan right) , (tilt down) Pan left and pan right are in terms of the robot's left and the robot's right. Now shut down everything that was launched by pressing q and Ctrl-C in the terminal.","title":"Face Estimation Demo"},{"location":"stretch-ros/stretch_deep_perception/#object-detection-demo","text":"Second, try running the object detection demo, which uses the tiny YOLO v3 object detection network (https://pjreddie.com/darknet/yolo/). RViz will display planar detection regions. Detection class labels will be printed to the terminal. roslaunch stretch_deep_perception stretch_detect_objects.launch Once you're ready for the next demo, shut down everything that was launched by pressing q and Ctrl-C in the terminal.","title":"Object Detection Demo"},{"location":"stretch-ros/stretch_deep_perception/#body-landmark-detection-demo","text":"Third, try running the body landmark point detection demo. The deep learning model comes from the Open Model Zoo (https://github.com/opencv/open_model_zoo). RViz will display colored 3D points on body landmarks. The network also provides information to connect these landmarks, but this demo code does not currently use it. roslaunch stretch_deep_perception stretch_detect_body_landmarks.launch Once you're ready for the next demo, shut down everything that was launched by pressing q and Ctrl-C in the terminal.","title":"Body Landmark Detection Demo"},{"location":"stretch-ros/stretch_deep_perception/#nearest-mouth-detection-demo","text":"Finally, try running the nearest mouth detection demo. RViz will display a 3D frame of reference estimated for the nearest mouth detected by the robot. Sometimes the point cloud will make it difficult to see. Disabling the point cloud view in RViz will make it more visible. We have used this frame of reference to deliver food near a person's mouth. This has the potential to be useful for assistive feeding. However, use of this detector in this way could be risky. Please be very careful and aware that you are using it at your own risk. A less risky use of this detection is for object delivery. stretch_demos has a demonstration that delivers an object based on this frame of reference by holding out the object some distance from the mouth location and below the mouth location with respect to the world frame. This works well and is inspired by similar methods used with the robot EL-E at Georgia Tech [1]. roslaunch stretch_deep_perception stretch_detect_nearest_mouth.launch","title":"Nearest Mouth Detection Demo"},{"location":"stretch-ros/stretch_deep_perception/#references","text":"[1] Hand It Over or Set It Down: A User Study of Object Delivery with an Assistive Mobile Manipulator, Young Sang Choi, Tiffany L. Chen, Advait Jain, Cressel Anderson, Jonathan D. Glass, and Charles C. Kemp, IEEE International Symposium on Robot and Human Interactive Communication (RO-MAN), 2009. http://pwp.gatech.edu/hrl/wp-content/uploads/sites/231/2016/05/roman2009_delivery.pdf","title":"References"},{"location":"stretch-ros/stretch_deep_perception/#license","text":"For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"License"},{"location":"stretch-ros/stretch_deep_perception/LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains software for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents are licensed under the Apache License, Version 2.0 (the \"License\"). You may not use the Contents except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, the Contents are distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"stretch-ros/stretch_demos/","text":"Overview stretch_demos provides simple demonstrations for the Stretch RE1 mobile manipulator from Hello Robot Inc. For an overview of the demos, we recommend you look at the following forum post: https://forum.hello-robot.com/t/autonomy-video-details Getting Started Demos Please be aware that these demonstrations typically do not perform careful collision avoidance. Instead, they expect to operate in freespace and detect contact through motor current if an obstacle gets in the way. Please be careful when trying out these demonstrations. Handover Object Demo First, place the robot near you so that it can freely move back and forth and reach near your body. Then, launch the handover object demo using the following command: roslaunch stretch_demos handover_object.launch For this demonstration, the robot will pan its head back and forth looking for a face. It will remember the 3D location of the mouth of the nearest face that it has detected. If you press \"y\" or \"Y\" on the keyboard in the terminal, the robot will move the grasp region of its gripper toward a handover location below and away from the mouth. The robot will restrict itself to Cartesian motion to do this. Specifically, it will move its mobile base backward and forward, its lift up and down, and its arm in and out. If you press \"y\" or \"Y\" again, it will retract its arm and then move to the most recent mouth location it has detected. At any time, you can also use the keyboard teleoperation commands in the terminal window. With this, you can adjust the gripper, including pointing it straight out and making it grasp an object to be handed over. Grasp Object Demo For this demonstration, the robot will look for the nearest elevated surface, look for an object on it, and then attempt to grasp the largest object using Cartesian motions. Prior to running the demo, you should move the robot so that its workspace will be able to move its gripper over the surface while performing Cartesian motions. Once the robot is in position, retract and lower the arm so that the robot can clearly see the surface when looking out in the direction of its arm. Now that the robot is ready, launch the demo with the following command: roslaunch stretch_demos grasp_object.launch Then, press the key with \u2018 and \u201c on it while in the terminal to initiate a grasp attempt. While attempting the grasp the demo will save several images under the ./stretch_user/debug/ directory within various grasping related directories. You can view these images to see some of what the robot did to make its decisions. Clean Surface Demo For this demonstration, the robot will look for the nearest elevated surface, look for clear space on it, and then attempt to wipe the clear space using Cartesian motions. Prior to running the demo, you should move the robot so that its workspace will be able to move its gripper over the surface while performing Cartesian motions. You should also place a soft cloth in the robot's gripper. Once the robot is in position with a cloth in its gripper, retract and lower the arm so that the robot can clearly see the surface when looking out in the direction of its arm. Now that the robot is ready, launch the demo with the following command: roslaunch stretch_demos clean_surface.launch Then, press the key with the / and ? on it while in the terminal to initiate a surface cleaning attempt. License For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"stretch_demos"},{"location":"stretch-ros/stretch_demos/#overview","text":"stretch_demos provides simple demonstrations for the Stretch RE1 mobile manipulator from Hello Robot Inc. For an overview of the demos, we recommend you look at the following forum post: https://forum.hello-robot.com/t/autonomy-video-details","title":"Overview"},{"location":"stretch-ros/stretch_demos/#getting-started-demos","text":"Please be aware that these demonstrations typically do not perform careful collision avoidance. Instead, they expect to operate in freespace and detect contact through motor current if an obstacle gets in the way. Please be careful when trying out these demonstrations.","title":"Getting Started Demos"},{"location":"stretch-ros/stretch_demos/#handover-object-demo","text":"First, place the robot near you so that it can freely move back and forth and reach near your body. Then, launch the handover object demo using the following command: roslaunch stretch_demos handover_object.launch For this demonstration, the robot will pan its head back and forth looking for a face. It will remember the 3D location of the mouth of the nearest face that it has detected. If you press \"y\" or \"Y\" on the keyboard in the terminal, the robot will move the grasp region of its gripper toward a handover location below and away from the mouth. The robot will restrict itself to Cartesian motion to do this. Specifically, it will move its mobile base backward and forward, its lift up and down, and its arm in and out. If you press \"y\" or \"Y\" again, it will retract its arm and then move to the most recent mouth location it has detected. At any time, you can also use the keyboard teleoperation commands in the terminal window. With this, you can adjust the gripper, including pointing it straight out and making it grasp an object to be handed over.","title":"Handover Object Demo"},{"location":"stretch-ros/stretch_demos/#grasp-object-demo","text":"For this demonstration, the robot will look for the nearest elevated surface, look for an object on it, and then attempt to grasp the largest object using Cartesian motions. Prior to running the demo, you should move the robot so that its workspace will be able to move its gripper over the surface while performing Cartesian motions. Once the robot is in position, retract and lower the arm so that the robot can clearly see the surface when looking out in the direction of its arm. Now that the robot is ready, launch the demo with the following command: roslaunch stretch_demos grasp_object.launch Then, press the key with \u2018 and \u201c on it while in the terminal to initiate a grasp attempt. While attempting the grasp the demo will save several images under the ./stretch_user/debug/ directory within various grasping related directories. You can view these images to see some of what the robot did to make its decisions.","title":"Grasp Object Demo"},{"location":"stretch-ros/stretch_demos/#clean-surface-demo","text":"For this demonstration, the robot will look for the nearest elevated surface, look for clear space on it, and then attempt to wipe the clear space using Cartesian motions. Prior to running the demo, you should move the robot so that its workspace will be able to move its gripper over the surface while performing Cartesian motions. You should also place a soft cloth in the robot's gripper. Once the robot is in position with a cloth in its gripper, retract and lower the arm so that the robot can clearly see the surface when looking out in the direction of its arm. Now that the robot is ready, launch the demo with the following command: roslaunch stretch_demos clean_surface.launch Then, press the key with the / and ? on it while in the terminal to initiate a surface cleaning attempt.","title":"Clean Surface Demo"},{"location":"stretch-ros/stretch_demos/#license","text":"For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"License"},{"location":"stretch-ros/stretch_demos/LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains software for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents are licensed under the Apache License, Version 2.0 (the \"License\"). You may not use the Contents except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, the Contents are distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"stretch-ros/stretch_description/","text":"Overview stretch_description provides materials for a URDF kinematic model of the Stretch RE1 mobile manipulator from Hello Robot Inc. Details The meshes directory contains STL mesh files representing the exterior geometry of various parts of the robot. The urdf directory contains xacro files representing various parts of the robot that are used to generate the robot's URDF. stretch_ros expects a URDF with the name stretch.urdf to reside within the urdf directory. The file stretch.urdf serves as the URDF for the robot and must be generated. Typically, it is a calibrated urdf file for the particular Stretch RE1 robot being used. To generate this file, please read the documentation within stretch_ros/stretch_calibration. The xacro_to_urdf.sh will usually only be indirectly run as part of various scripts and launch files within stretch_ros/stretch_calibration. Sometimes a stretch_uncalibrated.urdf file will reside with the urdf directory. This file is typically generated directly from the xacro files without any alterations. Exporting a URDF Sometimes a URDF is useful outside of ROS, such as for simulations and analysis. Running the export_urdf.sh script in the urdf directory will export a full URDF model of the robot based on stretch.urdf. The exported URDF will be found within an exported_urdf directory. It is also copied to a directory for your specific robot found under ~/stretch_user. The exported URDF includes meshes and controller calibration YAML files. The exported URDF can be visualized using stretch_urdf_show.py, which is part of the stretch_body Python code. Changing the Tool If you wish to remove the default gripper and add a different tool, you will typically edit /stretch_description/urdf/stretch_description.xacro. Specifically, you will replace the following line in order to include the xacro for the new tool and then follow directions within stretch_ros/stretch_calibration to generate a new calibrated urdf file (stretch.urdf) that includes the new tool. <xacro:include filename=\"stretch_gripper.xacro\" /> As an example we provide the xacro stretch_dry_erase_marker.xacro and its dependent mesh files with stretch_ros. Some of the tools found in the Stretch Body Tool Share include URDF data. To integrate these tools into the URDF for your Stretch >>$ cd ~/repos >>$ git clone https://github.com/hello-robot/stretch_tool_share >>$ cd stretch_tool_share/<tool name> >>$ cp stretch_description/urdf/* ~/catkin_ws/src/stretch_ros/stretch_description/urdf/ >>$ cp stretch_description/meshes/* ~/catkin_ws/src/stretch_ros/stretch_description/meshes/ Next add the xacro for the particular tool to /stretch_description/urdf/stretch_description.xacro . Then you can generate and preview the uncalibrated URDF: >>$ cd ~/catkin_ws/src/stretch_ros/stretch_description/urdf >>$ cp stretch.urdf stretch.urdf.bak >>$ rosrun stretch_calibration update_urdf_after_xacro_change.sh Now visualize the new tool >>$ roslaunch stretch_calibration simple_test_head_calibration.launch License and Patents Patents are pending that cover aspects of the Stretch RE1 mobile manipulator. For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"stretch_description"},{"location":"stretch-ros/stretch_description/#overview","text":"stretch_description provides materials for a URDF kinematic model of the Stretch RE1 mobile manipulator from Hello Robot Inc.","title":"Overview"},{"location":"stretch-ros/stretch_description/#details","text":"The meshes directory contains STL mesh files representing the exterior geometry of various parts of the robot. The urdf directory contains xacro files representing various parts of the robot that are used to generate the robot's URDF. stretch_ros expects a URDF with the name stretch.urdf to reside within the urdf directory. The file stretch.urdf serves as the URDF for the robot and must be generated. Typically, it is a calibrated urdf file for the particular Stretch RE1 robot being used. To generate this file, please read the documentation within stretch_ros/stretch_calibration. The xacro_to_urdf.sh will usually only be indirectly run as part of various scripts and launch files within stretch_ros/stretch_calibration. Sometimes a stretch_uncalibrated.urdf file will reside with the urdf directory. This file is typically generated directly from the xacro files without any alterations.","title":"Details"},{"location":"stretch-ros/stretch_description/#exporting-a-urdf","text":"Sometimes a URDF is useful outside of ROS, such as for simulations and analysis. Running the export_urdf.sh script in the urdf directory will export a full URDF model of the robot based on stretch.urdf. The exported URDF will be found within an exported_urdf directory. It is also copied to a directory for your specific robot found under ~/stretch_user. The exported URDF includes meshes and controller calibration YAML files. The exported URDF can be visualized using stretch_urdf_show.py, which is part of the stretch_body Python code.","title":"Exporting a URDF"},{"location":"stretch-ros/stretch_description/#changing-the-tool","text":"If you wish to remove the default gripper and add a different tool, you will typically edit /stretch_description/urdf/stretch_description.xacro. Specifically, you will replace the following line in order to include the xacro for the new tool and then follow directions within stretch_ros/stretch_calibration to generate a new calibrated urdf file (stretch.urdf) that includes the new tool. <xacro:include filename=\"stretch_gripper.xacro\" /> As an example we provide the xacro stretch_dry_erase_marker.xacro and its dependent mesh files with stretch_ros. Some of the tools found in the Stretch Body Tool Share include URDF data. To integrate these tools into the URDF for your Stretch >>$ cd ~/repos >>$ git clone https://github.com/hello-robot/stretch_tool_share >>$ cd stretch_tool_share/<tool name> >>$ cp stretch_description/urdf/* ~/catkin_ws/src/stretch_ros/stretch_description/urdf/ >>$ cp stretch_description/meshes/* ~/catkin_ws/src/stretch_ros/stretch_description/meshes/ Next add the xacro for the particular tool to /stretch_description/urdf/stretch_description.xacro . Then you can generate and preview the uncalibrated URDF: >>$ cd ~/catkin_ws/src/stretch_ros/stretch_description/urdf >>$ cp stretch.urdf stretch.urdf.bak >>$ rosrun stretch_calibration update_urdf_after_xacro_change.sh Now visualize the new tool >>$ roslaunch stretch_calibration simple_test_head_calibration.launch","title":"Changing the Tool"},{"location":"stretch-ros/stretch_description/#license-and-patents","text":"Patents are pending that cover aspects of the Stretch RE1 mobile manipulator. For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"License and Patents"},{"location":"stretch-ros/stretch_description/LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"). The Contents consist of software and data used with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. The Clear BSD License Copyright (c) 2021 Hello Robot Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"LICENSE"},{"location":"stretch-ros/stretch_description/urdf/export_urdf_license_template/","text":"The following license applies to the entire contents of this directory (the \"Contents\") except where otherwise noted. The Contents consist of software and data used with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents are licensed under the Creative Commons Attribution-NonCommercial-ShareAlike-4.0-International (CC BY-NC-SA 4.0) license (the \"License\"); you may not use the Contents except in compliance with the License. You may obtain a copy of the License at https://creativecommons.org/licenses/by-nc-sa/4.0/ Unless required by applicable law or agreed to in writing, the Contents distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Patents pending and trademark rights cover the Contents. As stated by the detailed License, \"Patent and trademark rights are not licensed under this Public License.\" The Contents may incorporate some parts of the \"RealSense Camera description package for Intel 3D D400 cameras\" released with an Apache 2.0 license and Copyright 2017 Intel Corporation. The details of the Apache 2.0 license can be found via the following link: https://www.apache.org/licenses/LICENSE-2.0 Specifically, the Contents may include the d435.dae mesh file and content generated by the _d435.urdf.xacro found within the GitHub repository available for download via the following link as of May 4, 2020: https://github.com/IntelRealSense/realsense-ros/tree/development/realsense2_description These specific materials are subject to the requirements of their original Apache 2.0 license. For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"Export urdf license template"},{"location":"stretch-ros/stretch_funmap/","text":"Overview stretch_funmap is an implementation of Fast Unified Navigation, Manipulation And Planning (FUNMAP). FUNMAP provides navigation, manipulation, and planning capabilities for the Stretch RE1 mobile manipulator. stretch_funmap includes examples of efficient ways to take advantage of the Stretch RE1's unique properties. Previous commercially-available mobile manipulators have consisted of a serial manipulator (i.e., links connected by rotary joints) placed on a mobile base [1]. Widely used software (e.g., the Robot Operating System (ROS)) [1] typically expects a velocity-controlled mobile base that can be held still while the arm manipulates [3, 4]. In contrast, the Stretch RE1's mobile base is integral to manipulation and typically moves throughout a task. It can also perform high-fidelity position control with its mobile base. FUNMAP uses approximate geometric models and computer-vision algorithms to efficiently find plans that take advantage of its prismatic joints (e.g., telescoping arm) and Cartesian structure. In contrast to typical approaches that treat navigation (e.g., ROS Navigation Stack ) and manipulation (e.g., MoveIt! [5, 6]) separately, FUNMAP does both. Getting Started Demo First, make sure that your Stretch RE1 has clearance to rotate in place and will rotate without straining any cables connected to the trunk. Ideally, you should have the robot untethered. Next, run the following launch file: roslaunch stretch_funmap mapping.launch Now, you will take a head scan, which will involve the head panning around, the base rotating, and the head panning around again to overcome the blindspot due to the mast. While in the terminal in which you ran roslaunch, press the space bar to initiate the head scan. At this point, you should see a 3D map resulting from the head scan in RViz. You can rotate it around and look at it. It has been created by merging many 3D scans. If you have the robot untethered, you can now specify a navigation goal for the robot. If the robot finds a navigation plan to the goal, it will attempt to navigate to it. While navigating, it will look down with its 3D camera in an attempt to stop if it detects an obstacle. In RViz, press the \"2D Nav Goal\" button on the top bar with a magenta arrow icon. Specify a nearby navigation goal pose on the floor of the map by clicking and drawing a magenta arrow. For this to work, the navigation goal must be in a place that the robot can reach and that the robot has scanned well. For example, the robot will only navigate across floor regions that it has in its map. If the robot finds a path, you should see green lines connecting white spheres in RViz that display its plan as it attempts to navigate to the goal. Once the robot has reached the goal, you can take another head scan. While in the terminal, press the space bar to initiate another head scan. The robot should take the head scan and merge it with the previous scans. If all goes well, the merged 3D map will be visible in RViz. You can also have the robot automatically drive to a place that it thinks is a good place for it to take a head scan in order to map the environment. While in the terminal, press the key with \\ and | on it. This should work even if caps lock is enabled or the shift key is pressed. If the robot reached it's goal, then you can now take another head scan. While in the terminal, press the space bar to initiate another head scan. By repeating this process, you can create a 3D map of the environment. FUNMAP uses images to represent the environment with each pixel value representing the highest observed 3D point at a planar location. By default, all of the merged maps are saved to the following directory: ./stretch_user/debug/merged_maps/ You can see the image representations by looking at files with the following naming pattern: ./stretch_user/debug/merged_maps/merged_map_DATETIME_mhi_visualization.png You can also click on a reaching goal for the Stretch RE1 by clicking on \"Publish Point\" in Rviz and then selecting a 3D point on the map. FUNMAP will attempt to generate a navigation and manipulation plan to reach close to the selected 3D location with Stretch's gripper. In RViz, select a reach goal by clicking on \"Publish Point\" on the top bar with a red map location icon). Then, click on a 3D location on the map to specify a reaching target for the robot's gripper. That concludes the demonstration. Have fun with FUNMAP! More FUNMAP FUNMAP represents human environments with Max Height Images (MHIs). An MHI is an image for which each pixel typically represents the height of the robot\u2019s environment. Given a volume of interest (VOI) with its z-axis aligned with gravity, an MHI, I, maps locations to heights. Specifically, I(x,y)=z, where (x,y) represents a discretized planar location within the VOI and z represents the discretized height of the maximum occupied voxel within the VOI at that planar location (see Figure 1 above). The placement of the Stretch RE1 3D camera at a human head height enables it to capture MHIs that represent the horizontal surfaces with which humans frequently interact, such as table tops, countertops, and chairs. The orientation of its 3D camera enables the robot to quickly scan an environment to create a room-scale MHI by panning its head at a constant tilt angle. In contrast to other environment representations, such as point clouds and 3D mesh models, MHIs support fast, efficient operations through optimized image processing and are compatible with deep learning methods for images. Related representations have primarily been used for navigation, including for legged robots on rough terrain, but have not emphasized elevated surfaces in human environments nor incorporated manipulation [7, 8]. Object grasping systems for bin picking have used related representations, but have only considered small areas with objects and not incorporated navigation [9, 10]. During development, we have used FUNMAP to create MHIs for which each pixel represents a 6mm x 6mm region of the environment\u2019s floor and has a height resolution of less than 6mm per unit. This allows a single 2000 x 2000 pixel, 8-bit image to represent a 12m x 12m environment from 10cm below the estimated floor plane to 1.2m above the floor plane, which captures the great majority of open horizontal surfaces in human environments with which people interact. MHIs also have the potential to represent enclosed surfaces (e.g., surfaces in shelves and cabinets) and vertical surfaces (e.g., doors) by defining new VOIs with different orientations and heights, which is a capability that merits future exploration. For navigation and planning, FUNMAP uses fast distance transforms and morphological operators to efficiently create cost functions for robust optimization-based planning. For example, a high value of a distance transform at a floor location implies that the mobile base will be farther from obstacles. Similarly, a high value of a distance transform for a location on an elevated surface implies that the robot\u2019s end effector will be farther from obstacles. Figure 3: Left: The cyan lines represent achievable driving goals on the floor from which the robot can reach the target (red circle) on the table (dark blue). Right: When the target (red circle) is farther back near obstacles on the table (dark blue), the robot can reach the target from fewer locations (cyan lines). Figure 4: Left: Example of a piecewise linear navigation plan (green line segments and white spheres) being executed. Right: Example of a successfully executed plan to reach a target location on a table (light blue) while avoiding a wall with shelves (dark blue and purple). The Stretch RE1\u2019s slender links and Cartesian kinematics support rapid optimization of plans due to the simplified geometry of the robot\u2019s motions. FUNMAP uses piecewise linear paths on the cost image for fast navigation and manipulation planning. FUNMAP enables the Stretch RE1 to reach a 3D target position. FUNMAP models the linear motion of the telescoping arm as it extends to reach a target as a line in a manipulation cost image (see Figure 2). FUNMAP uses a navigation cost image and Djikstra\u2019s algorithm with a priority queue to efficiently estimate the cost of navigating to all floor locations (see Figure 3 left). FUNMAP then combines these results to find a minimum cost plan that increases the distance to obstacles and the manipulable workspace of the robot (see Figure 3 right). References [1] Bostelman, Roger, Tsai Hong, and Jeremy Marvel. \"Survey of research for performance measurement of mobile manipulators.\" Journal of Research of the National Institute of Standards and Technology 121, no. 3 (2016): 342-366. [2] Quigley, Morgan, Ken Conley, Brian Gerkey, Josh Faust, Tully Foote, Jeremy Leibs, Rob Wheeler, and Andrew Y. Ng. \"ROS: an open-source Robot Operating System.\" In ICRA workshop on open source software, vol. 3, no. 3.2, p. 5. 2009. [3] Sachin Chitta, Eitan Marder-Eppstein, Wim Meeussen, Vijay Pradeep, Adolfo Rodr\u00edguez Tsouroukdissian, et al.. ros_control: A generic and simple control framework for ROS. The Journal of Open Source Software, 2017, 2 (20), pp.456 - 456. [4] Guimar\u00e3es, Rodrigo Longhi, Andr\u00e9 Schneider de Oliveira, Jo\u00e3o Alberto Fabro, Thiago Becker, and Vin\u00edcius Amilgar Brenner. \"ROS navigation: Concepts and tutorial.\" In Robot Operating System (ROS), pp. 121-160. Springer, Cham, 2016. [5] Chitta, Sachin, Ioan Sucan, and Steve Cousins. \"Moveit! [ros topics].\" IEEE Robotics & Automation Magazine 19, no. 1 (2012): 18-19. [6] Chitta, Sachin. \"MoveIt!: an introduction.\" In Robot Operating System (ROS), pp. 3-27. Springer, Cham, 2016. [7] Fankhauser, P\u00e9ter, and Marco Hutter. \"A universal grid map library: Implementation and use case for rough terrain navigation.\" In Robot Operating System (ROS), pp. 99-120. Springer, Cham, 2016. [8] Lu, David V., Dave Hershberger, and William D. Smart. \"Layered costmaps for context-sensitive navigation.\" In 2014 IEEE/RSJ International Conference on Intelligent Robots and Systems, pp. 709-715. IEEE, 2014. [9] Zeng, Andy, Shuran Song, Johnny Lee, Alberto Rodriguez, and Thomas Funkhouser. \"Tossingbot: Learning to throw arbitrary objects with residual physics.\" arXiv preprint arXiv:1903.11239 (2019). [10] Zeng, Andy, Shuran Song, Kuan-Ting Yu, Elliott Donlon, Francois R. Hogan, Maria Bauza, Daolin Ma et al. \"Robotic pick-and-place of novel objects in clutter with multi-affordance grasping and cross-domain image matching.\" In 2018 IEEE international conference on robotics and automation (ICRA), pp. 1-8. IEEE, 2018. License For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"stretch_funmap"},{"location":"stretch-ros/stretch_funmap/#overview","text":"stretch_funmap is an implementation of Fast Unified Navigation, Manipulation And Planning (FUNMAP). FUNMAP provides navigation, manipulation, and planning capabilities for the Stretch RE1 mobile manipulator. stretch_funmap includes examples of efficient ways to take advantage of the Stretch RE1's unique properties. Previous commercially-available mobile manipulators have consisted of a serial manipulator (i.e., links connected by rotary joints) placed on a mobile base [1]. Widely used software (e.g., the Robot Operating System (ROS)) [1] typically expects a velocity-controlled mobile base that can be held still while the arm manipulates [3, 4]. In contrast, the Stretch RE1's mobile base is integral to manipulation and typically moves throughout a task. It can also perform high-fidelity position control with its mobile base. FUNMAP uses approximate geometric models and computer-vision algorithms to efficiently find plans that take advantage of its prismatic joints (e.g., telescoping arm) and Cartesian structure. In contrast to typical approaches that treat navigation (e.g., ROS Navigation Stack ) and manipulation (e.g., MoveIt! [5, 6]) separately, FUNMAP does both.","title":"Overview"},{"location":"stretch-ros/stretch_funmap/#getting-started-demo","text":"First, make sure that your Stretch RE1 has clearance to rotate in place and will rotate without straining any cables connected to the trunk. Ideally, you should have the robot untethered. Next, run the following launch file: roslaunch stretch_funmap mapping.launch Now, you will take a head scan, which will involve the head panning around, the base rotating, and the head panning around again to overcome the blindspot due to the mast. While in the terminal in which you ran roslaunch, press the space bar to initiate the head scan. At this point, you should see a 3D map resulting from the head scan in RViz. You can rotate it around and look at it. It has been created by merging many 3D scans. If you have the robot untethered, you can now specify a navigation goal for the robot. If the robot finds a navigation plan to the goal, it will attempt to navigate to it. While navigating, it will look down with its 3D camera in an attempt to stop if it detects an obstacle. In RViz, press the \"2D Nav Goal\" button on the top bar with a magenta arrow icon. Specify a nearby navigation goal pose on the floor of the map by clicking and drawing a magenta arrow. For this to work, the navigation goal must be in a place that the robot can reach and that the robot has scanned well. For example, the robot will only navigate across floor regions that it has in its map. If the robot finds a path, you should see green lines connecting white spheres in RViz that display its plan as it attempts to navigate to the goal. Once the robot has reached the goal, you can take another head scan. While in the terminal, press the space bar to initiate another head scan. The robot should take the head scan and merge it with the previous scans. If all goes well, the merged 3D map will be visible in RViz. You can also have the robot automatically drive to a place that it thinks is a good place for it to take a head scan in order to map the environment. While in the terminal, press the key with \\ and | on it. This should work even if caps lock is enabled or the shift key is pressed. If the robot reached it's goal, then you can now take another head scan. While in the terminal, press the space bar to initiate another head scan. By repeating this process, you can create a 3D map of the environment. FUNMAP uses images to represent the environment with each pixel value representing the highest observed 3D point at a planar location. By default, all of the merged maps are saved to the following directory: ./stretch_user/debug/merged_maps/ You can see the image representations by looking at files with the following naming pattern: ./stretch_user/debug/merged_maps/merged_map_DATETIME_mhi_visualization.png You can also click on a reaching goal for the Stretch RE1 by clicking on \"Publish Point\" in Rviz and then selecting a 3D point on the map. FUNMAP will attempt to generate a navigation and manipulation plan to reach close to the selected 3D location with Stretch's gripper. In RViz, select a reach goal by clicking on \"Publish Point\" on the top bar with a red map location icon). Then, click on a 3D location on the map to specify a reaching target for the robot's gripper. That concludes the demonstration. Have fun with FUNMAP!","title":"Getting Started Demo"},{"location":"stretch-ros/stretch_funmap/#more-funmap","text":"FUNMAP represents human environments with Max Height Images (MHIs). An MHI is an image for which each pixel typically represents the height of the robot\u2019s environment. Given a volume of interest (VOI) with its z-axis aligned with gravity, an MHI, I, maps locations to heights. Specifically, I(x,y)=z, where (x,y) represents a discretized planar location within the VOI and z represents the discretized height of the maximum occupied voxel within the VOI at that planar location (see Figure 1 above). The placement of the Stretch RE1 3D camera at a human head height enables it to capture MHIs that represent the horizontal surfaces with which humans frequently interact, such as table tops, countertops, and chairs. The orientation of its 3D camera enables the robot to quickly scan an environment to create a room-scale MHI by panning its head at a constant tilt angle. In contrast to other environment representations, such as point clouds and 3D mesh models, MHIs support fast, efficient operations through optimized image processing and are compatible with deep learning methods for images. Related representations have primarily been used for navigation, including for legged robots on rough terrain, but have not emphasized elevated surfaces in human environments nor incorporated manipulation [7, 8]. Object grasping systems for bin picking have used related representations, but have only considered small areas with objects and not incorporated navigation [9, 10]. During development, we have used FUNMAP to create MHIs for which each pixel represents a 6mm x 6mm region of the environment\u2019s floor and has a height resolution of less than 6mm per unit. This allows a single 2000 x 2000 pixel, 8-bit image to represent a 12m x 12m environment from 10cm below the estimated floor plane to 1.2m above the floor plane, which captures the great majority of open horizontal surfaces in human environments with which people interact. MHIs also have the potential to represent enclosed surfaces (e.g., surfaces in shelves and cabinets) and vertical surfaces (e.g., doors) by defining new VOIs with different orientations and heights, which is a capability that merits future exploration. For navigation and planning, FUNMAP uses fast distance transforms and morphological operators to efficiently create cost functions for robust optimization-based planning. For example, a high value of a distance transform at a floor location implies that the mobile base will be farther from obstacles. Similarly, a high value of a distance transform for a location on an elevated surface implies that the robot\u2019s end effector will be farther from obstacles. Figure 3: Left: The cyan lines represent achievable driving goals on the floor from which the robot can reach the target (red circle) on the table (dark blue). Right: When the target (red circle) is farther back near obstacles on the table (dark blue), the robot can reach the target from fewer locations (cyan lines). Figure 4: Left: Example of a piecewise linear navigation plan (green line segments and white spheres) being executed. Right: Example of a successfully executed plan to reach a target location on a table (light blue) while avoiding a wall with shelves (dark blue and purple). The Stretch RE1\u2019s slender links and Cartesian kinematics support rapid optimization of plans due to the simplified geometry of the robot\u2019s motions. FUNMAP uses piecewise linear paths on the cost image for fast navigation and manipulation planning. FUNMAP enables the Stretch RE1 to reach a 3D target position. FUNMAP models the linear motion of the telescoping arm as it extends to reach a target as a line in a manipulation cost image (see Figure 2). FUNMAP uses a navigation cost image and Djikstra\u2019s algorithm with a priority queue to efficiently estimate the cost of navigating to all floor locations (see Figure 3 left). FUNMAP then combines these results to find a minimum cost plan that increases the distance to obstacles and the manipulable workspace of the robot (see Figure 3 right).","title":"More FUNMAP"},{"location":"stretch-ros/stretch_funmap/#references","text":"[1] Bostelman, Roger, Tsai Hong, and Jeremy Marvel. \"Survey of research for performance measurement of mobile manipulators.\" Journal of Research of the National Institute of Standards and Technology 121, no. 3 (2016): 342-366. [2] Quigley, Morgan, Ken Conley, Brian Gerkey, Josh Faust, Tully Foote, Jeremy Leibs, Rob Wheeler, and Andrew Y. Ng. \"ROS: an open-source Robot Operating System.\" In ICRA workshop on open source software, vol. 3, no. 3.2, p. 5. 2009. [3] Sachin Chitta, Eitan Marder-Eppstein, Wim Meeussen, Vijay Pradeep, Adolfo Rodr\u00edguez Tsouroukdissian, et al.. ros_control: A generic and simple control framework for ROS. The Journal of Open Source Software, 2017, 2 (20), pp.456 - 456. [4] Guimar\u00e3es, Rodrigo Longhi, Andr\u00e9 Schneider de Oliveira, Jo\u00e3o Alberto Fabro, Thiago Becker, and Vin\u00edcius Amilgar Brenner. \"ROS navigation: Concepts and tutorial.\" In Robot Operating System (ROS), pp. 121-160. Springer, Cham, 2016. [5] Chitta, Sachin, Ioan Sucan, and Steve Cousins. \"Moveit! [ros topics].\" IEEE Robotics & Automation Magazine 19, no. 1 (2012): 18-19. [6] Chitta, Sachin. \"MoveIt!: an introduction.\" In Robot Operating System (ROS), pp. 3-27. Springer, Cham, 2016. [7] Fankhauser, P\u00e9ter, and Marco Hutter. \"A universal grid map library: Implementation and use case for rough terrain navigation.\" In Robot Operating System (ROS), pp. 99-120. Springer, Cham, 2016. [8] Lu, David V., Dave Hershberger, and William D. Smart. \"Layered costmaps for context-sensitive navigation.\" In 2014 IEEE/RSJ International Conference on Intelligent Robots and Systems, pp. 709-715. IEEE, 2014. [9] Zeng, Andy, Shuran Song, Johnny Lee, Alberto Rodriguez, and Thomas Funkhouser. \"Tossingbot: Learning to throw arbitrary objects with residual physics.\" arXiv preprint arXiv:1903.11239 (2019). [10] Zeng, Andy, Shuran Song, Kuan-Ting Yu, Elliott Donlon, Francois R. Hogan, Maria Bauza, Daolin Ma et al. \"Robotic pick-and-place of novel objects in clutter with multi-affordance grasping and cross-domain image matching.\" In 2018 IEEE international conference on robotics and automation (ICRA), pp. 1-8. IEEE, 2018.","title":"References"},{"location":"stretch-ros/stretch_funmap/#license","text":"For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"License"},{"location":"stretch-ros/stretch_funmap/LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains software for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. This software is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License v3.0 (GNU LGPLv3) as published by the Free Software Foundation. This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License v3.0 (GNU LGPLv3) for more details, which can be found via the following link: https://www.gnu.org/licenses/lgpl-3.0.en.html For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"stretch-ros/stretch_gazebo/","text":"Overview stretch_gazebo is an implementation of simulating a Stretch robot with Gazebo simulator. Details The urdf directory contains a xacro file that extends the capabilities of the original xacro files living in stretch_description package to include Gazebo functionality. The config directory contains rviz files and ros_control controller configuration files for various parts of the robot including: Base: diff_drive_controller/DiffDriveController Arm: position_controllers/JointTrajectoryController Gripper: position_controllers/JointTrajectoryController Head: position_controllers/JointTrajectoryController Joints: joint_state_controller/JointStateController The launch directory includes two files: gazebo.launch: Opens up an empty Gazebo world and spawns the robot loading all the controllers, including all the sensors except Cliff sensors and respeaker. teleop_keyboard.launch: Allows keyboard teleop in the terminal and remaps cmd_vel topics to /stretch_diff_drive_controller/cmd_vel , which the robot is taking velocity commands from. teleop_joy.launch: Spawns a joy and teleop_twist_joy instance and remaps cmd_vel topics to /stretch_diff_drive_controller/cmd_vel , which the robot is taking velocity commands from. Note that the teleop_twist_joy package has a deadman switch by default which disables the drive commands to be published unless it is being pressed. For an Logitech F310 joystick this button is A. The script directory contains a single python file that publishes ground truth odometry of the robot from Gazebo. Setup These set up instructions will not be required on newly shipped robots. Follow these instructions if stretch_gazebo is not present in your ROS workspace or you are simulating Stretch on external hardware. Clone stretch_ros and realsense_gazebo_plugin packages to your catkin workspace. Then install dependencies and build the packages, with the following set of commands: mkdir -p ~/catkin_ws/src cd ~/catkin_ws/src git clone https://github.com/hello-robot/stretch_ros git clone https://github.com/pal-robotics/realsense_gazebo_plugin cd ~/catkin_ws rosdep install --from-paths src --ignore-src -r -y catkin_make In order to use the built packages, make the packages discoverable by sourcing the ROS workspace: source ~/catkin_ws/devel/setup.bash . It is popular to add the sourcing command to your ~/.bashrc file, so that the ROS packages are discoverable in every new terminal that is opened. Running Demo # Terminal 1: roslaunch stretch_gazebo gazebo.launch rviz: = true # Terminal 2: roslaunch stretch_core teleop_twist.launch twist_topic: = /stretch_diff_drive_controller/cmd_vel linear: = 1 .0 angular: = 2 .0 teleop_type: = keyboard # or use teleop_type:=joystick if you have a controller This will launch an Rviz instance that visualizes the sensors and an empty world in Gazebo with Stretch and load all the controllers. Although, the base will be able to move with the joystick commands, the joystick won't give joint commands to arm, head or gripper. To move these joints see the next section about Running Gazebo with MoveIt! and Stretch . Running Gazebo with MoveIt! and Stretch # Terminal 1: roslaunch stretch_gazebo gazebo.launch # Terminal 2: roslaunch stretch_core teleop_twist.launch twist_topic: = /stretch_diff_drive_controller/cmd_vel linear: = 1 .0 angular: = 2 .0 teleop_type: = keyboard # or use teleop_type:=joystick if you have a controller # Terminal 3 roslaunch stretch_moveit_config demo_gazebo.launch This will launch an Rviz instance that visualizes the joints with markers and an empty world in Gazebo with Stretch and load all the controllers. There are pre-defined positions for each joint group for demonstration purposes. There are three joint groups, namely stretch_arm , stretch_gripper and stretch_head that can be controlled individually via Motion Planning Rviz plugin. Start and goal positions for joints can be selected similar to this moveit tutorial . A few notes to be kept in mind: Planning group can be changed via Planning Group drop down in Planning tab of Motion Planning Rviz plugin. Pre-defined start and goal states can be specified in Start State and Goal State drop downs in Planning tab of Motion Planning Rviz plugin. stretch_gripper group does not show markers, and is intended to be controlled via the joints tab that is located in the very right of Motion Planning Rviz plugin. When planning with stretch_head group make sure you select Approx IK Solutions in Planning tab of Motion Planning Rviz plugin. Differences in Gazebo vs Stretch The simulated Stretch RE1 differs from the robot in the following ways. Gazebo Sensors vs Stretch Sensors Sensor Gazebo Stretch Notes LIDAR :heavy_check_mark: :heavy_check_mark: Base IMU :heavy_check_mark: :heavy_check_mark: Wrist Accelerometer :heavy_check_mark: :heavy_check_mark: Modeled as an IMU Realsense D435i :heavy_check_mark: :heavy_check_mark: Respeaker (Mic Array) :x: :heavy_check_mark: Cliff Sensors :x: :heavy_check_mark: Notes: Although there is no microphone in Gazebo, Respeaker can be represented with a ROS node that accesses compputer's microphone. Cliff sensors are not modeled but they can also be represented as 1D LIDAR sensors. See LIDAR definition in stretch_gazebo.urdf.xacro file. MoveIt Controllers vs stretch_core Actuators are defined as ros_control transmission objects in Gazebo using PositionJointInterfaces . MoveIt is configured to use three different action servers to control the body parts of stretch in Gazebo through the srdf file in stretch_moveit_config package. See the section above about MoveIt for details. Please note that this behavior is different than stretch_core as it works with a single Python interface to control all the joints. Uncalibrated XACRO vs Calibrated URDF We provide stretch_calibration to generate a calibrated URDF that is unique to each robot. The calibrated URDF is generated from the nominal description of Stretch RE1, the xacro files that live in stretch_description . The simulated Stretch RE1 is generated from the gazebo xacro description in the urdf directory and is not calibrated. License For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"stretch_gazebo"},{"location":"stretch-ros/stretch_gazebo/#overview","text":"stretch_gazebo is an implementation of simulating a Stretch robot with Gazebo simulator.","title":"Overview"},{"location":"stretch-ros/stretch_gazebo/#details","text":"The urdf directory contains a xacro file that extends the capabilities of the original xacro files living in stretch_description package to include Gazebo functionality. The config directory contains rviz files and ros_control controller configuration files for various parts of the robot including: Base: diff_drive_controller/DiffDriveController Arm: position_controllers/JointTrajectoryController Gripper: position_controllers/JointTrajectoryController Head: position_controllers/JointTrajectoryController Joints: joint_state_controller/JointStateController The launch directory includes two files: gazebo.launch: Opens up an empty Gazebo world and spawns the robot loading all the controllers, including all the sensors except Cliff sensors and respeaker. teleop_keyboard.launch: Allows keyboard teleop in the terminal and remaps cmd_vel topics to /stretch_diff_drive_controller/cmd_vel , which the robot is taking velocity commands from. teleop_joy.launch: Spawns a joy and teleop_twist_joy instance and remaps cmd_vel topics to /stretch_diff_drive_controller/cmd_vel , which the robot is taking velocity commands from. Note that the teleop_twist_joy package has a deadman switch by default which disables the drive commands to be published unless it is being pressed. For an Logitech F310 joystick this button is A. The script directory contains a single python file that publishes ground truth odometry of the robot from Gazebo.","title":"Details"},{"location":"stretch-ros/stretch_gazebo/#setup","text":"These set up instructions will not be required on newly shipped robots. Follow these instructions if stretch_gazebo is not present in your ROS workspace or you are simulating Stretch on external hardware. Clone stretch_ros and realsense_gazebo_plugin packages to your catkin workspace. Then install dependencies and build the packages, with the following set of commands: mkdir -p ~/catkin_ws/src cd ~/catkin_ws/src git clone https://github.com/hello-robot/stretch_ros git clone https://github.com/pal-robotics/realsense_gazebo_plugin cd ~/catkin_ws rosdep install --from-paths src --ignore-src -r -y catkin_make In order to use the built packages, make the packages discoverable by sourcing the ROS workspace: source ~/catkin_ws/devel/setup.bash . It is popular to add the sourcing command to your ~/.bashrc file, so that the ROS packages are discoverable in every new terminal that is opened.","title":"Setup"},{"location":"stretch-ros/stretch_gazebo/#running-demo","text":"# Terminal 1: roslaunch stretch_gazebo gazebo.launch rviz: = true # Terminal 2: roslaunch stretch_core teleop_twist.launch twist_topic: = /stretch_diff_drive_controller/cmd_vel linear: = 1 .0 angular: = 2 .0 teleop_type: = keyboard # or use teleop_type:=joystick if you have a controller This will launch an Rviz instance that visualizes the sensors and an empty world in Gazebo with Stretch and load all the controllers. Although, the base will be able to move with the joystick commands, the joystick won't give joint commands to arm, head or gripper. To move these joints see the next section about Running Gazebo with MoveIt! and Stretch .","title":"Running Demo"},{"location":"stretch-ros/stretch_gazebo/#running-gazebo-with-moveit-and-stretch","text":"# Terminal 1: roslaunch stretch_gazebo gazebo.launch # Terminal 2: roslaunch stretch_core teleop_twist.launch twist_topic: = /stretch_diff_drive_controller/cmd_vel linear: = 1 .0 angular: = 2 .0 teleop_type: = keyboard # or use teleop_type:=joystick if you have a controller # Terminal 3 roslaunch stretch_moveit_config demo_gazebo.launch This will launch an Rviz instance that visualizes the joints with markers and an empty world in Gazebo with Stretch and load all the controllers. There are pre-defined positions for each joint group for demonstration purposes. There are three joint groups, namely stretch_arm , stretch_gripper and stretch_head that can be controlled individually via Motion Planning Rviz plugin. Start and goal positions for joints can be selected similar to this moveit tutorial . A few notes to be kept in mind: Planning group can be changed via Planning Group drop down in Planning tab of Motion Planning Rviz plugin. Pre-defined start and goal states can be specified in Start State and Goal State drop downs in Planning tab of Motion Planning Rviz plugin. stretch_gripper group does not show markers, and is intended to be controlled via the joints tab that is located in the very right of Motion Planning Rviz plugin. When planning with stretch_head group make sure you select Approx IK Solutions in Planning tab of Motion Planning Rviz plugin.","title":"Running Gazebo with MoveIt! and Stretch"},{"location":"stretch-ros/stretch_gazebo/#differences-in-gazebo-vs-stretch","text":"The simulated Stretch RE1 differs from the robot in the following ways.","title":"Differences in Gazebo vs Stretch"},{"location":"stretch-ros/stretch_gazebo/#gazebo-sensors-vs-stretch-sensors","text":"Sensor Gazebo Stretch Notes LIDAR :heavy_check_mark: :heavy_check_mark: Base IMU :heavy_check_mark: :heavy_check_mark: Wrist Accelerometer :heavy_check_mark: :heavy_check_mark: Modeled as an IMU Realsense D435i :heavy_check_mark: :heavy_check_mark: Respeaker (Mic Array) :x: :heavy_check_mark: Cliff Sensors :x: :heavy_check_mark: Notes: Although there is no microphone in Gazebo, Respeaker can be represented with a ROS node that accesses compputer's microphone. Cliff sensors are not modeled but they can also be represented as 1D LIDAR sensors. See LIDAR definition in stretch_gazebo.urdf.xacro file.","title":"Gazebo Sensors vs Stretch Sensors"},{"location":"stretch-ros/stretch_gazebo/#moveit-controllers-vs-stretch_core","text":"Actuators are defined as ros_control transmission objects in Gazebo using PositionJointInterfaces . MoveIt is configured to use three different action servers to control the body parts of stretch in Gazebo through the srdf file in stretch_moveit_config package. See the section above about MoveIt for details. Please note that this behavior is different than stretch_core as it works with a single Python interface to control all the joints.","title":"MoveIt Controllers vs stretch_core"},{"location":"stretch-ros/stretch_gazebo/#uncalibrated-xacro-vs-calibrated-urdf","text":"We provide stretch_calibration to generate a calibrated URDF that is unique to each robot. The calibrated URDF is generated from the nominal description of Stretch RE1, the xacro files that live in stretch_description . The simulated Stretch RE1 is generated from the gazebo xacro description in the urdf directory and is not calibrated.","title":"Uncalibrated XACRO vs Calibrated URDF"},{"location":"stretch-ros/stretch_gazebo/#license","text":"For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"License"},{"location":"stretch-ros/stretch_gazebo/LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains software for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents are licensed under the Apache License, Version 2.0 (the \"License\"). You may not use the Contents except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, the Contents are distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"stretch-ros/stretch_moveit_config/","text":"Stretch & MoveIt! MoveIt is the standard ROS manipulation platform, and this package is the configuration for working with Stretch with the MoveIt framework. Offline Demo To experiment with the planning capabilities of MoveIt on Stretch, you can run a demo without Stretch hardware. roslaunch stretch_moveit_config demo.launch This will allow you to move the robot around using interactive markers and create plans between poses. Hardware Integration There is no planned support to run MoveIt on Stretch hardware. Instead, support for running MoveIt 2 (the successor to MoveIt) on Stretch hardware is being developed in Stretch's ROS2 packages . The primary reason to support MoveIt 2 instead of MoveIt 1 is because MoveIt 2 introduces planning for differential drive bases, whereas MoveIt 1 does not have this ability. Manipulation with Stretch is more capable when the mobile base is included. Please keep an eye on Stretch's ROS2 packages and our forum to track the state of Stretch + MoveIt 2 support. License For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"stretch_moveit_config"},{"location":"stretch-ros/stretch_moveit_config/#stretch-moveit","text":"MoveIt is the standard ROS manipulation platform, and this package is the configuration for working with Stretch with the MoveIt framework.","title":"Stretch &amp; MoveIt!"},{"location":"stretch-ros/stretch_moveit_config/#offline-demo","text":"To experiment with the planning capabilities of MoveIt on Stretch, you can run a demo without Stretch hardware. roslaunch stretch_moveit_config demo.launch This will allow you to move the robot around using interactive markers and create plans between poses.","title":"Offline Demo"},{"location":"stretch-ros/stretch_moveit_config/#hardware-integration","text":"There is no planned support to run MoveIt on Stretch hardware. Instead, support for running MoveIt 2 (the successor to MoveIt) on Stretch hardware is being developed in Stretch's ROS2 packages . The primary reason to support MoveIt 2 instead of MoveIt 1 is because MoveIt 2 introduces planning for differential drive bases, whereas MoveIt 1 does not have this ability. Manipulation with Stretch is more capable when the mobile base is included. Please keep an eye on Stretch's ROS2 packages and our forum to track the state of Stretch + MoveIt 2 support.","title":"Hardware Integration"},{"location":"stretch-ros/stretch_moveit_config/#license","text":"For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"License"},{"location":"stretch-ros/stretch_moveit_config/LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains software for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents are licensed under the Apache License, Version 2.0 (the \"License\"). You may not use the Contents except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, the Contents are distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"stretch-ros/stretch_navigation/","text":"Overview stretch_navigation provides the standard ROS navigation stack as two launch files. This package utilizes gmapping, move_base, and AMCL to drive the stretch RE1 around a mapped space. Running this code will require the robot to be untethered. Setup These set up instructions are already performed on Stretch RE1 robots. Follow these instructions if stretch_navigation is not present in your ROS workspace or you are simulating Stretch on external hardware. Clone stretch_ros to your catkin workspace. Then install dependencies and build the packages, with the following set of commands: mkdir -p ~/catkin_ws/src cd ~/catkin_ws/src git clone https://github.com/hello-robot/stretch_ros cd ~/catkin_ws rosdep install --from-paths src --ignore-src -r -y catkin_make Quickstart The first step is to map the space that the robot will navigate in. The mapping.launch will enable you to do this. First run: roslaunch stretch_navigation mapping.launch Rviz will show the robot and the map that is being constructed. With the terminal open, use the instructions printed by the teleop package to teleoperate the robot around the room. Avoid sharp turns and revisit previously visited spots to form loop closures. In Rviz, once you see a map that has reconstructed the space well enough, you can run the following commands to save the map to stretch_user/ . mkdir -p ~/stretch_user/maps rosrun map_server map_saver -f ${ HELLO_FLEET_PATH } /maps/<map_name> The <map_name> does not include an extension. Map_saver will save two files as <map_name>.pgm and <map_name>.yaml . Next, with <map_name>.yaml , we can navigate the robot around the mapped space. Run: roslaunch stretch_navigation navigation.launch map_yaml: = ${ HELLO_FLEET_PATH } /maps/<map_name>.yaml Rviz will show the robot in the previously mapped space, however, it's likely that the robot's location in the map does not match the robot's location in the real space. In the top bar of Rviz, use 2D Pose Estimate to lay an arrow down roughly where the robot is located in the real space. AMCL, the localization package, will better localize our pose once we give the robot a 2D Nav Goal. In the top bar of Rviz, use 2D Nav Goal to lay down an arrow where you'd like the robot to go. In the terminal, you'll see move_base go through the planning phases and then navigate the robot to the goal. If planning fails, the robot will begin a recovery behavior: spinning around 360 degrees in place. It is also possible to send 2D Pose Estimates and Nav Goals programatically. In your own launch file, you may include navigation.launch to bring up the navigation stack. Then, you can send move_base_msgs::MoveBaseGoal messages in order to navigate the robot programatically. Running in Simulation To perform mapping and navigation in the Gazebo simulation of Stretch, substitute the mapping_gazebo.launch and navigation_gazebo.launch launch files into the commands above. The default Gazebo environment is the Willow Garage HQ. Use the \"world\" ROS argument to specify the Gazebo world within which to spawn Stretch. roslaunch stretch_navigation mapping_gazebo.launch gazebo_world: = worlds/willowgarage.world Teleop using a Joystick Controller The mapping launch files, mapping.launch and mapping_gazebo.launch expose the ROS argument, \"teleop_type\". By default, this ROS arg is set to \"keyboard\", which launches keyboard teleop in the terminal. If the xbox controller that ships with Stretch RE1 is plugged into your computer, the following command will launch mapping with joystick teleop: roslaunch stretch_navigation mapping.launch teleop_type: = joystick Using ROS Remote Master If you have set up ROS Remote Master for untethered operation , you can use Rviz and teleop locally with the following commands: # On Robot roslaunch stretch_navigation mapping.launch rviz: = false teleop_type: = none # On your machine, Terminal 1: rviz -d ` rospack find stretch_navigation ` /rviz/mapping.launch # On your machine, Terminal 2: roslaunch stretch_core teleop_twist.launch teleop_type: = keyboard # or use teleop_type:=joystick if you have a controller License For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"stretch_navigation"},{"location":"stretch-ros/stretch_navigation/#overview","text":"stretch_navigation provides the standard ROS navigation stack as two launch files. This package utilizes gmapping, move_base, and AMCL to drive the stretch RE1 around a mapped space. Running this code will require the robot to be untethered.","title":"Overview"},{"location":"stretch-ros/stretch_navigation/#setup","text":"These set up instructions are already performed on Stretch RE1 robots. Follow these instructions if stretch_navigation is not present in your ROS workspace or you are simulating Stretch on external hardware. Clone stretch_ros to your catkin workspace. Then install dependencies and build the packages, with the following set of commands: mkdir -p ~/catkin_ws/src cd ~/catkin_ws/src git clone https://github.com/hello-robot/stretch_ros cd ~/catkin_ws rosdep install --from-paths src --ignore-src -r -y catkin_make","title":"Setup"},{"location":"stretch-ros/stretch_navigation/#quickstart","text":"The first step is to map the space that the robot will navigate in. The mapping.launch will enable you to do this. First run: roslaunch stretch_navigation mapping.launch Rviz will show the robot and the map that is being constructed. With the terminal open, use the instructions printed by the teleop package to teleoperate the robot around the room. Avoid sharp turns and revisit previously visited spots to form loop closures. In Rviz, once you see a map that has reconstructed the space well enough, you can run the following commands to save the map to stretch_user/ . mkdir -p ~/stretch_user/maps rosrun map_server map_saver -f ${ HELLO_FLEET_PATH } /maps/<map_name> The <map_name> does not include an extension. Map_saver will save two files as <map_name>.pgm and <map_name>.yaml . Next, with <map_name>.yaml , we can navigate the robot around the mapped space. Run: roslaunch stretch_navigation navigation.launch map_yaml: = ${ HELLO_FLEET_PATH } /maps/<map_name>.yaml Rviz will show the robot in the previously mapped space, however, it's likely that the robot's location in the map does not match the robot's location in the real space. In the top bar of Rviz, use 2D Pose Estimate to lay an arrow down roughly where the robot is located in the real space. AMCL, the localization package, will better localize our pose once we give the robot a 2D Nav Goal. In the top bar of Rviz, use 2D Nav Goal to lay down an arrow where you'd like the robot to go. In the terminal, you'll see move_base go through the planning phases and then navigate the robot to the goal. If planning fails, the robot will begin a recovery behavior: spinning around 360 degrees in place. It is also possible to send 2D Pose Estimates and Nav Goals programatically. In your own launch file, you may include navigation.launch to bring up the navigation stack. Then, you can send move_base_msgs::MoveBaseGoal messages in order to navigate the robot programatically.","title":"Quickstart"},{"location":"stretch-ros/stretch_navigation/#running-in-simulation","text":"To perform mapping and navigation in the Gazebo simulation of Stretch, substitute the mapping_gazebo.launch and navigation_gazebo.launch launch files into the commands above. The default Gazebo environment is the Willow Garage HQ. Use the \"world\" ROS argument to specify the Gazebo world within which to spawn Stretch. roslaunch stretch_navigation mapping_gazebo.launch gazebo_world: = worlds/willowgarage.world","title":"Running in Simulation"},{"location":"stretch-ros/stretch_navigation/#teleop-using-a-joystick-controller","text":"The mapping launch files, mapping.launch and mapping_gazebo.launch expose the ROS argument, \"teleop_type\". By default, this ROS arg is set to \"keyboard\", which launches keyboard teleop in the terminal. If the xbox controller that ships with Stretch RE1 is plugged into your computer, the following command will launch mapping with joystick teleop: roslaunch stretch_navigation mapping.launch teleop_type: = joystick","title":"Teleop using a Joystick Controller"},{"location":"stretch-ros/stretch_navigation/#using-ros-remote-master","text":"If you have set up ROS Remote Master for untethered operation , you can use Rviz and teleop locally with the following commands: # On Robot roslaunch stretch_navigation mapping.launch rviz: = false teleop_type: = none # On your machine, Terminal 1: rviz -d ` rospack find stretch_navigation ` /rviz/mapping.launch # On your machine, Terminal 2: roslaunch stretch_core teleop_twist.launch teleop_type: = keyboard # or use teleop_type:=joystick if you have a controller","title":"Using ROS Remote Master"},{"location":"stretch-ros/stretch_navigation/#license","text":"For license information, please see the LICENSE files. All materials are Copyright 2022 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"License"},{"location":"stretch-ros/stretch_navigation/LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains software for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents are licensed under the Apache License, Version 2.0 (the \"License\"). You may not use the Contents except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, the Contents are distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"stretch-tool-share/","text":"Overview We designed Stretch's hardware to be easily extended. You can make your own tool and attach it to the wrist to creatively expand what the Stretch RE1 can do. Your tool can also use Dynamixel X-series servos from Robotis via the provided TTL bus. In this repository, we provide examples of tools that we've created. We've released them with a permissive Apache 2.0 license, so you're free to use them as you wish. We hope they'll inspire you to create your own tools. We also include URDF and mesh files for many of the tools in their stretch_description folder. See the Stretch ROS documentation for guidance on integrating these tools into your robot model. We'd love it if you shared your creations with the community. We recommend you create a GitHub repository similar to this one for your own tools and then post an announcement to the forum to let people know about it. Tool Stretch Dex Wrist Stretch Teleop Kit Stretch Docking Station Stretch Dex Wrist Beta Wrist USB Board Camera Phone Holder V1 ReactorX Wrist V1 Dry Erase Holder V1 Swiffer Mount V1 Tray Cup Holder V1 Puller V1 Stretch RE1 Arm Stretch RE1 Head Licenses The contents in this repository that represent parts of the Stretch RE1 robot, such as its head, arm, wrist, and default gripper, are covered by the CC BY-NC-SA 4.0 license. Please note that the Stretch RE1 robot and its default gripper are also covered by pending patents. Please see the ROBOT_LICENSE file for details. Other contents in this repository created by Hello Robot Inc. that specifically pertain to the tools that attach to the Stretch RE1 as accessories are covered by the Apache 2.0 license. Please see the TOOL_LICENSE file for details. The contents of this repository are intended for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. For further information, including inquiries about dual licensing, please contact Hello Robot Inc.","title":"Overview"},{"location":"stretch-tool-share/#overview","text":"We designed Stretch's hardware to be easily extended. You can make your own tool and attach it to the wrist to creatively expand what the Stretch RE1 can do. Your tool can also use Dynamixel X-series servos from Robotis via the provided TTL bus. In this repository, we provide examples of tools that we've created. We've released them with a permissive Apache 2.0 license, so you're free to use them as you wish. We hope they'll inspire you to create your own tools. We also include URDF and mesh files for many of the tools in their stretch_description folder. See the Stretch ROS documentation for guidance on integrating these tools into your robot model. We'd love it if you shared your creations with the community. We recommend you create a GitHub repository similar to this one for your own tools and then post an announcement to the forum to let people know about it. Tool Stretch Dex Wrist Stretch Teleop Kit Stretch Docking Station Stretch Dex Wrist Beta Wrist USB Board Camera Phone Holder V1 ReactorX Wrist V1 Dry Erase Holder V1 Swiffer Mount V1 Tray Cup Holder V1 Puller V1 Stretch RE1 Arm Stretch RE1 Head","title":"Overview"},{"location":"stretch-tool-share/#licenses","text":"The contents in this repository that represent parts of the Stretch RE1 robot, such as its head, arm, wrist, and default gripper, are covered by the CC BY-NC-SA 4.0 license. Please note that the Stretch RE1 robot and its default gripper are also covered by pending patents. Please see the ROBOT_LICENSE file for details. Other contents in this repository created by Hello Robot Inc. that specifically pertain to the tools that attach to the Stretch RE1 as accessories are covered by the Apache 2.0 license. Please see the TOOL_LICENSE file for details. The contents of this repository are intended for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. For further information, including inquiries about dual licensing, please contact Hello Robot Inc.","title":"Licenses"},{"location":"stretch-tool-share/ROBOT_LICENSE/","text":"The following license applies to the entire contents of this directory that represent parts of the Stretch RE1 robot (the \"Robot Contents\"), such as the robot's head, arm, wrist, and default gripper. The Robot Contents consists of software and data for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Robot Contents are licensed under the Creative Commons Attribution-NonCommercial-ShareAlike-4.0-International (CC BY-NC-SA 4.0) license (the \"License\"); you may not use the Robot Contents except in compliance with the License. You may obtain a copy of the License at https://creativecommons.org/licenses/by-nc-sa/4.0/ Unless required by applicable law or agreed to in writing, the Robot Contents distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Patents pending and trademark rights cover the Robot Contents. As stated by the detailed License, \"Patent and trademark rights are not licensed under this Public License.\" For further information about the Robot Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"ROBOT LICENSE"},{"location":"stretch-tool-share/TOOL_LICENSE/","text":"The following license applies to the contents (the \"Tool Contents\") in this repository specific to tools created by Hello Robot Inc. that attach to the Stretch RE1 robot. This license explicitly excludes any contents covered by the license found in the ROBOT_LICENSE.md file. The Tool Contents does not include any part of the Stretch RE1 robot, such as its arm, wrist, or default gripper. The Tool Contents consists of software and data related to tools intended for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Tool Contents are licensed under the Apache License, Version 2.0 (the \"License\"). You may not use the Tool Contents except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, the Tool Contents are distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. For further information about the Tool Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"TOOL LICENSE"},{"location":"stretch-tool-share/python/LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains software for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents include free software and other kinds of works: you can redistribute them and/or modify them under the terms of the GNU General Public License v3.0 (GNU GPLv3) as published by the Free Software Foundation. The Contents are distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License v3.0 (GNU GPLv3) for more details, which can be found via the following link: https://www.gnu.org/licenses/gpl-3.0.html For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"stretch-tool-share/tool_share/dry_erase_holder_V1/","text":"Dry Erase Holder Created by : Hello Robot Inc This tool allows Stretch to hold a dry erase marker. It is spring loaded, allowing for compliant interaction between the marker and a white board. The tool can be integrated into your robot URDF by integrating its stretch_description as described in the Stretch ROS documentation . Parts List Item Qty Vendor Expo Dry Erase 1 Amazon M5x50mm Hex Head Bolt 1 McMaster-Carr M5 Nut 2 McMaster-Carr wrist_end_cap_5mm 1 PLA 3D Printer dry_erase_bushing_block 1 PLA 3D Printer Size 30 Rubber Band 2 McMaster-Carr 3/4\" Shaft Collar 1 McMaster-Carr Assembly instructions View 3D assembly Install the bolt into the dry_erase_bushing block and secure from below with an M5 nut. Attach the dry erase bushing block to the tool plate, securing from below with the wrist_end_cap_5mm and an M5 nut. Orient the block so the marker points forward. Attach the shaft collar to your dry erase marker, approximately 8mm from the back of the marker. Slide the marker into the bushing block. Loop a rubber band around the back of the marker and over to one of the pegs on the side of the bushing block. Repeat with the other peg. The marker should now easily spring back when pushed against. You're ready to write!","title":"Dry Erase Holder"},{"location":"stretch-tool-share/tool_share/dry_erase_holder_V1/#dry-erase-holder","text":"Created by : Hello Robot Inc This tool allows Stretch to hold a dry erase marker. It is spring loaded, allowing for compliant interaction between the marker and a white board. The tool can be integrated into your robot URDF by integrating its stretch_description as described in the Stretch ROS documentation .","title":"Dry Erase Holder"},{"location":"stretch-tool-share/tool_share/dry_erase_holder_V1/#parts-list","text":"Item Qty Vendor Expo Dry Erase 1 Amazon M5x50mm Hex Head Bolt 1 McMaster-Carr M5 Nut 2 McMaster-Carr wrist_end_cap_5mm 1 PLA 3D Printer dry_erase_bushing_block 1 PLA 3D Printer Size 30 Rubber Band 2 McMaster-Carr 3/4\" Shaft Collar 1 McMaster-Carr","title":"Parts List"},{"location":"stretch-tool-share/tool_share/dry_erase_holder_V1/#assembly-instructions","text":"View 3D assembly Install the bolt into the dry_erase_bushing block and secure from below with an M5 nut. Attach the dry erase bushing block to the tool plate, securing from below with the wrist_end_cap_5mm and an M5 nut. Orient the block so the marker points forward. Attach the shaft collar to your dry erase marker, approximately 8mm from the back of the marker. Slide the marker into the bushing block. Loop a rubber band around the back of the marker and over to one of the pegs on the side of the bushing block. Repeat with the other peg. The marker should now easily spring back when pushed against. You're ready to write!","title":"Assembly instructions"},{"location":"stretch-tool-share/tool_share/phone_holder_V1/","text":"Phone Holder Create by : Hello Robot Inc This tool allows you to attach a smart phone to your Stretch. It uses an off the shelf phone holder with and a photography standard 1/4-20 attachment post. Parts List Item Qty Vendor 1/4-20 x 3\" BHCS 1 McMaster-Carr 1/4-20 Nut 2 McMaster-Carr wrist_mount_spacer.STL 2 PLA 3D printer Ulanzi ST-01 Phone Tripod Mount 1 Amazon Assembly instructions View 3D assembly Install the two wrist_mount spacers onto wrist Install the long bolt and lock into place using the first nut. Friction will hold this in a fixed orientation. Install the second nut and then the phone mount, screwing onto the bolt Lock the phone mount into place, using the second nut as a jam nut If you want to adjust the phone orientation relative to the wrist yaw, loosen up the jam nut, adjust, then tighten.","title":"Phone Holder"},{"location":"stretch-tool-share/tool_share/phone_holder_V1/#phone-holder","text":"Create by : Hello Robot Inc This tool allows you to attach a smart phone to your Stretch. It uses an off the shelf phone holder with and a photography standard 1/4-20 attachment post.","title":"Phone Holder"},{"location":"stretch-tool-share/tool_share/phone_holder_V1/#parts-list","text":"Item Qty Vendor 1/4-20 x 3\" BHCS 1 McMaster-Carr 1/4-20 Nut 2 McMaster-Carr wrist_mount_spacer.STL 2 PLA 3D printer Ulanzi ST-01 Phone Tripod Mount 1 Amazon","title":"Parts List"},{"location":"stretch-tool-share/tool_share/phone_holder_V1/#assembly-instructions","text":"View 3D assembly Install the two wrist_mount spacers onto wrist Install the long bolt and lock into place using the first nut. Friction will hold this in a fixed orientation. Install the second nut and then the phone mount, screwing onto the bolt Lock the phone mount into place, using the second nut as a jam nut If you want to adjust the phone orientation relative to the wrist yaw, loosen up the jam nut, adjust, then tighten.","title":"Assembly instructions"},{"location":"stretch-tool-share/tool_share/puller_v1/","text":"Puller Create by : Hello Robot Inc This is a a simple 'puller' attachment for the Stretch Compliant Gripper. We've used it to pull open many common drawers, cabinet doors, and even a mini-fridge door. You can also use it to push things closed, such as drawers. You can think of it as a circular hook used to pull things or a finger used to push things. It attaches to the 6-32 stud on the side of the gripper. By turning the gripper sideways during manipulation, the hook can drop over the drawer handle, allowing the arm to retract and pull the door open. Parts List Item Qty Vendor 6-32 x 0.5\" BHCS 1 McMaster-Carr 6-32 x 1\" aluminum threaded standoff 1 McMaster-Carr Puller_V1.STL 1 PLA 3D printer Assembly instructions View 3D assembly Screw the standoff on to the gripper's threaded post. Secure tightly and add a drop of light duty Loctite if desired. Attach the plastic pull to the standoff using the BHCS.","title":"Puller"},{"location":"stretch-tool-share/tool_share/puller_v1/#puller","text":"Create by : Hello Robot Inc This is a a simple 'puller' attachment for the Stretch Compliant Gripper. We've used it to pull open many common drawers, cabinet doors, and even a mini-fridge door. You can also use it to push things closed, such as drawers. You can think of it as a circular hook used to pull things or a finger used to push things. It attaches to the 6-32 stud on the side of the gripper. By turning the gripper sideways during manipulation, the hook can drop over the drawer handle, allowing the arm to retract and pull the door open.","title":"Puller"},{"location":"stretch-tool-share/tool_share/puller_v1/#parts-list","text":"Item Qty Vendor 6-32 x 0.5\" BHCS 1 McMaster-Carr 6-32 x 1\" aluminum threaded standoff 1 McMaster-Carr Puller_V1.STL 1 PLA 3D printer","title":"Parts List"},{"location":"stretch-tool-share/tool_share/puller_v1/#assembly-instructions","text":"View 3D assembly Screw the standoff on to the gripper's threaded post. Secure tightly and add a drop of light duty Loctite if desired. Attach the plastic pull to the standoff using the BHCS.","title":"Assembly instructions"},{"location":"stretch-tool-share/tool_share/reactorx_wrist_V1/","text":"Reactor X Wrist Created by : Hello Robot Inc Here we describe how to modify an Interbotx ReactorX 150 Dynamixel arm to add a Pitch-Roll wrist plus parallel jaw gripper to Stretch, giving you a Yaw-Pitch-Roll wrist! The ReactorX 150 comes standard with Dynamixel XM430-W350-T servos for the shoulder joints and XL430-W250-T servos for its wrist and gripper. We're going to disassemble the arm and then rebuild it so that the Pitch and Roll DOF use the stronger XM430-W350-T servos. View the 3D assembly Parts List Item Qty Vendor ReactorX 150 Robot Arm 1 Trossen Robotics Robotis FR12-S101K Frame 1 Robotis M2x4mm SHCS 10 McMaster Carr Wrist Build Start with a ReactorX 150 Detach the the wrist unit from the arm. This includes the final pitch / roll /gripper DOFs with the XL430 servos. Remove the XM430 servos from the shoulder of the arm. The XM430s have the metal horns as shown. No replace the pitch and roll servos with the XM430s. Pay attention to how the cables route and which ports they plug into so you can recable the wrist correctly. To attach the two side plates to the pitch servo (above, right), you'll want to use the shorter M2x4mm screws. The ones that came off of the XL430s are too long and will cause the servo to bind up if used. Recable the servos and attach the pitch and roll joints to the gripper. You're done! Other Modifications The FR12-S101K frame doesn't allow a X-Series TTL connector to pass through by default. You will need to drill out one of the 8mm holes on a drill press to 10mm. This will allow the cable routing to go through the center of Wrist Yaw rotation (recommended) Dynamixel Configuration The Dynamixel servos that come with the Reactor arm need to be reprogrammed with the correct IDs and baudrate. Out of the box, the Reactor servos use a baudrate of 1Mbps while Stretch requires 57600Kbps. To reconfigure the servos: Download and install the Dynamixel Wizard 2.0 from Robotis Attach your 3 DOF gripper-wrist to a PC using a U2D2 adapter from Robotis Launch the Wizard and click Scan. It should identify the three servos. Select each servo from the left hand drop down menu and set its baudrate and ID. Hit save. By convention we use Dynamixel IDs of: Wrist PITCH: 14 Wrist ROLL: 15 Gripper: 16 Assembly instructions Now attach your wrist to the Stretch tool plate using the Robotis Frame and their provided hardware, as shown above. Code You're ready to start using your wrist. You will want to add the wrist YAML to your copy of stretch_re1_user_params.yaml . See the demo code here to test drive your wrist.","title":"ReactorX Wrist"},{"location":"stretch-tool-share/tool_share/reactorx_wrist_V1/#reactor-x-wrist","text":"Created by : Hello Robot Inc Here we describe how to modify an Interbotx ReactorX 150 Dynamixel arm to add a Pitch-Roll wrist plus parallel jaw gripper to Stretch, giving you a Yaw-Pitch-Roll wrist! The ReactorX 150 comes standard with Dynamixel XM430-W350-T servos for the shoulder joints and XL430-W250-T servos for its wrist and gripper. We're going to disassemble the arm and then rebuild it so that the Pitch and Roll DOF use the stronger XM430-W350-T servos. View the 3D assembly","title":"Reactor X Wrist"},{"location":"stretch-tool-share/tool_share/reactorx_wrist_V1/#parts-list","text":"Item Qty Vendor ReactorX 150 Robot Arm 1 Trossen Robotics Robotis FR12-S101K Frame 1 Robotis M2x4mm SHCS 10 McMaster Carr","title":"Parts List"},{"location":"stretch-tool-share/tool_share/reactorx_wrist_V1/#wrist-build","text":"Start with a ReactorX 150 Detach the the wrist unit from the arm. This includes the final pitch / roll /gripper DOFs with the XL430 servos. Remove the XM430 servos from the shoulder of the arm. The XM430s have the metal horns as shown. No replace the pitch and roll servos with the XM430s. Pay attention to how the cables route and which ports they plug into so you can recable the wrist correctly. To attach the two side plates to the pitch servo (above, right), you'll want to use the shorter M2x4mm screws. The ones that came off of the XL430s are too long and will cause the servo to bind up if used. Recable the servos and attach the pitch and roll joints to the gripper. You're done!","title":"Wrist Build"},{"location":"stretch-tool-share/tool_share/reactorx_wrist_V1/#other-modifications","text":"The FR12-S101K frame doesn't allow a X-Series TTL connector to pass through by default. You will need to drill out one of the 8mm holes on a drill press to 10mm. This will allow the cable routing to go through the center of Wrist Yaw rotation (recommended)","title":"Other Modifications"},{"location":"stretch-tool-share/tool_share/reactorx_wrist_V1/#dynamixel-configuration","text":"The Dynamixel servos that come with the Reactor arm need to be reprogrammed with the correct IDs and baudrate. Out of the box, the Reactor servos use a baudrate of 1Mbps while Stretch requires 57600Kbps. To reconfigure the servos: Download and install the Dynamixel Wizard 2.0 from Robotis Attach your 3 DOF gripper-wrist to a PC using a U2D2 adapter from Robotis Launch the Wizard and click Scan. It should identify the three servos. Select each servo from the left hand drop down menu and set its baudrate and ID. Hit save. By convention we use Dynamixel IDs of: Wrist PITCH: 14 Wrist ROLL: 15 Gripper: 16","title":"Dynamixel Configuration"},{"location":"stretch-tool-share/tool_share/reactorx_wrist_V1/#assembly-instructions","text":"Now attach your wrist to the Stretch tool plate using the Robotis Frame and their provided hardware, as shown above.","title":"Assembly instructions"},{"location":"stretch-tool-share/tool_share/reactorx_wrist_V1/#code","text":"You're ready to start using your wrist. You will want to add the wrist YAML to your copy of stretch_re1_user_params.yaml . See the demo code here to test drive your wrist.","title":"Code"},{"location":"stretch-tool-share/tool_share/stretch_RE1_arm/","text":"Stretch RE1 Arm Model Created by : Hello Robot Inc This is an STL model of the Stretch RE1 arm (retracted) including the end-of-arm interface. It can assist the design of your own tools for your Stretch. Files Stretch_RE1_Arm.STL","title":"Stretch RE1 Arm"},{"location":"stretch-tool-share/tool_share/stretch_RE1_arm/#stretch-re1-arm-model","text":"Created by : Hello Robot Inc This is an STL model of the Stretch RE1 arm (retracted) including the end-of-arm interface. It can assist the design of your own tools for your Stretch. Files Stretch_RE1_Arm.STL","title":"Stretch RE1 Arm Model"},{"location":"stretch-tool-share/tool_share/stretch_RE1_head/","text":"Stretch RE1 Head Model Created by : Hello Robot Inc These are STL models of the Stretch RE1 head shells. They can assist the design of your own tools to attach to Stretch's head. These shells can be printed in PLA using an FDM printer. The heat set inserts use McMaster Carr part number 94180A321. Files Stretch_RE1_Head_Left.STL Stretch_RE1_Head_Right.STL Stretch_RE1_Head_Camera.STL","title":"Index"},{"location":"stretch-tool-share/tool_share/stretch_RE1_head/#stretch-re1-head-model","text":"Created by : Hello Robot Inc These are STL models of the Stretch RE1 head shells. They can assist the design of your own tools to attach to Stretch's head. These shells can be printed in PLA using an FDM printer. The heat set inserts use McMaster Carr part number 94180A321. Files Stretch_RE1_Head_Left.STL Stretch_RE1_Head_Right.STL Stretch_RE1_Head_Camera.STL","title":"Stretch RE1 Head Model"},{"location":"stretch-tool-share/tool_share/stretch_dex_wrist/gazebo_support/","text":"Stretch Dex Wrist - Gazebo Support Created by : Hello Robot Inc The Stretch RE1 robot with the Dex Wrist can also be simulated with Gazebo simulator. The information on Stretch robot's Gazebo implementation can be found here stretch_gazebo . To add the Dex Wrist to Stretch with Gazebo support: cd ~/catkin_ws/src/stretch_ros/ git pull cd ~/repos git clone https://github.com/hello-robot/stretch_tool_share cd stretch_tool_share/tool_share/stretch_dex_wrist cp stretch_description/urdf/stretch_dex_wrist.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf cp stretch_description/urdf/stretch_description.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf cp stretch_description/meshes/*.STL ~/catkin_ws/src/stretch_ros/stretch_description/meshes cp gazebo_support/stretch_gazebo.urdf.xacro ~/catkin_ws/src/stretch_ros/stretch_gazebo/urdf cp gazebo_support/dex_wrist.yaml ~/catkin_ws/src/stretch_ros/stretch_gazebo/config cp gazebo_support/cp gazebo.launch ~/catkin_ws/src/stretch_ros/stretch_gazebo/launch During the Gazebo simulation with Dex Wrist, the wrist's Roll and Pitch can be controlled using the spawned \"stretch_dex_wrist_controller\" of type position_controllers/JointTrajectoryController Note : Still there is no planned support to run MoveIt with Stretch Dex Wrist in Gazebo.","title":"Index"},{"location":"stretch-tool-share/tool_share/stretch_dex_wrist/gazebo_support/#stretch-dex-wrist-gazebo-support","text":"Created by : Hello Robot Inc The Stretch RE1 robot with the Dex Wrist can also be simulated with Gazebo simulator. The information on Stretch robot's Gazebo implementation can be found here stretch_gazebo . To add the Dex Wrist to Stretch with Gazebo support: cd ~/catkin_ws/src/stretch_ros/ git pull cd ~/repos git clone https://github.com/hello-robot/stretch_tool_share cd stretch_tool_share/tool_share/stretch_dex_wrist cp stretch_description/urdf/stretch_dex_wrist.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf cp stretch_description/urdf/stretch_description.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf cp stretch_description/meshes/*.STL ~/catkin_ws/src/stretch_ros/stretch_description/meshes cp gazebo_support/stretch_gazebo.urdf.xacro ~/catkin_ws/src/stretch_ros/stretch_gazebo/urdf cp gazebo_support/dex_wrist.yaml ~/catkin_ws/src/stretch_ros/stretch_gazebo/config cp gazebo_support/cp gazebo.launch ~/catkin_ws/src/stretch_ros/stretch_gazebo/launch During the Gazebo simulation with Dex Wrist, the wrist's Roll and Pitch can be controlled using the spawned \"stretch_dex_wrist_controller\" of type position_controllers/JointTrajectoryController Note : Still there is no planned support to run MoveIt with Stretch Dex Wrist in Gazebo.","title":"Stretch Dex Wrist - Gazebo Support"},{"location":"stretch-tool-share/tool_share/stretch_docking_station/","text":"Stretch Docking Station Created by : Hello Robot Inc Overview The Stretch Docking Station provides automated charging of Stretch. A 110mm Aruco tag on the docking station allows the robot to accomplish visually guided docking. Hardware Coming soon. Assembly Coming soon. Software Coming soon. ROS Support URDF The Stretch Docking Station, can be included in Gazebo and RViz. The URDF data is available on the Stretch Tool Share . x Gazebo Coming soon.","title":"Stretch Docking Station"},{"location":"stretch-tool-share/tool_share/stretch_docking_station/#stretch-docking-station","text":"Created by : Hello Robot Inc","title":"Stretch Docking Station"},{"location":"stretch-tool-share/tool_share/stretch_docking_station/#overview","text":"The Stretch Docking Station provides automated charging of Stretch. A 110mm Aruco tag on the docking station allows the robot to accomplish visually guided docking.","title":"Overview"},{"location":"stretch-tool-share/tool_share/stretch_docking_station/#hardware","text":"Coming soon.","title":"Hardware"},{"location":"stretch-tool-share/tool_share/stretch_docking_station/#assembly","text":"Coming soon.","title":"Assembly"},{"location":"stretch-tool-share/tool_share/stretch_docking_station/#software","text":"Coming soon.","title":"Software"},{"location":"stretch-tool-share/tool_share/stretch_docking_station/#ros-support","text":"","title":"ROS Support"},{"location":"stretch-tool-share/tool_share/stretch_docking_station/#urdf","text":"The Stretch Docking Station, can be included in Gazebo and RViz. The URDF data is available on the Stretch Tool Share . x","title":"URDF"},{"location":"stretch-tool-share/tool_share/stretch_docking_station/#gazebo","text":"Coming soon.","title":"Gazebo"},{"location":"stretch-tool-share/tool_share/stretch_teleop_kit/","text":"Stretch Teleop Kit Created by : Hello Robot Inc Overview The Stretch Teleop Kit allows for improved remote teleoperation of Stretch. It adds two fish-eye USB cameras to Stretch. One is added to the robot's gripper for a better view while manipulating. The other is added to the robot's head and points downward, providing a better view while navigating. Hardware The Stretch Teleop Kit uses two Spinel UC20MPE_F185 USB cameras that provide a 185 degree FOV and 2MP resolution. These board cameras are mounted in 3D printed shells and attached to existing mount points of the Stretch. Assembly Hello Robot has provided the STL files, BOM, and assembly instructions necessary to build your own Stretch Teleop Kit. Alternatively, the kit is available for sale by Hello Robot . * Note if building your own kit: : The Spinel cameras come with a custom USB to JST ZH cable. We recommend using a custom length cable however in order to improve the cable routing of your system. Please contact Hello Robot for details. 3D Printed Parts 3DP-808_Teleop_Camera_Mount_Front.STL 3DP-809_Head_Teleop_Mount_Back.STL 3DP-810_Head_Teleop_Mount.STL 3DP-811_Gripper_Teleop_Mount_Back.STL 3DP-812_Gripper_Teleop_Mount_Bottom.STL Software Teleoperation Interface The Stretch Teleop Kit includes the open-source teleoperation interface (beta) that utilizes these cameras as shown below. ROS Support URDF The Stretch RE1 URDF can be augmented with these two cameras as well. The URDF information is found here . To add the Teleop Kit to your URDF: cd ~/catkin_ws/src/stretch_ros/ git pull cd ~/repos git clone https://github.com/hello-robot/stretch_tool_share cd ~/repos/stretch_tool_share/tool_share/stretch_teleop_kit/stretch_description cp urdf/stretch_teleop_kit.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf cp urdf/stretch_description.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf cp meshes/*teleop*.STL ~/catkin_ws/src/stretch_ros/stretch_description/meshes Gazebo The Stretch RE1 robot with the Teleop Kit can also be simulated with Gazebo simulator. The information on Stretch robot's Gazebo implementation can be found here stretch_gazebo . To add Teleop kit to the Stretch Gazebo implementation: cd ~/catkin_ws/src/stretch_ros/ git pull cd ~/repos git clone https://github.com/hello-robot/stretch_tool_share cd ~/repos/stretch_tool_share/tool_share/stretch_teleop_kit/stretch_description cp urdf/stretch_teleop_kit.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf cp urdf/stretch_gazebo.urdf.xacro ~/catkin_ws/src/stretch_ros/stretch_gazebo/urdf/stretch_gazebo.urdf.xacro cp meshes/*teleop*.STL ~/catkin_ws/src/stretch_ros/stretch_description/meshes During Gazebo simulation the two Teleop camera's video streams would be published to the topics \"teleop/gripper_camera\" and \"teleop/head_camera\".","title":"Index"},{"location":"stretch-tool-share/tool_share/stretch_teleop_kit/#stretch-teleop-kit","text":"Created by : Hello Robot Inc","title":"Stretch Teleop Kit"},{"location":"stretch-tool-share/tool_share/stretch_teleop_kit/#overview","text":"The Stretch Teleop Kit allows for improved remote teleoperation of Stretch. It adds two fish-eye USB cameras to Stretch. One is added to the robot's gripper for a better view while manipulating. The other is added to the robot's head and points downward, providing a better view while navigating.","title":"Overview"},{"location":"stretch-tool-share/tool_share/stretch_teleop_kit/#hardware","text":"The Stretch Teleop Kit uses two Spinel UC20MPE_F185 USB cameras that provide a 185 degree FOV and 2MP resolution. These board cameras are mounted in 3D printed shells and attached to existing mount points of the Stretch.","title":"Hardware"},{"location":"stretch-tool-share/tool_share/stretch_teleop_kit/#assembly","text":"Hello Robot has provided the STL files, BOM, and assembly instructions necessary to build your own Stretch Teleop Kit. Alternatively, the kit is available for sale by Hello Robot . * Note if building your own kit: : The Spinel cameras come with a custom USB to JST ZH cable. We recommend using a custom length cable however in order to improve the cable routing of your system. Please contact Hello Robot for details. 3D Printed Parts 3DP-808_Teleop_Camera_Mount_Front.STL 3DP-809_Head_Teleop_Mount_Back.STL 3DP-810_Head_Teleop_Mount.STL 3DP-811_Gripper_Teleop_Mount_Back.STL 3DP-812_Gripper_Teleop_Mount_Bottom.STL","title":"Assembly"},{"location":"stretch-tool-share/tool_share/stretch_teleop_kit/#software","text":"","title":"Software"},{"location":"stretch-tool-share/tool_share/stretch_teleop_kit/#teleoperation-interface","text":"The Stretch Teleop Kit includes the open-source teleoperation interface (beta) that utilizes these cameras as shown below.","title":"Teleoperation Interface"},{"location":"stretch-tool-share/tool_share/stretch_teleop_kit/#ros-support","text":"","title":"ROS Support"},{"location":"stretch-tool-share/tool_share/stretch_teleop_kit/#urdf","text":"The Stretch RE1 URDF can be augmented with these two cameras as well. The URDF information is found here . To add the Teleop Kit to your URDF: cd ~/catkin_ws/src/stretch_ros/ git pull cd ~/repos git clone https://github.com/hello-robot/stretch_tool_share cd ~/repos/stretch_tool_share/tool_share/stretch_teleop_kit/stretch_description cp urdf/stretch_teleop_kit.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf cp urdf/stretch_description.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf cp meshes/*teleop*.STL ~/catkin_ws/src/stretch_ros/stretch_description/meshes","title":"URDF"},{"location":"stretch-tool-share/tool_share/stretch_teleop_kit/#gazebo","text":"The Stretch RE1 robot with the Teleop Kit can also be simulated with Gazebo simulator. The information on Stretch robot's Gazebo implementation can be found here stretch_gazebo . To add Teleop kit to the Stretch Gazebo implementation: cd ~/catkin_ws/src/stretch_ros/ git pull cd ~/repos git clone https://github.com/hello-robot/stretch_tool_share cd ~/repos/stretch_tool_share/tool_share/stretch_teleop_kit/stretch_description cp urdf/stretch_teleop_kit.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf cp urdf/stretch_gazebo.urdf.xacro ~/catkin_ws/src/stretch_ros/stretch_gazebo/urdf/stretch_gazebo.urdf.xacro cp meshes/*teleop*.STL ~/catkin_ws/src/stretch_ros/stretch_description/meshes During Gazebo simulation the two Teleop camera's video streams would be published to the topics \"teleop/gripper_camera\" and \"teleop/head_camera\".","title":"Gazebo"},{"location":"stretch-tool-share/tool_share/swiffer_mount_V1/","text":"Swiffer Mount Created by : Hello Robot Inc This tool allows a Swiffer duster to your Stretch. The designs uses a clamp to hold the Swiffer handle in place, allowing the height and orientation of the Swiffer to be adjusted by loosening the clamp. Parts List Item Qty Vendor M5x50mm BHCS 3 McMaster-Carr M5 nut 4 McMaster-Carr swiffer_mount.STL 1 PLA 3D printer swiffer_mount_clamp.STL 1 PLA 3D printer wrist_end_cap_5mm.STL 1 PLA 3D printer Swiffer Sweeper Cleaner Dry and Wet Mop Kit 1 Amazon Assembly instructions View 3D Assembly Attach the M5 bolt through the swiffer_mount_primary part and lock into place by tightening the M5 nut Attach swiffer_mount_primary to the tool plate using the wrist_end_cap_5mm and a second M5 nut. Friction holds the assembly in place against the tool plate. Attach the swiffer_mount_clamp part using two M5 bolts and nuts, clamping the shaft of the Swiffer handle in place. Adjust the length and orientation of the Swiffer and clamp in place. Clean away!","title":"Swiffer Mount"},{"location":"stretch-tool-share/tool_share/swiffer_mount_V1/#swiffer-mount","text":"Created by : Hello Robot Inc This tool allows a Swiffer duster to your Stretch. The designs uses a clamp to hold the Swiffer handle in place, allowing the height and orientation of the Swiffer to be adjusted by loosening the clamp.","title":"Swiffer Mount"},{"location":"stretch-tool-share/tool_share/swiffer_mount_V1/#parts-list","text":"Item Qty Vendor M5x50mm BHCS 3 McMaster-Carr M5 nut 4 McMaster-Carr swiffer_mount.STL 1 PLA 3D printer swiffer_mount_clamp.STL 1 PLA 3D printer wrist_end_cap_5mm.STL 1 PLA 3D printer Swiffer Sweeper Cleaner Dry and Wet Mop Kit 1 Amazon","title":"Parts List"},{"location":"stretch-tool-share/tool_share/swiffer_mount_V1/#assembly-instructions","text":"View 3D Assembly Attach the M5 bolt through the swiffer_mount_primary part and lock into place by tightening the M5 nut Attach swiffer_mount_primary to the tool plate using the wrist_end_cap_5mm and a second M5 nut. Friction holds the assembly in place against the tool plate. Attach the swiffer_mount_clamp part using two M5 bolts and nuts, clamping the shaft of the Swiffer handle in place. Adjust the length and orientation of the Swiffer and clamp in place. Clean away!","title":"Assembly instructions"},{"location":"stretch-tool-share/tool_share/tray_cup_holder_V1/","text":"Tray Cup Holder Created by : Hello Robot Inc This is a tray and cup holder attachment for your Stretch. The tray stows nicely within the robot footprint during navigation and can un-stow upon delivery to a person. The 3D printed attachment clips easily onto the bottom of an off the shelf tray. Parts List Item Qty Vendor M5 Nut 2 McMaster-Carr M5x50mm Hex Head Bolt 1 McMaster-Carr wrist_end_cap_5mm.STL 1 PLA 3D printer tray_clip.STL 1 PLA 3D printer AUTUT Universal Car Cup Holder 1 Amazon Assembly instructions View 3D assembly Install the M5 bolt into the tray clip and secure it rigidly to the part using the M5 nut. Clip the tray onto the tray clip. Drop the tray clip assembly on to the tool plate from above. Secure it to the tool plate using the wrist_end_cap_5mm and M5 nut.","title":"Tray Cup Holder"},{"location":"stretch-tool-share/tool_share/tray_cup_holder_V1/#tray-cup-holder","text":"Created by : Hello Robot Inc This is a tray and cup holder attachment for your Stretch. The tray stows nicely within the robot footprint during navigation and can un-stow upon delivery to a person. The 3D printed attachment clips easily onto the bottom of an off the shelf tray.","title":"Tray Cup Holder"},{"location":"stretch-tool-share/tool_share/tray_cup_holder_V1/#parts-list","text":"Item Qty Vendor M5 Nut 2 McMaster-Carr M5x50mm Hex Head Bolt 1 McMaster-Carr wrist_end_cap_5mm.STL 1 PLA 3D printer tray_clip.STL 1 PLA 3D printer AUTUT Universal Car Cup Holder 1 Amazon","title":"Parts List"},{"location":"stretch-tool-share/tool_share/tray_cup_holder_V1/#assembly-instructions","text":"View 3D assembly Install the M5 bolt into the tray clip and secure it rigidly to the part using the M5 nut. Clip the tray onto the tray clip. Drop the tray clip assembly on to the tool plate from above. Secure it to the tool plate using the wrist_end_cap_5mm and M5 nut.","title":"Assembly instructions"},{"location":"stretch-tool-share/tool_share/wrist_USB_board_camera/","text":"Wrist USB Board Camera Create by : Hello Robot Inc This design allows you to attach a USB board camera to the wrist yaw joint of Stretch. The wrist mounted camera can pan left-right, making it perfect for simple remote inspection tasks. The camera can be integrated into your robot URDF by integrating its stretch_description as described in the Stretch ROS documentation . Parts List Item Qty Vendor M2x8mm SHCS 8 McMaster-Carr M2x6mm Thread Forming Screw 5 McMaster-Carr Board_Camera_Ball_Shell.STL 1 PLA 3D printer Board_Camera_Ball_Cover.STL 1 PLA 3D printer ELP 2MP USB Board Camera (Suggested) 1 Amazon / Spinel Assembly instructions View 3D assembly Attach the Board_Camera_Ball_Shell to the wrist tool plate using the 8 M2 bolts Attach the camera to the Board_Camera_Ball_Shell using 4 self-threading screws Attach the USB cable and route it down and through the wrist yaw passage Attach the Boad_Camera_Ball_Cover using 1 self-threading screw Plug the USB cable into the USB-A port on the wrist NOTE: The USB cable that comes with the camera uses a JST-PH connector. You may want to make your own cable with a custom length using a right-angle USB-A cable. This may require a JST-PH crimp tool. NOTE: A variety of USB board cameras are available from ELP and Spinel, among others. The shells may need to be modified to accommodate variations in the mechanical packaging of these cameras.","title":"Wrist USB Camera"},{"location":"stretch-tool-share/tool_share/wrist_USB_board_camera/#wrist-usb-board-camera","text":"Create by : Hello Robot Inc This design allows you to attach a USB board camera to the wrist yaw joint of Stretch. The wrist mounted camera can pan left-right, making it perfect for simple remote inspection tasks. The camera can be integrated into your robot URDF by integrating its stretch_description as described in the Stretch ROS documentation .","title":"Wrist USB Board Camera"},{"location":"stretch-tool-share/tool_share/wrist_USB_board_camera/#parts-list","text":"Item Qty Vendor M2x8mm SHCS 8 McMaster-Carr M2x6mm Thread Forming Screw 5 McMaster-Carr Board_Camera_Ball_Shell.STL 1 PLA 3D printer Board_Camera_Ball_Cover.STL 1 PLA 3D printer ELP 2MP USB Board Camera (Suggested) 1 Amazon / Spinel","title":"Parts List"},{"location":"stretch-tool-share/tool_share/wrist_USB_board_camera/#assembly-instructions","text":"View 3D assembly Attach the Board_Camera_Ball_Shell to the wrist tool plate using the 8 M2 bolts Attach the camera to the Board_Camera_Ball_Shell using 4 self-threading screws Attach the USB cable and route it down and through the wrist yaw passage Attach the Boad_Camera_Ball_Cover using 1 self-threading screw Plug the USB cable into the USB-A port on the wrist NOTE: The USB cable that comes with the camera uses a JST-PH connector. You may want to make your own cable with a custom length using a right-angle USB-A cable. This may require a JST-PH crimp tool. NOTE: A variety of USB board cameras are available from ELP and Spinel, among others. The shells may need to be modified to accommodate variations in the mechanical packaging of these cameras.","title":"Assembly instructions"}]}