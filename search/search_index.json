{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Safety WARNING: The Stretch RE1 is a potentially dangerous robot. All users must carefully read the Stretch Safety Guide prior to using the robot. Resource Description Stretch Safety Guide Safety guide for users of the Stretch RE1 Stretch Best Practices - Powered Off Video How to work with Stretch when its power is off Stretch Best Practices - Powered On Video How to work with Stretch when its power is on Quick Start Resource Description Stretch Unboxing Video How to unpack your new Stretch Stretch Quick Start Guide Getting started - Xbox Teleoperation Demo and beyond Stretch Troubleshooting Guide Solutions to common issues Stretch Network Setup Guide to network setup for working with Stretch untethered Tutorials Resource Description Working with Robot Parameters Learn how to query, set, and manage robot parameters. Working with Dynamixel Servos Learn how to use various tools to manage Dynamixel servos Changing End of Arm Tools Learn how to configure the Stretch software interfaces to support other tools Extending the Wrist DOF Learn how to integrate additional DOF to the End of Arm Working with the Wrist Expansion Header Learn how to integrate custom hardware on to the expansion header in the wrist. Hardware Resource Description Stretch Hardware User Guide Specification and functional description of the Stretch RE1 Hardware Stretch Dex Wrist User Guide Installing, configuring, and working with the Stretch Dex Wrist Stretch Battery Maintenance Guide Guide to Care for and Charge the Stretch Batteries Stretch Tool Share Open resource to share designs and code for end-of-arm tools Software Body Interface Resource Description Stretch Body Guide Guide to the low level Python interface to the Stretch hardware Stretch Body API Reference API reference for the Stretch Body python module. Stretch Firmware Guide Guide to updating the Stretch Firmware Stretch Installation Guide Guide to installing a new user and managing the Stretch installation Stretch Factory Tools Guide to factory tools for hardware calibration and introspection ROS Interface We provide ROS-related code for the Stretch RE1 mobile manipulator, including a ROS node that interfaces to the robot, calibration code, and demonstrations of various autonomous robot capabilities. Resource Description stretch_ros repository on GitHub Repository with ROS-related code for Stretch Other Tools Resource Description Stretch Web Interface Repository with code to allow a user to operate a Stretch through a web browser License This documentation is only to be used for an authentic Stretch RE1 robot produced and sold by Hello Robot Inc. All Hello Robot stretch_docs related materials are released under the Creative Commons Attribution-NoDerivatives 4.0 International (CC BY-ND 4.0) license. The Stretch RE1 has patents pending.","title":"Home"},{"location":"#safety","text":"WARNING: The Stretch RE1 is a potentially dangerous robot. All users must carefully read the Stretch Safety Guide prior to using the robot. Resource Description Stretch Safety Guide Safety guide for users of the Stretch RE1 Stretch Best Practices - Powered Off Video How to work with Stretch when its power is off Stretch Best Practices - Powered On Video How to work with Stretch when its power is on","title":"Safety"},{"location":"#quick-start","text":"Resource Description Stretch Unboxing Video How to unpack your new Stretch Stretch Quick Start Guide Getting started - Xbox Teleoperation Demo and beyond Stretch Troubleshooting Guide Solutions to common issues Stretch Network Setup Guide to network setup for working with Stretch untethered","title":"Quick Start"},{"location":"#tutorials","text":"Resource Description Working with Robot Parameters Learn how to query, set, and manage robot parameters. Working with Dynamixel Servos Learn how to use various tools to manage Dynamixel servos Changing End of Arm Tools Learn how to configure the Stretch software interfaces to support other tools Extending the Wrist DOF Learn how to integrate additional DOF to the End of Arm Working with the Wrist Expansion Header Learn how to integrate custom hardware on to the expansion header in the wrist.","title":"Tutorials"},{"location":"#hardware","text":"Resource Description Stretch Hardware User Guide Specification and functional description of the Stretch RE1 Hardware Stretch Dex Wrist User Guide Installing, configuring, and working with the Stretch Dex Wrist Stretch Battery Maintenance Guide Guide to Care for and Charge the Stretch Batteries Stretch Tool Share Open resource to share designs and code for end-of-arm tools","title":"Hardware"},{"location":"#software","text":"","title":"Software"},{"location":"#body-interface","text":"Resource Description Stretch Body Guide Guide to the low level Python interface to the Stretch hardware Stretch Body API Reference API reference for the Stretch Body python module. Stretch Firmware Guide Guide to updating the Stretch Firmware Stretch Installation Guide Guide to installing a new user and managing the Stretch installation Stretch Factory Tools Guide to factory tools for hardware calibration and introspection","title":"Body Interface"},{"location":"#ros-interface","text":"We provide ROS-related code for the Stretch RE1 mobile manipulator, including a ROS node that interfaces to the robot, calibration code, and demonstrations of various autonomous robot capabilities. Resource Description stretch_ros repository on GitHub Repository with ROS-related code for Stretch","title":"ROS Interface"},{"location":"#other-tools","text":"Resource Description Stretch Web Interface Repository with code to allow a user to operate a Stretch through a web browser","title":"Other Tools"},{"location":"#license","text":"This documentation is only to be used for an authentic Stretch RE1 robot produced and sold by Hello Robot Inc. All Hello Robot stretch_docs related materials are released under the Creative Commons Attribution-NoDerivatives 4.0 International (CC BY-ND 4.0) license. The Stretch RE1 has patents pending.","title":"License"},{"location":"LICENSE/","text":"The following license applies to the entire contents of this directory (the \"Contents\"), which contains documentation exclusively for use with the Stretch RE1 mobile manipulator, which is a robot produced and sold by Hello Robot Inc. Copyright 2020 Hello Robot Inc. The Contents are licensed under the Creative Commons Attribution-NoDerivatives 4.0 International (CC BY-ND 4.0) license (the \"License\"); you may not use the Contents except in compliance with the License. You may obtain a copy of the License at https://creativecommons.org/licenses/by-nd/4.0 Unless required by applicable law or agreed to in writing, the Contents distributed under the License are distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Patents pending and trademark rights cover the Contents. As stated by the detailed License, \"Patent and trademark rights are not licensed under this Public License.\" For further information about the Contents including inquiries about dual licensing, please contact Hello Robot Inc.","title":"LICENSE"},{"location":"battery_maintenance_guide/","text":"Battery Maintenance Guide - Stretch RE1 Overview Stretch RE1 utilizes two 12V AGM SLA batteries that provide a combined 18AH of capacity. Maintaining an adequate level of charge on the battery system will enhance the battery lifetime. The run time for a fully charged system is dependent on the load use case. The majority of battery power is consumed by the NUC computer as Stretch uses relatively low power motors. A fully charged robot running a high CPU load can run approximately 2 hours before requiring a recharge. Charger Stretch ships with a NOCO Genius 10 charger. Earlier versions of Stretch use the NOCO G7200. These two chargers are functionally very similar. Please review the battery charger user manuals prior to following the guidance in this document. Genius 10 Manual G7200 Manual Stretch utilizes four of the available modes on these chargers. Mode Function STANDBY Charger not charging the robot 12V AGM Charging robot powered down SUPPLY 1) Power the robot during tethered use 2) Repair damaged batteries. REPAIR Repair damaged batteries. NOCO Genius 10 - Interface Mode Procedure STANDBY Illuminates when charger not charging 12V AGM 1) From STANDBY, charger attached 2) Press MODE button repeatedly until 12V AGM indicator is illuminated SUPPLY 1) From STANDBY, charger not attached 2) Press and hold MODE button for 3s 3) Press MODE button until SUPPLY indicator is illuminated 4) Attach charger REPAIR 1) From STANDBY, charger attached 2) Press and hold MODE button for 3s 3) Press MODE button until REPAIR indicator is illuminated NOCO G7200 - Interface Mode Procedure STANDBY Illuminates when charger not charging 12V AGM 1) From STANDBY, charger attached 2) Press MODE button repeatedly until 12V AGM indicator is illuminated SUPPLY 1) From STANDBY, charger not attached 2) Press and hold MODE button for 3s 3) Press MODE button until SUPPLY indicator is illuminated 4) Attach charger REPAIR 1) From STANDBY, charger attached 2) Press and hold MODE button for 3s 3) Press MODE button until REPAIR indicator is illuminated Charging Best Practices It is possible to accidentally deeply discharge the batteries by leaving the robot on for long durations without the charger attached. This is similar to leaving the lights on your car where the battery will continue to drain until fully discharged. We recommend following the best practices below to avoid deep discharge of the batteries and to ensure they have a long lifespan. Use Case Best Practice Reason Robot is in use - tethered Leave the charger attached in SUPPLY mode while developing on the robot whenever possible. Shutdown and power off the robot when development is done. Running the robot while attempting to charge in 12V AGM mode can cause issues and is generally bad for battery health. SUPPLY mode is preferred whenever the robot needs to be powered on. Robot is in use - untethered Regularly check the battery voltage using the command line tool. Shutdown the computer and power off the robot when voltage falls below 11.5V. Attach the charger in 12V AGM mode. Charge to 100% before resuming operation. The 12V AGM charge mode expects the battery voltage to be above 10.5-11V in order to operate. Robot is not in use Shutdown the computer and turn off the robot power. Leave the charger attached and place it in 12V AGM mode. Leaving the robot power on may cause the batteries to deep discharge The charger will maintain a \u2018trickle charge\u2019 on the battery, keeping the charge at 100%. Robot is coming out of storage Attach charger in 12V AGM mode and charge for 2-3 hours until charger reports 100% SLA batteries naturally lose charge over time due to \u2018self-discharge\u2019. When To Plug in the Charger We recommend keeping the charger attached whenever the robot is not running untethered. When the battery voltage drops below \u2018low voltage\u2019 threshold the robot will produce an intermittent double beep sound. This is a reminder to the user to plug in the charger. If desired, the intermittent beep functionality can be disabled by setting the stop_at_low_voltage field in the User YAML to 0 . Troubleshooting Issue How to Diagnose Cause Corrective Procedure Robot shows no power on activity Nothing happens when you toggle on the robot\u2019s power switch. There is no visible illumination of LEDs, motion of the laser range finder, or audible noise of the robot fans. The robot fuse may have blown. When the batteries drain the current required to maintain power goes up, which can ultimately blow the fuse. Proceed to \u201cChanging the Fuse\u201d steps below Robot powers on momentarily When you toggle on the robot\u2019s power switch some activity occurs (illumination of LEDs, audible noise of robot fans, etc) but the computer fails to boot. The battery voltage is too low to maintain power. As the power draw increases during power-on, the voltage dips and causes the system to shut down. Connect the battery charger in 12V AGM mode and leave until fully charged. Battery won\u2019t charge in 12V AGM mode When the robot is powered down and the charger is connected in 12V AGM mode, the charger eventually switches to a different mode. The battery voltage is too low for the charger to function correctly in normal operation. Proceed to the \u201cRecovering from Low Battery Voltage\u201d steps below. Charger reports 100% charge but the batteries are discharged When the robot is powered down and the charger is connected in 12V AGM mode, the charger status shows 100%. However the robot fails to turn on properly. Damage to the batteries (usually caused by excessively low voltage) may artificially raise the open circuit voltage of the battery, causing the battery to appear fully charged, while providing low capacity. Proceed to the \u201cRecovering from Low Battery Voltage\u201d steps below. Charger will not charge or stay in any mode. When placed in 12V AGM, SUPPLY, or REPAIR mode, it continually reverts to STANDBY mode after ~ 20 minutes. Charger may be defective. Contact Hello Robot Support for a replacement. Recovering from Low Battery Voltage Turn off the robot power switch and detach the charger from the robot Place charger in SUPPLY Mode Allow robot to charge for 4-8 hours, or up to 24 hours for extreme discharge Switch the charger to 12V AGM mode Charge until at 100% Additional Information Powering Down the Robot The recommended power down procedure is Place a clamp on the mast below the shoulder to prevent dropping Shutdown the computer from the Desktop or via SSH When the laser range finder has stopped spinning, turn off the main power switch Replacing the Fuse Stretch RE1 has an automotive fuse inside the base that may need to be replaced. The type of fuse depends on your build version of the RE1 Build Version Fuse Type Recommended Fuse Guthrie 8A 5x20mm Fast Blow Glass Bussman S505-8-R Hank and later 7.5A ATM Fast Blow Blade Bussman VP/ATM-7-1/2-RP The fuse location is shown below. For guidance on replacing the fuse, contact Hello Robot support: support@hello-robot.com . Checking the Battery Charge The battery charger LEDs provide an approximate indicator of battery charge when it is in 12V AGM mode. Checking the Battery Voltage Battery voltage is not always an accurate indicator of battery charge but it can be a useful proxy. A charged battery will typically report a voltage of 12-12.8V and will maintain that voltage across load conditions. Meanwhile, a partially charged battery may report anywhere from 10-12.8V but its voltage will drop rapidly when loaded. Measuring Battery Voltage from the Command Line The battery voltage and current draw can be checked from the command line: $ stretch_robot_battery_check.py [Pass] Voltage with 12.9889035225 [Pass] Current with 2.46239192784 [Pass] CPU Temp with 56.0 Measuring Battery Voltage with a DMM When troubleshooting a deeply discharged battery it may be useful to directly measure the battery voltage with a digital multimeter (DMM). To do this we recommend detaching the charger cable at its inline connector and applying the DMM to the connector contacts as shown. NOTE: Caution should be taken as it is possible to short the battery when doing this. Repairing Damaged Batteries It is possible for Stretch's batteries to become damaged due to repeated deep discharge. If the robot has continued issues maintaining a charge we recommend attempting the following procedure: Turn off the robot power switch and detach the charger from the robot Place charger in SUPPLY Mode Attach the charger and allow robot to charge for 4-8 hours Place the charger in REPAIR mode Allow robot to charge until the repair cycle completes and the charger returns to standby - up to 4 hours Place the charger back in 12V AGM mode and allow batteries to charger to 100% Replacing Dead Batteries It is possible for a mechanically skilled person to replace the Stretch batteries should it be necessary . Please contact Hello Robot Support for more information (support@hello-robot.com) . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Battery Maintenance Guide - Stretch RE1"},{"location":"battery_maintenance_guide/#battery-maintenance-guide-stretch-re1","text":"","title":"Battery Maintenance Guide - Stretch RE1"},{"location":"battery_maintenance_guide/#overview","text":"Stretch RE1 utilizes two 12V AGM SLA batteries that provide a combined 18AH of capacity. Maintaining an adequate level of charge on the battery system will enhance the battery lifetime. The run time for a fully charged system is dependent on the load use case. The majority of battery power is consumed by the NUC computer as Stretch uses relatively low power motors. A fully charged robot running a high CPU load can run approximately 2 hours before requiring a recharge.","title":"Overview"},{"location":"battery_maintenance_guide/#charger","text":"Stretch ships with a NOCO Genius 10 charger. Earlier versions of Stretch use the NOCO G7200. These two chargers are functionally very similar. Please review the battery charger user manuals prior to following the guidance in this document. Genius 10 Manual G7200 Manual Stretch utilizes four of the available modes on these chargers. Mode Function STANDBY Charger not charging the robot 12V AGM Charging robot powered down SUPPLY 1) Power the robot during tethered use 2) Repair damaged batteries. REPAIR Repair damaged batteries.","title":"Charger"},{"location":"battery_maintenance_guide/#noco-genius-10-interface","text":"Mode Procedure STANDBY Illuminates when charger not charging 12V AGM 1) From STANDBY, charger attached 2) Press MODE button repeatedly until 12V AGM indicator is illuminated SUPPLY 1) From STANDBY, charger not attached 2) Press and hold MODE button for 3s 3) Press MODE button until SUPPLY indicator is illuminated 4) Attach charger REPAIR 1) From STANDBY, charger attached 2) Press and hold MODE button for 3s 3) Press MODE button until REPAIR indicator is illuminated","title":"NOCO Genius 10 - Interface"},{"location":"battery_maintenance_guide/#noco-g7200-interface","text":"Mode Procedure STANDBY Illuminates when charger not charging 12V AGM 1) From STANDBY, charger attached 2) Press MODE button repeatedly until 12V AGM indicator is illuminated SUPPLY 1) From STANDBY, charger not attached 2) Press and hold MODE button for 3s 3) Press MODE button until SUPPLY indicator is illuminated 4) Attach charger REPAIR 1) From STANDBY, charger attached 2) Press and hold MODE button for 3s 3) Press MODE button until REPAIR indicator is illuminated","title":"NOCO G7200 - Interface"},{"location":"battery_maintenance_guide/#charging-best-practices","text":"It is possible to accidentally deeply discharge the batteries by leaving the robot on for long durations without the charger attached. This is similar to leaving the lights on your car where the battery will continue to drain until fully discharged. We recommend following the best practices below to avoid deep discharge of the batteries and to ensure they have a long lifespan. Use Case Best Practice Reason Robot is in use - tethered Leave the charger attached in SUPPLY mode while developing on the robot whenever possible. Shutdown and power off the robot when development is done. Running the robot while attempting to charge in 12V AGM mode can cause issues and is generally bad for battery health. SUPPLY mode is preferred whenever the robot needs to be powered on. Robot is in use - untethered Regularly check the battery voltage using the command line tool. Shutdown the computer and power off the robot when voltage falls below 11.5V. Attach the charger in 12V AGM mode. Charge to 100% before resuming operation. The 12V AGM charge mode expects the battery voltage to be above 10.5-11V in order to operate. Robot is not in use Shutdown the computer and turn off the robot power. Leave the charger attached and place it in 12V AGM mode. Leaving the robot power on may cause the batteries to deep discharge The charger will maintain a \u2018trickle charge\u2019 on the battery, keeping the charge at 100%. Robot is coming out of storage Attach charger in 12V AGM mode and charge for 2-3 hours until charger reports 100% SLA batteries naturally lose charge over time due to \u2018self-discharge\u2019.","title":"Charging Best Practices"},{"location":"battery_maintenance_guide/#when-to-plug-in-the-charger","text":"We recommend keeping the charger attached whenever the robot is not running untethered. When the battery voltage drops below \u2018low voltage\u2019 threshold the robot will produce an intermittent double beep sound. This is a reminder to the user to plug in the charger. If desired, the intermittent beep functionality can be disabled by setting the stop_at_low_voltage field in the User YAML to 0 .","title":"When To Plug in the Charger"},{"location":"battery_maintenance_guide/#troubleshooting","text":"Issue How to Diagnose Cause Corrective Procedure Robot shows no power on activity Nothing happens when you toggle on the robot\u2019s power switch. There is no visible illumination of LEDs, motion of the laser range finder, or audible noise of the robot fans. The robot fuse may have blown. When the batteries drain the current required to maintain power goes up, which can ultimately blow the fuse. Proceed to \u201cChanging the Fuse\u201d steps below Robot powers on momentarily When you toggle on the robot\u2019s power switch some activity occurs (illumination of LEDs, audible noise of robot fans, etc) but the computer fails to boot. The battery voltage is too low to maintain power. As the power draw increases during power-on, the voltage dips and causes the system to shut down. Connect the battery charger in 12V AGM mode and leave until fully charged. Battery won\u2019t charge in 12V AGM mode When the robot is powered down and the charger is connected in 12V AGM mode, the charger eventually switches to a different mode. The battery voltage is too low for the charger to function correctly in normal operation. Proceed to the \u201cRecovering from Low Battery Voltage\u201d steps below. Charger reports 100% charge but the batteries are discharged When the robot is powered down and the charger is connected in 12V AGM mode, the charger status shows 100%. However the robot fails to turn on properly. Damage to the batteries (usually caused by excessively low voltage) may artificially raise the open circuit voltage of the battery, causing the battery to appear fully charged, while providing low capacity. Proceed to the \u201cRecovering from Low Battery Voltage\u201d steps below. Charger will not charge or stay in any mode. When placed in 12V AGM, SUPPLY, or REPAIR mode, it continually reverts to STANDBY mode after ~ 20 minutes. Charger may be defective. Contact Hello Robot Support for a replacement.","title":"Troubleshooting"},{"location":"battery_maintenance_guide/#recovering-from-low-battery-voltage","text":"Turn off the robot power switch and detach the charger from the robot Place charger in SUPPLY Mode Allow robot to charge for 4-8 hours, or up to 24 hours for extreme discharge Switch the charger to 12V AGM mode Charge until at 100%","title":"Recovering from Low Battery Voltage"},{"location":"battery_maintenance_guide/#additional-information","text":"","title":"Additional Information"},{"location":"battery_maintenance_guide/#powering-down-the-robot","text":"The recommended power down procedure is Place a clamp on the mast below the shoulder to prevent dropping Shutdown the computer from the Desktop or via SSH When the laser range finder has stopped spinning, turn off the main power switch","title":"Powering Down the Robot"},{"location":"battery_maintenance_guide/#replacing-the-fuse","text":"Stretch RE1 has an automotive fuse inside the base that may need to be replaced. The type of fuse depends on your build version of the RE1 Build Version Fuse Type Recommended Fuse Guthrie 8A 5x20mm Fast Blow Glass Bussman S505-8-R Hank and later 7.5A ATM Fast Blow Blade Bussman VP/ATM-7-1/2-RP The fuse location is shown below. For guidance on replacing the fuse, contact Hello Robot support: support@hello-robot.com .","title":"Replacing the Fuse"},{"location":"battery_maintenance_guide/#checking-the-battery-charge","text":"The battery charger LEDs provide an approximate indicator of battery charge when it is in 12V AGM mode.","title":"Checking the Battery Charge"},{"location":"battery_maintenance_guide/#checking-the-battery-voltage","text":"Battery voltage is not always an accurate indicator of battery charge but it can be a useful proxy. A charged battery will typically report a voltage of 12-12.8V and will maintain that voltage across load conditions. Meanwhile, a partially charged battery may report anywhere from 10-12.8V but its voltage will drop rapidly when loaded. Measuring Battery Voltage from the Command Line The battery voltage and current draw can be checked from the command line: $ stretch_robot_battery_check.py [Pass] Voltage with 12.9889035225 [Pass] Current with 2.46239192784 [Pass] CPU Temp with 56.0 Measuring Battery Voltage with a DMM When troubleshooting a deeply discharged battery it may be useful to directly measure the battery voltage with a digital multimeter (DMM). To do this we recommend detaching the charger cable at its inline connector and applying the DMM to the connector contacts as shown. NOTE: Caution should be taken as it is possible to short the battery when doing this.","title":"Checking the Battery Voltage"},{"location":"battery_maintenance_guide/#repairing-damaged-batteries","text":"It is possible for Stretch's batteries to become damaged due to repeated deep discharge. If the robot has continued issues maintaining a charge we recommend attempting the following procedure: Turn off the robot power switch and detach the charger from the robot Place charger in SUPPLY Mode Attach the charger and allow robot to charge for 4-8 hours Place the charger in REPAIR mode Allow robot to charge until the repair cycle completes and the charger returns to standby - up to 4 hours Place the charger back in 12V AGM mode and allow batteries to charger to 100%","title":"Repairing Damaged Batteries"},{"location":"battery_maintenance_guide/#replacing-dead-batteries","text":"It is possible for a mechanically skilled person to replace the Stretch batteries should it be necessary . Please contact Hello Robot Support for more information (support@hello-robot.com) . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Replacing Dead Batteries"},{"location":"dex_wrist_user_guide/","text":"Stretch RE1: Dex Wrist User Guide In this guide, we will cover the installation, configuration, and use of the Stretch Dex Wrist. Overview The Stretch Dex Wrist is an optional add-on to the RE1. It adds pitch and roll degrees of freedom to the standard wrist yaw joint. It also includes a slightly modified version of the standard Stretch Compliant Gripper. NOTE: If your robot did not ship with the Stretch Dex Wrist pre-installed you will want to first proceed to the Appendix: Installation and Configuration at the end of this guide. Functional Specification Working with the Dex Wrist Safe Use The Dex Wrist requires added attention to safety. Its additional dexterity introduces new pinch points around the wrist pitch and roll degrees of freedom. NOTE: Please review the Robot Safety Guide prior to working with the Dex Wrist. In addition to these precautions, the Dex Wrist requires attention to pinch points between: The wrist pitch and wrist yaw structures during yaw motion The gripper and wrist pitch structures during pitch motion The Dex Wrist includes a pinch point safety marking as a reminder to users: Avoiding Collisions The added dexterity of the Dex Wrist introduces new opportunities for self-collision between the robot tool and the robot. These include Running the tool into the base during lift downward motion Running the tool into the ground Running the tool into the wrist yaw structure We recommend becoming familiar with the potential collision points of the Dex Wrist by commanding careful motions through the stretch_xbox_controller_teleop.py tool. With Stretch Body v0.1.0 we introduce a simple collision avoidance controller . The collision avoidance behavior acts to dynamically set the robot joint limits according to simple models of its kinematic state. The avoidance behavior is defined in collision_model.py For performance reasons this collision avoidance behavior is coarse and does not prevent all self-collisions and considered 'experimental'. The collision avoidance is off by default for the standard Stretch RE1. For robots with the wrist we turn it on by default. It be turned on or off by modifying the following in your user YAML: robot : use_collision_manager : 1 XBox Teleoperation The Dex Wrist can be teleoperated using the XBox controller. When the Dex Wrist is installed the stretch_xbox_controller_teleop.py tool will automatically remap control of the pan-tilt head to control of the pitch-roll wrist. $ stretch_xbox_controller_teleop.py The new key mapping is shown below. A printable version is available here . Stretch Body Interface The new WristPitch and WristRoll joints are accessed from Stretch Body in the same manner as the WristYaw joint. Control of the Stretch Dex Wrist uses the same interfaces as the rest of the Stretch Body Robot joints. For example: import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () #Move arm to safe manipulation location robot . stow () robot . lift . move_to ( 0.4 ) robot . push_command () time . sleep ( 2.0 ) #Pose the Dex Wrist robot . end_of_arm . move_to ( 'wrist_yaw' , 0 ) robot . end_of_arm . move_to ( 'wrist_pitch' , 0 ) robot . end_of_arm . move_to ( 'wrist_roll' , 0 ) robot . end_of_arm . move_to ( 'stretch_gripper' , 50 ) time . sleep ( 2.0 ) #Go back to stow and shutdown robot . stow () robot . stop () You can jog the individual joints of the wrist with the Stretch Body interface using the stretch_dex_wrist_jog.py tool that installs with the Stretch Tool Share: $ stretch_dex_wrist_jog.py --pitch $ stretch_dex_wrist_jog.py --yaw $ stretch_dex_wrist_jog.py --roll For reference, the parameters for the Stretch Dex Wrist (which can be overridden in the user YAML) can be seen in params.py . Stretch ROS Interface The Dex Wrist can be controlled via ROS as well, as shown in the keyboard teleoperation code . To test the interface: $ roslaunch stretch_calibration simple_test_head_calibration.launch You can use Ctrl-C to exit when done. The menu interface is: ---------- KEYBOARD TELEOP MENU ----------- i HEAD UP j HEAD LEFT l HEAD RIGHT , HEAD DOWN 7 BASE ROTATE LEFT 9 BASE ROTATE RIGHT home page-up 8 LIFT UP up-arrow 4 BASE FORWARD 6 BASE BACK left-arrow right-arrow 2 LIFT DOWN down-arrow w ARM OUT a WRIST FORWARD d WRIST BACK x ARM IN c PITCH FORWARD v PITCH BACK o ROLL FORWARD p ROLL BACK 5 GRIPPER CLOSE 0 GRIPPER OPEN step size: b BIG, m MEDIUM, s SMALL q QUIT ------------------------------------------- Appendix: Installation and Configuration Robots that did not ship with the Dex Wrist installed will require additional hardware and software installation. Production Batch Variation Earlier production 'batches' of Stretch will require a hardware upgrade prior to use the Dex Wrist. To check your robot's batch, run: $ stretch_about.py Refer to this table to determine what changes are required for your robot. Batch Name Upgrade Wacc Board Update Baud Rate Guthrie Y Y Hank Y Y Irma Y Y Joplin N Y Kendrick or later N N Upgrade Wacc Board If your robot requires a Wacc Board upgrade please follow the instructions here with the assistance of Hello Robot support. This must be done before attaching the Dex Wrist to our robot. Update Baud Rate The new wrist requires moving to 115200 Baud communication for all Dynamixel servos from the previous 57600. Use the commands below. $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-head 11 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-head 12 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-wrist 13 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud Attaching the Dex Wrist Power down your Stretch before installing the Dex Wrist. The Dex Wrist mounts to the bottom of the Stretch Wrist Tool Plate . Installation requires 8 M2x6mm Torx FHCS bolts (provided) 4 M2.5x4mm Torx FHCS bolts (provided) 2 M2.5x8mm SHCS bolts (provided) T6 Torx wrench (provided) T8 Torx wrench (provided) 2mm Hex key (provided) First, remove the standard Stretch Gripper if it is still attached according to the Hardware User Guide . Mounting Bracket Note where the forward direction is on the wrist yaw tool plate. The forward direction is indicated by the additional alignment hole that is just outside the bolt pattern (shown pointing down in the image) Using the T6 Torx wrench, attach the wrist mount bracket (A) to the bottom of the tool plate using the provided M2x6mm bolts (B). NOTE: ensure that the forward direction of the bracket (also indicated by an alignment hole) matches the forward direction of the tool plate. Now route the Dynamixel cable coming from the Stretch Wrist Yaw through the hollow bore of the wrist yaw joint. NOTE: During this step ensure the Dynamixel cable from the wrist yaw exits out the back (towards the shoulder) Next, raise the wrist module up vertically into the mounting bracket , then sliding it over horizontally so that the bearing mates onto its post. Now rotate the wrist yaw joint so the wrist pitch servo body is accessible. Attach the pitch servo to the mounting bracket using the 4 M2.5x4mm screws (C) using the T8 Torx wrench. Finally, route the Dynamixel cable into the wrist pitch servo (pink) and install the cable clip (D) using the M2.5x8mm bolts and the 2mm hex wrench. Software Configuration Robots that did not ship with the Dex Wrist pre-installed will require their software to be updated and configured. NOTE: Each user account on the robot will need to run the following steps to configure the Dex Wrist. Upgrade Stretch Body Ensure the latest version of Stretch Body and Stretch Factory are installed $ pip2 install hello-robot-stretch-body -U --no-cache-dir $ pip2 install hello-robot-stretch-body-tools -U --no-cache-dir $ pip2 install hello-robot-stretch-factory -U --no-cache-dir $ pip2 install hello-robot-stretch-tool-share -U --no-cache-dir Backup User YAML $ cd $HELLO_FLEET_PATH / $HELLO_FLEET_ID $ cp stretch_re1_user_params.yaml stretch_re1_user_params.yaml.bak Run Installation Script $ cd ~/repos $ git clone https://github.com/hello-robot/stretch_install $ cd ./stretch_install $ git pull $ ./factory/stretch_install_dex_wrist.sh NOTE: The factory gripper calibration may not provide the full range of motion in some cases. If necessary you can dial in the gripper calibration with the tool RE1_gripper_calibrate.py All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch RE1: Dex Wrist User Guide"},{"location":"dex_wrist_user_guide/#stretch-re1-dex-wrist-user-guide","text":"In this guide, we will cover the installation, configuration, and use of the Stretch Dex Wrist.","title":"Stretch RE1: Dex Wrist User Guide"},{"location":"dex_wrist_user_guide/#overview","text":"The Stretch Dex Wrist is an optional add-on to the RE1. It adds pitch and roll degrees of freedom to the standard wrist yaw joint. It also includes a slightly modified version of the standard Stretch Compliant Gripper. NOTE: If your robot did not ship with the Stretch Dex Wrist pre-installed you will want to first proceed to the Appendix: Installation and Configuration at the end of this guide.","title":"Overview"},{"location":"dex_wrist_user_guide/#functional-specification","text":"","title":"Functional Specification"},{"location":"dex_wrist_user_guide/#working-with-the-dex-wrist","text":"","title":"Working with the Dex Wrist"},{"location":"dex_wrist_user_guide/#safe-use","text":"The Dex Wrist requires added attention to safety. Its additional dexterity introduces new pinch points around the wrist pitch and roll degrees of freedom. NOTE: Please review the Robot Safety Guide prior to working with the Dex Wrist. In addition to these precautions, the Dex Wrist requires attention to pinch points between: The wrist pitch and wrist yaw structures during yaw motion The gripper and wrist pitch structures during pitch motion The Dex Wrist includes a pinch point safety marking as a reminder to users:","title":"Safe Use"},{"location":"dex_wrist_user_guide/#avoiding-collisions","text":"The added dexterity of the Dex Wrist introduces new opportunities for self-collision between the robot tool and the robot. These include Running the tool into the base during lift downward motion Running the tool into the ground Running the tool into the wrist yaw structure We recommend becoming familiar with the potential collision points of the Dex Wrist by commanding careful motions through the stretch_xbox_controller_teleop.py tool. With Stretch Body v0.1.0 we introduce a simple collision avoidance controller . The collision avoidance behavior acts to dynamically set the robot joint limits according to simple models of its kinematic state. The avoidance behavior is defined in collision_model.py For performance reasons this collision avoidance behavior is coarse and does not prevent all self-collisions and considered 'experimental'. The collision avoidance is off by default for the standard Stretch RE1. For robots with the wrist we turn it on by default. It be turned on or off by modifying the following in your user YAML: robot : use_collision_manager : 1","title":"Avoiding Collisions"},{"location":"dex_wrist_user_guide/#xbox-teleoperation","text":"The Dex Wrist can be teleoperated using the XBox controller. When the Dex Wrist is installed the stretch_xbox_controller_teleop.py tool will automatically remap control of the pan-tilt head to control of the pitch-roll wrist. $ stretch_xbox_controller_teleop.py The new key mapping is shown below. A printable version is available here .","title":"XBox Teleoperation"},{"location":"dex_wrist_user_guide/#stretch-body-interface","text":"The new WristPitch and WristRoll joints are accessed from Stretch Body in the same manner as the WristYaw joint. Control of the Stretch Dex Wrist uses the same interfaces as the rest of the Stretch Body Robot joints. For example: import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () #Move arm to safe manipulation location robot . stow () robot . lift . move_to ( 0.4 ) robot . push_command () time . sleep ( 2.0 ) #Pose the Dex Wrist robot . end_of_arm . move_to ( 'wrist_yaw' , 0 ) robot . end_of_arm . move_to ( 'wrist_pitch' , 0 ) robot . end_of_arm . move_to ( 'wrist_roll' , 0 ) robot . end_of_arm . move_to ( 'stretch_gripper' , 50 ) time . sleep ( 2.0 ) #Go back to stow and shutdown robot . stow () robot . stop () You can jog the individual joints of the wrist with the Stretch Body interface using the stretch_dex_wrist_jog.py tool that installs with the Stretch Tool Share: $ stretch_dex_wrist_jog.py --pitch $ stretch_dex_wrist_jog.py --yaw $ stretch_dex_wrist_jog.py --roll For reference, the parameters for the Stretch Dex Wrist (which can be overridden in the user YAML) can be seen in params.py .","title":"Stretch Body Interface"},{"location":"dex_wrist_user_guide/#stretch-ros-interface","text":"The Dex Wrist can be controlled via ROS as well, as shown in the keyboard teleoperation code . To test the interface: $ roslaunch stretch_calibration simple_test_head_calibration.launch You can use Ctrl-C to exit when done. The menu interface is: ---------- KEYBOARD TELEOP MENU ----------- i HEAD UP j HEAD LEFT l HEAD RIGHT , HEAD DOWN 7 BASE ROTATE LEFT 9 BASE ROTATE RIGHT home page-up 8 LIFT UP up-arrow 4 BASE FORWARD 6 BASE BACK left-arrow right-arrow 2 LIFT DOWN down-arrow w ARM OUT a WRIST FORWARD d WRIST BACK x ARM IN c PITCH FORWARD v PITCH BACK o ROLL FORWARD p ROLL BACK 5 GRIPPER CLOSE 0 GRIPPER OPEN step size: b BIG, m MEDIUM, s SMALL q QUIT -------------------------------------------","title":"Stretch ROS Interface"},{"location":"dex_wrist_user_guide/#appendix-installation-and-configuration","text":"Robots that did not ship with the Dex Wrist installed will require additional hardware and software installation.","title":"Appendix: Installation and Configuration"},{"location":"dex_wrist_user_guide/#production-batch-variation","text":"Earlier production 'batches' of Stretch will require a hardware upgrade prior to use the Dex Wrist. To check your robot's batch, run: $ stretch_about.py Refer to this table to determine what changes are required for your robot. Batch Name Upgrade Wacc Board Update Baud Rate Guthrie Y Y Hank Y Y Irma Y Y Joplin N Y Kendrick or later N N","title":"Production Batch Variation"},{"location":"dex_wrist_user_guide/#upgrade-wacc-board","text":"If your robot requires a Wacc Board upgrade please follow the instructions here with the assistance of Hello Robot support. This must be done before attaching the Dex Wrist to our robot.","title":"Upgrade Wacc Board"},{"location":"dex_wrist_user_guide/#update-baud-rate","text":"The new wrist requires moving to 115200 Baud communication for all Dynamixel servos from the previous 57600. Use the commands below. $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-head 11 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-head 12 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-wrist 13 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud","title":"Update Baud Rate"},{"location":"dex_wrist_user_guide/#attaching-the-dex-wrist","text":"Power down your Stretch before installing the Dex Wrist. The Dex Wrist mounts to the bottom of the Stretch Wrist Tool Plate . Installation requires 8 M2x6mm Torx FHCS bolts (provided) 4 M2.5x4mm Torx FHCS bolts (provided) 2 M2.5x8mm SHCS bolts (provided) T6 Torx wrench (provided) T8 Torx wrench (provided) 2mm Hex key (provided) First, remove the standard Stretch Gripper if it is still attached according to the Hardware User Guide .","title":"Attaching the Dex Wrist"},{"location":"dex_wrist_user_guide/#mounting-bracket","text":"Note where the forward direction is on the wrist yaw tool plate. The forward direction is indicated by the additional alignment hole that is just outside the bolt pattern (shown pointing down in the image) Using the T6 Torx wrench, attach the wrist mount bracket (A) to the bottom of the tool plate using the provided M2x6mm bolts (B). NOTE: ensure that the forward direction of the bracket (also indicated by an alignment hole) matches the forward direction of the tool plate. Now route the Dynamixel cable coming from the Stretch Wrist Yaw through the hollow bore of the wrist yaw joint. NOTE: During this step ensure the Dynamixel cable from the wrist yaw exits out the back (towards the shoulder) Next, raise the wrist module up vertically into the mounting bracket , then sliding it over horizontally so that the bearing mates onto its post. Now rotate the wrist yaw joint so the wrist pitch servo body is accessible. Attach the pitch servo to the mounting bracket using the 4 M2.5x4mm screws (C) using the T8 Torx wrench. Finally, route the Dynamixel cable into the wrist pitch servo (pink) and install the cable clip (D) using the M2.5x8mm bolts and the 2mm hex wrench.","title":"Mounting Bracket"},{"location":"dex_wrist_user_guide/#software-configuration","text":"Robots that did not ship with the Dex Wrist pre-installed will require their software to be updated and configured. NOTE: Each user account on the robot will need to run the following steps to configure the Dex Wrist.","title":"Software Configuration"},{"location":"dex_wrist_user_guide/#upgrade-stretch-body","text":"Ensure the latest version of Stretch Body and Stretch Factory are installed $ pip2 install hello-robot-stretch-body -U --no-cache-dir $ pip2 install hello-robot-stretch-body-tools -U --no-cache-dir $ pip2 install hello-robot-stretch-factory -U --no-cache-dir $ pip2 install hello-robot-stretch-tool-share -U --no-cache-dir","title":"Upgrade Stretch Body"},{"location":"dex_wrist_user_guide/#backup-user-yaml","text":"$ cd $HELLO_FLEET_PATH / $HELLO_FLEET_ID $ cp stretch_re1_user_params.yaml stretch_re1_user_params.yaml.bak","title":"Backup User YAML"},{"location":"dex_wrist_user_guide/#run-installation-script","text":"$ cd ~/repos $ git clone https://github.com/hello-robot/stretch_install $ cd ./stretch_install $ git pull $ ./factory/stretch_install_dex_wrist.sh NOTE: The factory gripper calibration may not provide the full range of motion in some cases. If necessary you can dial in the gripper calibration with the tool RE1_gripper_calibrate.py All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Run Installation Script"},{"location":"dynamixel_tutorial/","text":"Stretch RE1 - Working with the Dynamixel Servos In this tutorial we will cover the basics required to work with Dynamixel servos and Stretch. Note : This tutorial applies to Stretch Body v0.1.x or greater Overview Stretch comes with two Dynamixel buses - one for the head and one for the end-of-arm: $ ls /dev/hello-dynamixel-* /dev/hello-dynamixel-head /dev/hello-dynamixel-wrist Typically users will interact with these devices through either the Head or EndOfArm interfaces. The EndOfArm interface may be extended to support custom tools, as described in the Stretch Body Tool Change Tutorial. In some cases users will need to work directly with the servos from the command line. The sections below covers these tools Servo Tools Jogging the Servos You can directly command each servo using the command line tool RE1_dynamixel_servo_jog.py . This can be useful for debugging new servos added to the end-of-arm tool during system bring-up. For example, to command the head pan servo: $ RE1_dynamixel_jog.py /dev/hello-dynamixel-head 11 [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1080 ------ MENU ------- m: menu a: increment position 50 tick b: decrement position 50 tick A: increment position 500 ticks B: decrement position 500 ticks v: set profile velocity u: set profile acceleration z: zero position h: show homing offset o: zero homing offset q: got to position p: ping r: reboot w: set max pwm t: set max temp i: set id d: disable torque e: enable torque ------------------- Rebooting the Servos Under high-load conditions the servos may enter an error state to protect themselves from thermal overload. In this case, the red LED on the servo will flash (if visible). In addition, the servo will be unresponsive to motion commands. In this case, allow the overheating servo to cool down and reboot the servos using the stretch_robot_dynamixel_reboot.py tool: $ stretch_robot_dynamixel_reboot.py For use with S T R E T C H (TM) RESEARCH EDITION from Hello Robot Inc. ---- Rebooting Head ---- [Dynamixel ID:011] Reboot Succeeded. [Dynamixel ID:012] Reboot Succeeded. ---- Rebooting Wrist ---- [Dynamixel ID:013] Reboot Succeeded. [Dynamixel ID:014] Reboot Succeeded. Identify Servos on the Bus If it is unclear which servos are on the bus, and at what baud rate, you can use the RE1_dynamixel_id_scan.py tool. Here we see that the two head servos are at ID 11 and 12 at baud 57600. $ RE1_dynamixel_id_scan.py /dev/hello-dynamixel-head --baud 57600 Scanning bus /dev/hello-dynamixel-head at baud rate 57600 ---------------------------------------------------------- [Dynamixel ID:000] ping Failed. [Dynamixel ID:001] ping Failed. [Dynamixel ID:002] ping Failed. [Dynamixel ID:003] ping Failed. [Dynamixel ID:004] ping Failed. [Dynamixel ID:005] ping Failed. [Dynamixel ID:006] ping Failed. [Dynamixel ID:007] ping Failed. [Dynamixel ID:008] ping Failed. [Dynamixel ID:009] ping Failed. [Dynamixel ID:010] ping Failed. [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1080 [Dynamixel ID:012] ping Succeeded. Dynamixel model number : 1060 [Dynamixel ID:013] ping Failed. [Dynamixel ID:014] ping Failed. [Dynamixel ID:015] ping Failed. [Dynamixel ID:016] ping Failed. [Dynamixel ID:017] ping Failed. [Dynamixel ID:018] ping Failed. [Dynamixel ID:019] ping Failed. [Dynamixel ID:020] ping Failed. [Dynamixel ID:021] ping Failed. [Dynamixel ID:022] ping Failed. [Dynamixel ID:023] ping Failed. [Dynamixel ID:024] ping Failed. Setting the Servo Baud Rate Dynamixel servos come with baudrate=57600 from the factory. When adding your own servos to the end-of-arm tool, you may want to set the servo ID using the RE1_dynamixel_set_baud.py tool. For example: $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-wrist 13 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud Setting the Servo ID Dynamixel servos come with ID=1 from the factory. When adding your own servos to the end-of-arm tool, you may want to set the servo ID using the RE1_dynamixel_id_change.py tool. For example: $ RE1_dynamixel_id_change.py /dev/hello-dynamixel-wrist 1 13 --baud 115200 [Dynamixel ID:001] ping Succeeded. Dynamixel model number : 1080 Ready to change ID 1 to 13. Hit enter to continue: [Dynamixel ID:013] ping Succeeded. Dynamixel model number : 1080 Success at setting ID to 13 All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch RE1 - Working with the Dynamixel Servos"},{"location":"dynamixel_tutorial/#stretch-re1-working-with-the-dynamixel-servos","text":"In this tutorial we will cover the basics required to work with Dynamixel servos and Stretch. Note : This tutorial applies to Stretch Body v0.1.x or greater","title":"Stretch RE1 - Working with the Dynamixel Servos"},{"location":"dynamixel_tutorial/#overview","text":"Stretch comes with two Dynamixel buses - one for the head and one for the end-of-arm: $ ls /dev/hello-dynamixel-* /dev/hello-dynamixel-head /dev/hello-dynamixel-wrist Typically users will interact with these devices through either the Head or EndOfArm interfaces. The EndOfArm interface may be extended to support custom tools, as described in the Stretch Body Tool Change Tutorial. In some cases users will need to work directly with the servos from the command line. The sections below covers these tools","title":"Overview"},{"location":"dynamixel_tutorial/#servo-tools","text":"","title":"Servo Tools"},{"location":"dynamixel_tutorial/#jogging-the-servos","text":"You can directly command each servo using the command line tool RE1_dynamixel_servo_jog.py . This can be useful for debugging new servos added to the end-of-arm tool during system bring-up. For example, to command the head pan servo: $ RE1_dynamixel_jog.py /dev/hello-dynamixel-head 11 [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1080 ------ MENU ------- m: menu a: increment position 50 tick b: decrement position 50 tick A: increment position 500 ticks B: decrement position 500 ticks v: set profile velocity u: set profile acceleration z: zero position h: show homing offset o: zero homing offset q: got to position p: ping r: reboot w: set max pwm t: set max temp i: set id d: disable torque e: enable torque -------------------","title":"Jogging the Servos"},{"location":"dynamixel_tutorial/#rebooting-the-servos","text":"Under high-load conditions the servos may enter an error state to protect themselves from thermal overload. In this case, the red LED on the servo will flash (if visible). In addition, the servo will be unresponsive to motion commands. In this case, allow the overheating servo to cool down and reboot the servos using the stretch_robot_dynamixel_reboot.py tool: $ stretch_robot_dynamixel_reboot.py For use with S T R E T C H (TM) RESEARCH EDITION from Hello Robot Inc. ---- Rebooting Head ---- [Dynamixel ID:011] Reboot Succeeded. [Dynamixel ID:012] Reboot Succeeded. ---- Rebooting Wrist ---- [Dynamixel ID:013] Reboot Succeeded. [Dynamixel ID:014] Reboot Succeeded.","title":"Rebooting the Servos"},{"location":"dynamixel_tutorial/#identify-servos-on-the-bus","text":"If it is unclear which servos are on the bus, and at what baud rate, you can use the RE1_dynamixel_id_scan.py tool. Here we see that the two head servos are at ID 11 and 12 at baud 57600. $ RE1_dynamixel_id_scan.py /dev/hello-dynamixel-head --baud 57600 Scanning bus /dev/hello-dynamixel-head at baud rate 57600 ---------------------------------------------------------- [Dynamixel ID:000] ping Failed. [Dynamixel ID:001] ping Failed. [Dynamixel ID:002] ping Failed. [Dynamixel ID:003] ping Failed. [Dynamixel ID:004] ping Failed. [Dynamixel ID:005] ping Failed. [Dynamixel ID:006] ping Failed. [Dynamixel ID:007] ping Failed. [Dynamixel ID:008] ping Failed. [Dynamixel ID:009] ping Failed. [Dynamixel ID:010] ping Failed. [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1080 [Dynamixel ID:012] ping Succeeded. Dynamixel model number : 1060 [Dynamixel ID:013] ping Failed. [Dynamixel ID:014] ping Failed. [Dynamixel ID:015] ping Failed. [Dynamixel ID:016] ping Failed. [Dynamixel ID:017] ping Failed. [Dynamixel ID:018] ping Failed. [Dynamixel ID:019] ping Failed. [Dynamixel ID:020] ping Failed. [Dynamixel ID:021] ping Failed. [Dynamixel ID:022] ping Failed. [Dynamixel ID:023] ping Failed. [Dynamixel ID:024] ping Failed.","title":"Identify Servos on the Bus"},{"location":"dynamixel_tutorial/#setting-the-servo-baud-rate","text":"Dynamixel servos come with baudrate=57600 from the factory. When adding your own servos to the end-of-arm tool, you may want to set the servo ID using the RE1_dynamixel_set_baud.py tool. For example: $ RE1_dynamixel_set_baud.py /dev/hello-dynamixel-wrist 13 115200 --------------------- Checking servo current baud for 57600 ---- Identified current baud of 57600. Changing baud to 115200 Success at changing baud","title":"Setting the Servo Baud Rate"},{"location":"dynamixel_tutorial/#setting-the-servo-id","text":"Dynamixel servos come with ID=1 from the factory. When adding your own servos to the end-of-arm tool, you may want to set the servo ID using the RE1_dynamixel_id_change.py tool. For example: $ RE1_dynamixel_id_change.py /dev/hello-dynamixel-wrist 1 13 --baud 115200 [Dynamixel ID:001] ping Succeeded. Dynamixel model number : 1080 Ready to change ID 1 to 13. Hit enter to continue: [Dynamixel ID:013] ping Succeeded. Dynamixel model number : 1080 Success at setting ID to 13 All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Setting the Servo ID"},{"location":"hardware_user_guide/","text":"Hardware User Guide This manual provides the engineering data and user guidance for working with the Hello Robot Stretch RE1 hardware. Disclaimer The Hello Robot Stretch Robot is intended for use in the research of mobile manipulation applications by users experienced in the use and programming of research robots. This product is not intended for general use in the home by consumers, and lacks the required certifications for such use. Please see the section on Regulatory Compliance for further details. Functional Specification Body Plan Hardware Architecture Robot Subsystems Base The base is a two wheel differential drive with a passive Mecanum wheel for a caster. It includes four cliff sensors to allow detection of stairs, thresholds, etc. Item Notes A Drive wheels 4 inch diameter, urethane rubber shore 60A B Cliff sensors Sharp GP2Y0A51SK0F, Analog, range 2-15 cm C Mecanum wheel Diameter 50mm The base has 6 M4 threaded inserts available for mounting user accessories such as a tray. The mounting pattern is shown below. The inserts are recessed 1mm from the top of the base shell. Base IMU The base has a 9 DOF IMU using the 9 DOF FXOS8700 + FXAS21002 chipset. The IMU orientation is as shown below: Trunk Development and charge ports are at the back of the base in the trunk. The trunk cover slides into place vertically and is non-latching. The trunk height has been designed to accommodate one or more USB based Intel Neural Compute Sticks. Two mounting holes are provided inside the trunk. These allow the user to strain relief tethered cables (eg, HDMI and keyboard) during development. It is recommended to strain relief such cables to prevent accidental damage during base motion. Item Notes A Vent Intake vent for computer fan B 6 Port USB Hub USB 3.0 , powered 5V/3A C Ethernet Connected to computer NIC D On/Off Robot power on / off. Switch is illuminated when on. E Charge Rated for upplied 12V/7A charger F HDMI Connected to computer HDMI G Mounting points M4 threaded holes Head The head provides the audio interface to the robot, a pan tilt depth camera, a runstop, as well as a developer interface to allow the addition of additional user hardware. Item Notes A Pan tilt depth camera Intel RealSense D435i Two Dynamixel XL430-W250-T servos B Speakers C Mounting holes 2x M4 threaded, spacing 25mm D Developer Interface USB2.0-A with 5V@500mA fused JST XHP-2, 12V@3A fused Pin 1: 12V Pin 2: GND E Microphone array With programmable 12 RGB LED ring F Runstop G Audio volume control Pan Tilt The head pan-tilt unit utilizes two Dynamixel XL430-W250-T servos. It incorporates a small fan in order to ensure proper cooling of the servo and camera during dynamic repeated motions of the tilt DOF. The nominal \u2018zero\u2019 position is of the head is shown below, along with the corresponding range of motion. DOF Range (deg) Min(deg) Max (deg) Pan 346 -234 112 Tilt 115 -25 90 ReSpeaker Microphone Array The ReSPeaker has 12 RGB LEDs that can be controlled programatically. By default they display sound intensity and direction of the microphone array. The ReSpeaker has 4 mems microphones mounted on a 64.61mm circle at 45 degree spacing. The drawing below shows the position and orientation of the microphone array relative to the head pan axis. Runstop The runstop allows the user to pause the motion of the four primary DOF (base, lift, and arm) by tapping the illuminated button on the head. When the runstop is enabled, these DOF are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume. Lift The lift degree of freedom provides vertical translation of the arm. It is driven by a closed loop stepper motor, providing smooth and precise motion through a low gear-ratio belt drive. The \u2018shoulder\u2019 includes two mounting holes and a small delivery tray. Item Notes A Delivery tray B Mounting holes Threaded M4. Spacing 34.5 mm. C Aruco Tag Size 40x40 mm Arm The arm comprises 5 telescoping carbon fiber links set on rollers. Its proprietary drive train is driven by a stepper motor with closed loop control and current sensing, allowing contact sensitivity during motion. The arm exhibits a small amount of play (lash) in the X, Y, Z, and theta directions which is a normal characteristic of its design. Despite this it can achieve good repeatability, in part because its gravity loading is fairly constant. The retracted arm and wrist combined are designed to fit within the footprint of the base. The arm is designed to have: Reach: 0.52m Wrist The wrist includes: Yaw DOF to allow for stowing of the tool 2 Aruco tags for calibration and visual localization of the tool Expansion port with Arduino expansion header USB-A connector Tool plate with dual sided mounting Dynamixel X-Series TTL bus Wrist Control Interface The wrist yaw degree-of-freedom uses a Dynamixel XL430 servo . Additional Dynamixel servos can be daisy chained off of this servo, allowing for one more additional degree-of-freedoms to be easily integrated onto the robot (such as the provided Stretch Gripper). Stretch comes with a XL430 compatible control cable preinstalled into this servo. If a different cable needs to be installed the servo cap can be removed as shown. Wrist Tool Plate The tool plate allows for mounting on the top or the bottom using the M2 bolt pattern. The mounting pattern is compatible with Robotis Dynamixel frames as well: FR12-H101K FR12-S102K FR12-S101K Wrist Yaw Range of Motion The wrist yaw DOF is calibrated so that the index hole faces forward at the 'zero' position. From this pose the wrist has a ROM of +256/-76 degrees as shown. Wrist Accelerometer The wrist includes a 3 axis ADXL343 accelerometer which provides bump and tap detection capabilities. The sensor is mounted inside the distal link of the arm as shown below. Wrist Expansion USB The wrist includes a USB 2.0 A interface. This power to this USB port is fused to 500mA@5V. Wrist Expansion Header The wrist includes an expansion header that provides access to pins of the wrist Arduino board. The header connector can be accessed by removing the cap at the end of the arm. The header is wired to a Atmel SAMD21G18A-AUT ( datasheet ) microcontroller (same as Arduino Zero). The expansion header pins are configured at the factory to allow: General purpose digital I/O Analog input In addition, the firmware can be configured for other pin functions, including: Serial SPI Serial I2C Serial UART The Stretch Firmware Manual covers this modification. The header pins utilize 3V3 TTL logic. They do not have interface protection (eg, ESD, over-voltage, shorts). It is possible to damage your robot if pin specifications are exceeded The pin mapping is: Pin Name Function Factory Firmware 1 DGND Digital ground 2 3V3 3.3V supply fused at 250mA. 3 E12V 12VDC fused at 500mA 4 SS DIO | SPI SS Digital out (D3) 5 SCK DIO | SPI SCK Digital out (D2) 6 MISO DIO | SPI MISO |UART TX Digital in (D0) 7 MOSI DIO | SPI MOSI | UART RX Digital in (D1) 8 SCL DIO | I2C SCL Not used 9 SS DIO | I2C SDA Not used 10 ANA0 Analog input Analog in (A0) The expansion DIO uses a 10 pin JST header B10B-PHDSS(LF)(SN) . It is compatible with a JST PHDR-10VS housing. JST provides pre-crimped wire compatible with this housing ( part APAPA22K305 ). Pin 1 & 10 are indicated below. The expansion DIO schematic shown below. Wrist Mounts Gripper The Stretch Compliant Gripper utilizes a Dynamixel XL430-W250-T servo to drive the spring grasper mechanism. The kinematics of the grasper mechanism are complex and non-linear relative to the motor position. As shown, it includes mounting features on one side to allow for attachment of simple rigid tools such as hooks and pullers . Item Notes A Stud attachment Threaded 6-32 B Thread attahcment Threaded M4 The attachment features are spaced at 9mm. The weight of the Stretch Compliant Gripper is 240g. Gripper Removal Here we describe removing the Stretch Compliant gripper. Installation is simply these steps in reverse. Unplug the Dynamixel cable from the back of the gripper. Remove the 4 screws holding the gripper to the bracket. Remove the gripper from the mounting bracket Unscrew the 8 screws holding the mounting bracket to the bottom of the tool plate. Robot Care Battery Maintenance Please review the Battery Maintenance Guide for proper care and charging of the Stretch batteries. Belt Tension A neoprene timing belt drives the arm up and down the lift. It may detension over long periods of time if it experiences sustained loading. In this case, slack will become visually apparent in the belt as the lift moves. The belt is very straightforward to re-tension. Please contact support@hello-robot.com for tensioning instructions. Keeping the Robot Clean The robot surfaces can be wiped down with an alcohol wipe or a moist rag from time to time in order to remove and debris or oils that accumulate on the shells or mast. The drive wheels can accumulate dust over time and begin to lose traction. They should be periodically wiped down as well. When possible, the Trunk cover for the base should be kept on in order to keep dust and debris out of the Trunk connectors. If the D435i camera requires cleaning use appropriate lens cleaning fluid and a microfiber cloth. Keeping the Robot Calibrated The robot comes pre-calibrated with a robot-specific URDF. This calibration allows the D435i depth sensor to accurately estimate where the robot wrist, and body, is in the depth image. The robot may become slightly uncalibrated over time for a variety of reasons: Normal wear and tear and loosening of joints of the robot The head structure is accidentally load and the structure becomes very slightly bent The wrist and should structure become accidentally highly loaded and become slightly bent The calibration accuracy can be checked using the provided ROS tools. If necessary, the user can recalibrate the robot. See the Stretch URDF Calibration Guide for more information. Transporting the Robot Stretch was designed to be easily transported in the back of a car, up a stair case, or around a building. For short trips, the robot can be simply rolled around by grabbing its mast. It may be picked up by its mast and carried up stairs as well. For safety, please use two people to lift the robot. For longer trips it is recommended to transport the robot in its original cardboard box with foam packaging. The metal protective cage that surrounds the head is only necessary if the robot might be shipped and the box will not remain upright. System Check It is useful to periodically run stretch_robot_system_check.py. This will check that the robot's hardware devices are present and within normal operating conditions. $ stretch_robot_system_check.py ---- Checking Devices ---- [Pass] : hello-wacc [Pass] : hello-motor-left-wheel [Pass] : hello-motor-arm [Pass] : hello-dynamixel-wrist [Pass] : hello-motor-right-wheel [Pass] : hello-motor-lift [Pass] : hello-pimu [Pass] : hello-respeaker [Pass] : hello-lrf [Pass] : hello-dynamixel-head ---- Checking Pimu ---- [Pass] Voltage = 12.8763639927 [Pass] Current = 3.25908634593 [Pass] Temperature = 36.3404559783 [Pass] Cliff-0 = -4.72064208984 [Pass] Cliff-1 = -8.56213378906 [Pass] Cliff-2 = 1.08505249023 [Pass] Cliff-3 = 5.68453979492 [Pass] IMU AZ = -9.80407142639 ---- Checking EndOfArm ---- [Dynamixel ID:013] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: wrist_yaw [Pass] Calibrated: wrist_yaw [Dynamixel ID:014] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: stretch_gripper [Pass] Calibrated: stretch_gripper ---- Checking Head ---- [Dynamixel ID:012] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_tilt [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_pan ---- Checking Wacc ---- [Pass] AX = 9.4840593338 ---- Checking hello-motor-left-wheel ---- [Pass] Position = 43.9992256165 ---- Checking hello-motor-right-wheel ---- [Pass] Position = 15.1164712906 ---- Checking hello-motor-arm ---- [Pass] Position = 59.7719421387 [Pass] Position Calibrated = True ---- Checking hello-motor-lift ---- [Pass] Position = 83.7744064331 [Pass] Position Calibrated = True ---- Checking for Intel D435i ---- Bus 002 Device 016: ID 8086:0b3a Intel Corp. [Pass] : Device found Regulatory Compliance The Stretch Research Edition 1 (Stretch RE1) is not certified for use as a consumer device in the U.S. Unless stated otherwise, the Stretch RE1 is not subjected to compliance testing nor certified to meet any requirements, such as requirements for EMI, EMC, or ESD. Per FCC 47 CFR, Part 15, Subpart B, section 15.103(c) , we claim the Stretch Research Edition 1 as an exempted device, since it is a digital device used exclusively as industrial, commercial, or medical test equipment, where test equipment is equipment intended primarily for purposes of performing scientific investigations. OET BULLETIN NO. 62 , titled \"UNDERSTANDING THE FCC REGULATIONS FOR COMPUTERS AND OTHER DIGITAL DEVICES\" from December 1993 provides further clarification of the Section 15.103(c) exemption: \u201c Test equipment includes devices used for maintenance, research, evaluation, simulation and other analytical or scientific applications in areas such as industrial plants, public utilities, hospitals, universities, laboratories, automotive service centers and electronic repair shops.\u201d All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Hardware User Guide"},{"location":"hardware_user_guide/#hardware-user-guide","text":"This manual provides the engineering data and user guidance for working with the Hello Robot Stretch RE1 hardware.","title":"Hardware User Guide"},{"location":"hardware_user_guide/#disclaimer","text":"The Hello Robot Stretch Robot is intended for use in the research of mobile manipulation applications by users experienced in the use and programming of research robots. This product is not intended for general use in the home by consumers, and lacks the required certifications for such use. Please see the section on Regulatory Compliance for further details.","title":"Disclaimer"},{"location":"hardware_user_guide/#functional-specification","text":"","title":"Functional Specification"},{"location":"hardware_user_guide/#body-plan","text":"","title":"Body Plan"},{"location":"hardware_user_guide/#hardware-architecture","text":"","title":"Hardware Architecture"},{"location":"hardware_user_guide/#robot-subsystems","text":"","title":"Robot Subsystems"},{"location":"hardware_user_guide/#base","text":"The base is a two wheel differential drive with a passive Mecanum wheel for a caster. It includes four cliff sensors to allow detection of stairs, thresholds, etc. Item Notes A Drive wheels 4 inch diameter, urethane rubber shore 60A B Cliff sensors Sharp GP2Y0A51SK0F, Analog, range 2-15 cm C Mecanum wheel Diameter 50mm The base has 6 M4 threaded inserts available for mounting user accessories such as a tray. The mounting pattern is shown below. The inserts are recessed 1mm from the top of the base shell.","title":"Base"},{"location":"hardware_user_guide/#base-imu","text":"The base has a 9 DOF IMU using the 9 DOF FXOS8700 + FXAS21002 chipset. The IMU orientation is as shown below:","title":"Base IMU"},{"location":"hardware_user_guide/#trunk","text":"Development and charge ports are at the back of the base in the trunk. The trunk cover slides into place vertically and is non-latching. The trunk height has been designed to accommodate one or more USB based Intel Neural Compute Sticks. Two mounting holes are provided inside the trunk. These allow the user to strain relief tethered cables (eg, HDMI and keyboard) during development. It is recommended to strain relief such cables to prevent accidental damage during base motion. Item Notes A Vent Intake vent for computer fan B 6 Port USB Hub USB 3.0 , powered 5V/3A C Ethernet Connected to computer NIC D On/Off Robot power on / off. Switch is illuminated when on. E Charge Rated for upplied 12V/7A charger F HDMI Connected to computer HDMI G Mounting points M4 threaded holes","title":"Trunk"},{"location":"hardware_user_guide/#head","text":"The head provides the audio interface to the robot, a pan tilt depth camera, a runstop, as well as a developer interface to allow the addition of additional user hardware. Item Notes A Pan tilt depth camera Intel RealSense D435i Two Dynamixel XL430-W250-T servos B Speakers C Mounting holes 2x M4 threaded, spacing 25mm D Developer Interface USB2.0-A with 5V@500mA fused JST XHP-2, 12V@3A fused Pin 1: 12V Pin 2: GND E Microphone array With programmable 12 RGB LED ring F Runstop G Audio volume control","title":"Head"},{"location":"hardware_user_guide/#pan-tilt","text":"The head pan-tilt unit utilizes two Dynamixel XL430-W250-T servos. It incorporates a small fan in order to ensure proper cooling of the servo and camera during dynamic repeated motions of the tilt DOF. The nominal \u2018zero\u2019 position is of the head is shown below, along with the corresponding range of motion. DOF Range (deg) Min(deg) Max (deg) Pan 346 -234 112 Tilt 115 -25 90","title":"Pan Tilt"},{"location":"hardware_user_guide/#respeaker-microphone-array","text":"The ReSPeaker has 12 RGB LEDs that can be controlled programatically. By default they display sound intensity and direction of the microphone array. The ReSpeaker has 4 mems microphones mounted on a 64.61mm circle at 45 degree spacing. The drawing below shows the position and orientation of the microphone array relative to the head pan axis.","title":"ReSpeaker Microphone Array"},{"location":"hardware_user_guide/#runstop","text":"The runstop allows the user to pause the motion of the four primary DOF (base, lift, and arm) by tapping the illuminated button on the head. When the runstop is enabled, these DOF are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume.","title":"Runstop"},{"location":"hardware_user_guide/#lift","text":"The lift degree of freedom provides vertical translation of the arm. It is driven by a closed loop stepper motor, providing smooth and precise motion through a low gear-ratio belt drive. The \u2018shoulder\u2019 includes two mounting holes and a small delivery tray. Item Notes A Delivery tray B Mounting holes Threaded M4. Spacing 34.5 mm. C Aruco Tag Size 40x40 mm","title":"Lift"},{"location":"hardware_user_guide/#arm","text":"The arm comprises 5 telescoping carbon fiber links set on rollers. Its proprietary drive train is driven by a stepper motor with closed loop control and current sensing, allowing contact sensitivity during motion. The arm exhibits a small amount of play (lash) in the X, Y, Z, and theta directions which is a normal characteristic of its design. Despite this it can achieve good repeatability, in part because its gravity loading is fairly constant. The retracted arm and wrist combined are designed to fit within the footprint of the base. The arm is designed to have: Reach: 0.52m","title":"Arm"},{"location":"hardware_user_guide/#wrist","text":"The wrist includes: Yaw DOF to allow for stowing of the tool 2 Aruco tags for calibration and visual localization of the tool Expansion port with Arduino expansion header USB-A connector Tool plate with dual sided mounting Dynamixel X-Series TTL bus","title":"Wrist"},{"location":"hardware_user_guide/#wrist-control-interface","text":"The wrist yaw degree-of-freedom uses a Dynamixel XL430 servo . Additional Dynamixel servos can be daisy chained off of this servo, allowing for one more additional degree-of-freedoms to be easily integrated onto the robot (such as the provided Stretch Gripper). Stretch comes with a XL430 compatible control cable preinstalled into this servo. If a different cable needs to be installed the servo cap can be removed as shown.","title":"Wrist Control Interface"},{"location":"hardware_user_guide/#wrist-tool-plate","text":"The tool plate allows for mounting on the top or the bottom using the M2 bolt pattern. The mounting pattern is compatible with Robotis Dynamixel frames as well: FR12-H101K FR12-S102K FR12-S101K","title":"Wrist Tool Plate"},{"location":"hardware_user_guide/#wrist-yaw-range-of-motion","text":"The wrist yaw DOF is calibrated so that the index hole faces forward at the 'zero' position. From this pose the wrist has a ROM of +256/-76 degrees as shown.","title":"Wrist Yaw Range of Motion"},{"location":"hardware_user_guide/#wrist-accelerometer","text":"The wrist includes a 3 axis ADXL343 accelerometer which provides bump and tap detection capabilities. The sensor is mounted inside the distal link of the arm as shown below.","title":"Wrist Accelerometer"},{"location":"hardware_user_guide/#wrist-expansion-usb","text":"The wrist includes a USB 2.0 A interface. This power to this USB port is fused to 500mA@5V.","title":"Wrist Expansion USB"},{"location":"hardware_user_guide/#wrist-expansion-header","text":"The wrist includes an expansion header that provides access to pins of the wrist Arduino board. The header connector can be accessed by removing the cap at the end of the arm. The header is wired to a Atmel SAMD21G18A-AUT ( datasheet ) microcontroller (same as Arduino Zero). The expansion header pins are configured at the factory to allow: General purpose digital I/O Analog input In addition, the firmware can be configured for other pin functions, including: Serial SPI Serial I2C Serial UART The Stretch Firmware Manual covers this modification. The header pins utilize 3V3 TTL logic. They do not have interface protection (eg, ESD, over-voltage, shorts). It is possible to damage your robot if pin specifications are exceeded The pin mapping is: Pin Name Function Factory Firmware 1 DGND Digital ground 2 3V3 3.3V supply fused at 250mA. 3 E12V 12VDC fused at 500mA 4 SS DIO | SPI SS Digital out (D3) 5 SCK DIO | SPI SCK Digital out (D2) 6 MISO DIO | SPI MISO |UART TX Digital in (D0) 7 MOSI DIO | SPI MOSI | UART RX Digital in (D1) 8 SCL DIO | I2C SCL Not used 9 SS DIO | I2C SDA Not used 10 ANA0 Analog input Analog in (A0) The expansion DIO uses a 10 pin JST header B10B-PHDSS(LF)(SN) . It is compatible with a JST PHDR-10VS housing. JST provides pre-crimped wire compatible with this housing ( part APAPA22K305 ). Pin 1 & 10 are indicated below. The expansion DIO schematic shown below.","title":"Wrist Expansion Header"},{"location":"hardware_user_guide/#wrist-mounts","text":"","title":"Wrist Mounts"},{"location":"hardware_user_guide/#gripper","text":"The Stretch Compliant Gripper utilizes a Dynamixel XL430-W250-T servo to drive the spring grasper mechanism. The kinematics of the grasper mechanism are complex and non-linear relative to the motor position. As shown, it includes mounting features on one side to allow for attachment of simple rigid tools such as hooks and pullers . Item Notes A Stud attachment Threaded 6-32 B Thread attahcment Threaded M4 The attachment features are spaced at 9mm. The weight of the Stretch Compliant Gripper is 240g.","title":"Gripper"},{"location":"hardware_user_guide/#gripper-removal","text":"Here we describe removing the Stretch Compliant gripper. Installation is simply these steps in reverse. Unplug the Dynamixel cable from the back of the gripper. Remove the 4 screws holding the gripper to the bracket. Remove the gripper from the mounting bracket Unscrew the 8 screws holding the mounting bracket to the bottom of the tool plate.","title":"Gripper Removal"},{"location":"hardware_user_guide/#robot-care","text":"","title":"Robot Care"},{"location":"hardware_user_guide/#battery-maintenance","text":"Please review the Battery Maintenance Guide for proper care and charging of the Stretch batteries.","title":"Battery Maintenance"},{"location":"hardware_user_guide/#belt-tension","text":"A neoprene timing belt drives the arm up and down the lift. It may detension over long periods of time if it experiences sustained loading. In this case, slack will become visually apparent in the belt as the lift moves. The belt is very straightforward to re-tension. Please contact support@hello-robot.com for tensioning instructions.","title":"Belt Tension"},{"location":"hardware_user_guide/#keeping-the-robot-clean","text":"The robot surfaces can be wiped down with an alcohol wipe or a moist rag from time to time in order to remove and debris or oils that accumulate on the shells or mast. The drive wheels can accumulate dust over time and begin to lose traction. They should be periodically wiped down as well. When possible, the Trunk cover for the base should be kept on in order to keep dust and debris out of the Trunk connectors. If the D435i camera requires cleaning use appropriate lens cleaning fluid and a microfiber cloth.","title":"Keeping the Robot Clean"},{"location":"hardware_user_guide/#keeping-the-robot-calibrated","text":"The robot comes pre-calibrated with a robot-specific URDF. This calibration allows the D435i depth sensor to accurately estimate where the robot wrist, and body, is in the depth image. The robot may become slightly uncalibrated over time for a variety of reasons: Normal wear and tear and loosening of joints of the robot The head structure is accidentally load and the structure becomes very slightly bent The wrist and should structure become accidentally highly loaded and become slightly bent The calibration accuracy can be checked using the provided ROS tools. If necessary, the user can recalibrate the robot. See the Stretch URDF Calibration Guide for more information.","title":"Keeping the Robot Calibrated"},{"location":"hardware_user_guide/#transporting-the-robot","text":"Stretch was designed to be easily transported in the back of a car, up a stair case, or around a building. For short trips, the robot can be simply rolled around by grabbing its mast. It may be picked up by its mast and carried up stairs as well. For safety, please use two people to lift the robot. For longer trips it is recommended to transport the robot in its original cardboard box with foam packaging. The metal protective cage that surrounds the head is only necessary if the robot might be shipped and the box will not remain upright.","title":"Transporting the Robot"},{"location":"hardware_user_guide/#system-check","text":"It is useful to periodically run stretch_robot_system_check.py. This will check that the robot's hardware devices are present and within normal operating conditions. $ stretch_robot_system_check.py ---- Checking Devices ---- [Pass] : hello-wacc [Pass] : hello-motor-left-wheel [Pass] : hello-motor-arm [Pass] : hello-dynamixel-wrist [Pass] : hello-motor-right-wheel [Pass] : hello-motor-lift [Pass] : hello-pimu [Pass] : hello-respeaker [Pass] : hello-lrf [Pass] : hello-dynamixel-head ---- Checking Pimu ---- [Pass] Voltage = 12.8763639927 [Pass] Current = 3.25908634593 [Pass] Temperature = 36.3404559783 [Pass] Cliff-0 = -4.72064208984 [Pass] Cliff-1 = -8.56213378906 [Pass] Cliff-2 = 1.08505249023 [Pass] Cliff-3 = 5.68453979492 [Pass] IMU AZ = -9.80407142639 ---- Checking EndOfArm ---- [Dynamixel ID:013] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: wrist_yaw [Pass] Calibrated: wrist_yaw [Dynamixel ID:014] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: stretch_gripper [Pass] Calibrated: stretch_gripper ---- Checking Head ---- [Dynamixel ID:012] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_tilt [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_pan ---- Checking Wacc ---- [Pass] AX = 9.4840593338 ---- Checking hello-motor-left-wheel ---- [Pass] Position = 43.9992256165 ---- Checking hello-motor-right-wheel ---- [Pass] Position = 15.1164712906 ---- Checking hello-motor-arm ---- [Pass] Position = 59.7719421387 [Pass] Position Calibrated = True ---- Checking hello-motor-lift ---- [Pass] Position = 83.7744064331 [Pass] Position Calibrated = True ---- Checking for Intel D435i ---- Bus 002 Device 016: ID 8086:0b3a Intel Corp. [Pass] : Device found","title":"System Check"},{"location":"hardware_user_guide/#regulatory-compliance","text":"The Stretch Research Edition 1 (Stretch RE1) is not certified for use as a consumer device in the U.S. Unless stated otherwise, the Stretch RE1 is not subjected to compliance testing nor certified to meet any requirements, such as requirements for EMI, EMC, or ESD. Per FCC 47 CFR, Part 15, Subpart B, section 15.103(c) , we claim the Stretch Research Edition 1 as an exempted device, since it is a digital device used exclusively as industrial, commercial, or medical test equipment, where test equipment is equipment intended primarily for purposes of performing scientific investigations. OET BULLETIN NO. 62 , titled \"UNDERSTANDING THE FCC REGULATIONS FOR COMPUTERS AND OTHER DIGITAL DEVICES\" from December 1993 provides further clarification of the Section 15.103(c) exemption: \u201c Test equipment includes devices used for maintenance, research, evaluation, simulation and other analytical or scientific applications in areas such as industrial plants, public utilities, hospitals, universities, laboratories, automotive service centers and electronic repair shops.\u201d All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Regulatory Compliance"},{"location":"parameters_tutorial/","text":"Stretch Body: Parameters Tutorial In this tutorial we will discuss how parameters are managed in Stretch Body and show examples of how to customize your robot by overriding parameters. Note : This tutorial applies to Stretch Body version 0.1.x or greater. Overview Stretch Body shares a global set of parameters across all of its Python Devices. A quick way to see what parameters are available are with the stretch_params.py tool: $ stretch_params.py # ################################## Parameters for stretch-re1-1039 ###################################### Origin Parameter Value ---------------------------------------------------------------------------------------------------------- stretch_re1_factory_params.yaml param.head_pan.req_calibration 0 stretch_re1_factory_params.yaml param.head_tilt.pwm_limit 885 ... The tool display each parameter's value as well as which parameter file it was loaded from. By grepping the tool's output you can query specific settings. For example, to query contact thresholds for the arm: $ stretch_params.py | grep arm | grep contact_thresh stretch_re1_factory_params.yaml param.arm.contact_thresh_max_N [-100, 100] stretch_re1_factory_params.yaml param.arm.contact_thresh_N [-64.46241590881348, 66.51084520568847] Now if you want to override the default contact thresholds for the arm, you could add the following to your stretch_re1_user_params.yaml : arm : contact_thresh_N : [ -80.0 , 80.0 ] Run the tool again and we see: $ stretch_params.py | grep arm | grep contact_thresh stretch_re1_factory_params.yaml param.arm.contact_thresh_max_N [-100, 100] stretch_re1_factory_params.yaml param.arm.contact_thresh_N [-80, 80] Data Organization Parameters' data sources may be either a Python dictionary or a YAML file. The robot's YAML files are found under $HELLO_FLEET_PATH/$HELLO_FLEET_ID . The Python dictionaries may come from any Python module on the Python path. There are three types of parameters: Factory Parameters stretch_re1_factory_params.yaml : These are common factory settings shared across RE1s as well as factory calibration data that is specific to your robot. stretch_body.robot_params.py : These are common factory settings shared across RE1s that may be automatically updated over time as new versions of Stretch Body are released. External Parameters <external_module>.params.py : These are parameters for devices outside of Stretch Body (such as the devices found in the Stretch Tool Share) User Parameters stretch_re1_user_params.yaml : These are user customizations of the robot's settings As shown below, the parameters are loaded into the robot_params dictionary in a specific order, starting with stretch_re1_factory_params.yaml . Loading of subsequent parameters overwrites earlier parameters. As such, the stretch_re1_user_params.yaml parameters can overwrite any factory parameters or external parameters. You can configure which external parameters' data sources are loaded, and their order, in your stretch_re1_user_params.yaml . For example: factory_params : stretch_re1_factory_params.yaml params : - stretch_tool_share.usbcam_wrist_v1.params - stretch_tool_share.stretch_dex_wrist_beta.params Here we see that the name of the factory parameters file is stretch_re1_factory_params.yaml . We also see that two external parameter sets will be loaded. In this example, the order of parameter precedence would be: stretch_re1_user_params.yaml stretch_tool_share.stretch_dex_wrist_beta.params.py stretch_tool_share.usbcam_wrist_v1.params.py stretch_body.robot_params.py stretch_re1_factory_params.yaml Working with Parameters Programmatically Stretch Body is organized as a set of classes that extend the base Device class. Each Device has access to a set of global parameters that are stored within the Device as a dictionary. These are: device.params : the parameters for the specific device device.robot_params : global set of parameters For example, let's look at the Robot class: class Robot ( Device ): def __init__ ( self ): Device . __init__ ( self , 'robot' ) ... When instantiating its Device base class it loads the robot parameters of the various YAML files and Python dictionaries. class Device : def __init__ ( self , name ): self . name = name self . user_params , self . robot_params = RobotParams . get_params () try : self . params = self . robot_params [ self . name ] except KeyError : print ( 'No device params found for %s ' % name ) self . params = {} We can explore these parameters via iPython. In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . params Out [ 3 ]: { 'batch_name' : 'Irma' , 'log_to_console' : 0 , 'serial_no' : 'stretch-re1-1039' , 'stow' : { 'arm' : 0.0 , 'head_pan' : 0.0 , 'head_tilt' : 0.0 , 'lift' : 0.2 , 'stretch_gripper' : 0 , 'wrist_yaw' : 3.4 }, 'tool' : 'tool_none' , 'use_arm' : 1 , 'use_base' : 1 , 'use_end_of_arm' : 1 , 'use_head' : 1 , 'use_lift' : 1 , 'use_monitor' : 1 , 'use_pimu' : 1 , 'use_sentry' : 1 , 'use_wacc' : 1 , 'verbose' : 0 } In [ 4 ]: r . arm . params Out [ 4 ]: { 'chain_pitch' : 0.0167 , 'chain_sprocket_teeth' : 10 , 'contact_thresh_N' : [ - 80 , 80 ], 'contact_thresh_max_N' : [ - 100 , 100 ], 'force_N_per_A' : 55.9 , 'gr_spur' : 3.875 , 'homing_force_N' : [ - 60 , 80 ], 'i_feedforward' : 0 , 'motion' : { 'default' : { 'accel_m' : 0.14 , 'vel_m' : 0.14 }, 'fast' : { 'accel_m' : 0.2 , 'vel_m' : 0.25 }, 'max' : { 'accel_m' : 0.3 , 'vel_m' : 0.3 }, 'slow' : { 'accel_m' : 0.07 , 'vel_m' : 0.06 }}, 'range_m' : [ 0.0 , 0.5202755326289126 ], 'verbose' : 0 } All devices have access the global parameter set, robot_params . For example, the arm can access the lift parameters: In [ 5 ]: r . arm . robot_params [ 'lift' ] Out [ 5 ]: { 'belt_pitch_m' : 0.005 , 'contact_thresh_N' : [ - 72.45217552185059 , 65.6581787109375 ], 'contact_thresh_max_N' : [ - 100 , 100 ], 'force_N_per_A' : 75.0 , 'homing_force_N' : [ - 70 , 70 ], 'i_feedforward' : 0.75 , 'motion' : { 'default' : { 'accel_m' : 0.15 , 'vel_m' : 0.095 }, 'fast' : { 'accel_m' : 0.2 , 'vel_m' : 0.12 }, 'max' : { 'accel_m' : 0.3 , 'vel_m' : 0.15 }, 'slow' : { 'accel_m' : 0.05 , 'vel_m' : 0.05 }}, 'pinion_t' : 12 , 'range_m' : [ 0.0 , 1.0983598164609882 ], 'verbose' : 0 } You can set any of the robot_params programmatically. For example to adjust the contact sensitivity for the arm: In [ 6 ]: r . arm . params [ 'contact_thresh_N' ] Out [ 6 ]: [ - 64.46241590881348 , 66.51084520568847 ] In [ 7 ]: r . arm . params [ 'contact_thresh_N' ] = [ - 80.0 , 80.0 ] In [ 8 ]: r . arm . params [ 'contact_thresh_N' ] Out [ 8 ]: [ - 80.0 , 80.0 ] All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch Body: Parameters Tutorial"},{"location":"parameters_tutorial/#stretch-body-parameters-tutorial","text":"In this tutorial we will discuss how parameters are managed in Stretch Body and show examples of how to customize your robot by overriding parameters. Note : This tutorial applies to Stretch Body version 0.1.x or greater.","title":"Stretch Body: Parameters Tutorial"},{"location":"parameters_tutorial/#overview","text":"Stretch Body shares a global set of parameters across all of its Python Devices. A quick way to see what parameters are available are with the stretch_params.py tool: $ stretch_params.py # ################################## Parameters for stretch-re1-1039 ###################################### Origin Parameter Value ---------------------------------------------------------------------------------------------------------- stretch_re1_factory_params.yaml param.head_pan.req_calibration 0 stretch_re1_factory_params.yaml param.head_tilt.pwm_limit 885 ... The tool display each parameter's value as well as which parameter file it was loaded from. By grepping the tool's output you can query specific settings. For example, to query contact thresholds for the arm: $ stretch_params.py | grep arm | grep contact_thresh stretch_re1_factory_params.yaml param.arm.contact_thresh_max_N [-100, 100] stretch_re1_factory_params.yaml param.arm.contact_thresh_N [-64.46241590881348, 66.51084520568847] Now if you want to override the default contact thresholds for the arm, you could add the following to your stretch_re1_user_params.yaml : arm : contact_thresh_N : [ -80.0 , 80.0 ] Run the tool again and we see: $ stretch_params.py | grep arm | grep contact_thresh stretch_re1_factory_params.yaml param.arm.contact_thresh_max_N [-100, 100] stretch_re1_factory_params.yaml param.arm.contact_thresh_N [-80, 80]","title":"Overview"},{"location":"parameters_tutorial/#data-organization","text":"Parameters' data sources may be either a Python dictionary or a YAML file. The robot's YAML files are found under $HELLO_FLEET_PATH/$HELLO_FLEET_ID . The Python dictionaries may come from any Python module on the Python path. There are three types of parameters: Factory Parameters stretch_re1_factory_params.yaml : These are common factory settings shared across RE1s as well as factory calibration data that is specific to your robot. stretch_body.robot_params.py : These are common factory settings shared across RE1s that may be automatically updated over time as new versions of Stretch Body are released. External Parameters <external_module>.params.py : These are parameters for devices outside of Stretch Body (such as the devices found in the Stretch Tool Share) User Parameters stretch_re1_user_params.yaml : These are user customizations of the robot's settings As shown below, the parameters are loaded into the robot_params dictionary in a specific order, starting with stretch_re1_factory_params.yaml . Loading of subsequent parameters overwrites earlier parameters. As such, the stretch_re1_user_params.yaml parameters can overwrite any factory parameters or external parameters. You can configure which external parameters' data sources are loaded, and their order, in your stretch_re1_user_params.yaml . For example: factory_params : stretch_re1_factory_params.yaml params : - stretch_tool_share.usbcam_wrist_v1.params - stretch_tool_share.stretch_dex_wrist_beta.params Here we see that the name of the factory parameters file is stretch_re1_factory_params.yaml . We also see that two external parameter sets will be loaded. In this example, the order of parameter precedence would be: stretch_re1_user_params.yaml stretch_tool_share.stretch_dex_wrist_beta.params.py stretch_tool_share.usbcam_wrist_v1.params.py stretch_body.robot_params.py stretch_re1_factory_params.yaml","title":"Data Organization"},{"location":"parameters_tutorial/#working-with-parameters-programmatically","text":"Stretch Body is organized as a set of classes that extend the base Device class. Each Device has access to a set of global parameters that are stored within the Device as a dictionary. These are: device.params : the parameters for the specific device device.robot_params : global set of parameters For example, let's look at the Robot class: class Robot ( Device ): def __init__ ( self ): Device . __init__ ( self , 'robot' ) ... When instantiating its Device base class it loads the robot parameters of the various YAML files and Python dictionaries. class Device : def __init__ ( self , name ): self . name = name self . user_params , self . robot_params = RobotParams . get_params () try : self . params = self . robot_params [ self . name ] except KeyError : print ( 'No device params found for %s ' % name ) self . params = {} We can explore these parameters via iPython. In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . params Out [ 3 ]: { 'batch_name' : 'Irma' , 'log_to_console' : 0 , 'serial_no' : 'stretch-re1-1039' , 'stow' : { 'arm' : 0.0 , 'head_pan' : 0.0 , 'head_tilt' : 0.0 , 'lift' : 0.2 , 'stretch_gripper' : 0 , 'wrist_yaw' : 3.4 }, 'tool' : 'tool_none' , 'use_arm' : 1 , 'use_base' : 1 , 'use_end_of_arm' : 1 , 'use_head' : 1 , 'use_lift' : 1 , 'use_monitor' : 1 , 'use_pimu' : 1 , 'use_sentry' : 1 , 'use_wacc' : 1 , 'verbose' : 0 } In [ 4 ]: r . arm . params Out [ 4 ]: { 'chain_pitch' : 0.0167 , 'chain_sprocket_teeth' : 10 , 'contact_thresh_N' : [ - 80 , 80 ], 'contact_thresh_max_N' : [ - 100 , 100 ], 'force_N_per_A' : 55.9 , 'gr_spur' : 3.875 , 'homing_force_N' : [ - 60 , 80 ], 'i_feedforward' : 0 , 'motion' : { 'default' : { 'accel_m' : 0.14 , 'vel_m' : 0.14 }, 'fast' : { 'accel_m' : 0.2 , 'vel_m' : 0.25 }, 'max' : { 'accel_m' : 0.3 , 'vel_m' : 0.3 }, 'slow' : { 'accel_m' : 0.07 , 'vel_m' : 0.06 }}, 'range_m' : [ 0.0 , 0.5202755326289126 ], 'verbose' : 0 } All devices have access the global parameter set, robot_params . For example, the arm can access the lift parameters: In [ 5 ]: r . arm . robot_params [ 'lift' ] Out [ 5 ]: { 'belt_pitch_m' : 0.005 , 'contact_thresh_N' : [ - 72.45217552185059 , 65.6581787109375 ], 'contact_thresh_max_N' : [ - 100 , 100 ], 'force_N_per_A' : 75.0 , 'homing_force_N' : [ - 70 , 70 ], 'i_feedforward' : 0.75 , 'motion' : { 'default' : { 'accel_m' : 0.15 , 'vel_m' : 0.095 }, 'fast' : { 'accel_m' : 0.2 , 'vel_m' : 0.12 }, 'max' : { 'accel_m' : 0.3 , 'vel_m' : 0.15 }, 'slow' : { 'accel_m' : 0.05 , 'vel_m' : 0.05 }}, 'pinion_t' : 12 , 'range_m' : [ 0.0 , 1.0983598164609882 ], 'verbose' : 0 } You can set any of the robot_params programmatically. For example to adjust the contact sensitivity for the arm: In [ 6 ]: r . arm . params [ 'contact_thresh_N' ] Out [ 6 ]: [ - 64.46241590881348 , 66.51084520568847 ] In [ 7 ]: r . arm . params [ 'contact_thresh_N' ] = [ - 80.0 , 80.0 ] In [ 8 ]: r . arm . params [ 'contact_thresh_N' ] Out [ 8 ]: [ - 80.0 , 80.0 ] All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Working with Parameters Programmatically"},{"location":"quick_start_guide/","text":"Stretch RE1: Quick Start Guide Congratulations on your Stretch RE1! This guide will get you started with your new robot. Safety Stretch has the potential to cause harm if not properly used. All users should review the Stretch Safety Guide before operating the robot. Unboxing Please watch the Stretch Unboxing Video . Robot Tour A few items you'll want to know about before getting started. Power The entire robot powers up and down with the On/Off switch. When powering down, we recommend selecting 'Power Off' from the Ubuntu Desktop prior to hitting the Off switch The provided battery charger can be plugged and unplugged at any time during operation. Stretch uses the following charger modes: Mode Function STANDBY Charger not charging the robot 12V AGM Charging while robot is powered down SUPPLY 1) Power the robot during tethered use 2) Repair damaged batteries. REPAIR Repair damaged batteries. Please review the Battery Maintenance Guide for proper care and charging of Stretch batteries. Runstop The illuminated button on the head is its Runstop. Just tap it, you'll hear a beep and it will start flashing. This will pause motion of the primary robot joints during operation. This can be useful if the robot makes an unsafe motion, or if you just want to free up the robot motors while you roll it around. To allow motion once again, hold the button down for two seconds. After the beep, motion can resume. Safe Handling Like any robot, it is possible to break Stretch if you're not careful. Use common sense when applying forces to its joints, transporting it, etc. The Stretch Unpowered Best Practices Video provides a quick overview of how to work with the robot. Things that won't hurt the robot : Manually push and pull the arm (when the motor isn't holding a position). Manually raise and lower the lift (when the motor isn't holding a position). Manually tilt and roll the base around (when the motors aren't holding a position). Pick up and carry Stretch (while holding it by the mast, two people for safety). Things to be mindful of : Manually moving the head and wrist. They will move but they want to go at their own speed. The arm will slowly descend when the robot is powered off. If the arm is retracted it may rest the tool on the base. If desired to hold the arm up when un-powered, the provided 'clip-clamp' can be clipped onto the mast below the shoulder to support it. Things that can hurt the robot : Driving the wrist and gripper into the base. When the arm and wrist are stowed it is possible to collide the two. Getting the gripper stuck on something and then driving the arm, lift, or base. Laying the robot down with it weight on its camera. Trying to ride on the robot, getting it wet, etc. (eg, common sense) Hello World Demo Stretch comes ready to run out of the box. The Xbox Teleoperation demo will let you quickly test out the robot capabilities by teleoperating it with an Xbox Controller. Note : You will find the USB Dongle already plugged into the the USB port of the base trunk. To start the demo after unboxing: Remove the 'trunk' cover and power on the robot Wait for about 45 seconds. You will hear the Ubuntu startup sound, followed by two beeps (indicating the demo is running). Hit the Connect button on the controller. The upper two LEDs of the ring will illuminate. Hit the Home Robot button. Stretch will go through its homing calibration routine. Note : make sure the space around the robot is clear before running the Home function You're ready to go! A few things to try: Hit the Stow Robot button. The robot will assume the stow pose. Practice driving the robot around. Pull the Fast Base trigger while driving. When stowed, it will make Stretch drive faster Manually stop the arm or lift from moving to make it stop upon contact. Try picking up your cellphone from the floor Try grasping cup from a counter top Try delivering an object to a person If you're done, hold down the Shutdown PC button for 2 seconds. This will cause the PC to turn off. You can then power down the robot. Or proceed to the next step... Now that you're familiar with the robot, take a minute to watch the Stretch Powered Best Practices Video . Get Plugged In Let's get plugged in. Remove the 'trunk' cover and power on the robot if its not already on. Plug in a mouse, keyboard and HDMI monitor to the robot trunk Plug in the battery charger Place the charger in SUPPLY mode Log in to the robot computer. The default user credentials came in the box with the robot. Start Coding Python is the easiest way to begin writing code for the robot. This section will give you a quick look at Stretch Body, which is the low level Python interface to the robot. Detailed information on the Stretch Body Interface can be found here. Stretch is configured to run the XBox Controller demo in the background at startup. To run your own code you'll need kill off this process so that it doesn't contend with your code. $ pkill -f stretch_xbox* While you're at it, disable this autoboot feature. You can always turn it back on later. Search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop' Now open up a Terminal. From the command line, first verify that that all of the hardware is present and happy $ stretch_robot_system_check.py You may see a few joints reported in red because they haven't yet been calibrated. If so, home the robot $ stretch_robot_home.py Once the robot has homed, let's write some quick test code: $ ipython Python 2.7.17 (default, Apr 15 2020, 17:20:14) ... Now let's move the robot around using the Robot API. Try typing in these interactive commands at the iPython prompt: import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . stow () robot . arm . move_to ( 0.25 ) robot . push_command () robot . arm . move_to ( 0.0 ) robot . push_command () robot . lift . move_to ( 0.4 ) robot . push_command () robot . pretty_print () robot . lift . pretty_print () robot . head . pose ( 'tool' ) robot . head . pose ( 'ahead' ) robot . end_of_arm . move_to ( 'wrist_yaw' , 0 ) robot . end_of_arm . move_to ( 'stretch_gripper' , 50 ) robot . end_of_arm . move_to ( 'stretch_gripper' , - 50 ) robot . stow () robot . stop () Change Credentials Finally, we recommend that you change the login credentials for the default user, hello-robot. $ sudo passwd hello-robot If you'd like to setup a new user account, check out the Stretch Installation Guide . In a lab setting, it's useful for lab members to have their own user accounts to run experiments. Power Down The recommended power down procedure is Place a clamp on the mast below the shoulder to prevent dropping Shutdown the computer from the Desktop When the laser range finder has stopped spinning, turn off the main power switch Attach the charger Place the charger in 12V AGM mode Join the Community Forum Join the Hello Robot Community . We'd welcome hearing your feedback as you get to know your robot. Hello Robot support monitors the forum closely and will quickly get back to you on any questions or issues you post. Further Exploration Encounter any issues while getting started? Please let us know at support@hello-robot.com. Also take a minute to review the Stretch Troubleshooting Guide We recommend next exploring the ROS based demos that ship with Stretch. These are found in the stretch_ros repository . That's it. Happy coding! All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch RE1: Quick Start Guide"},{"location":"quick_start_guide/#stretch-re1-quick-start-guide","text":"Congratulations on your Stretch RE1! This guide will get you started with your new robot.","title":"Stretch RE1: Quick Start Guide"},{"location":"quick_start_guide/#safety","text":"Stretch has the potential to cause harm if not properly used. All users should review the Stretch Safety Guide before operating the robot.","title":"Safety"},{"location":"quick_start_guide/#unboxing","text":"Please watch the Stretch Unboxing Video .","title":"Unboxing"},{"location":"quick_start_guide/#robot-tour","text":"A few items you'll want to know about before getting started.","title":"Robot Tour"},{"location":"quick_start_guide/#power","text":"The entire robot powers up and down with the On/Off switch. When powering down, we recommend selecting 'Power Off' from the Ubuntu Desktop prior to hitting the Off switch The provided battery charger can be plugged and unplugged at any time during operation. Stretch uses the following charger modes: Mode Function STANDBY Charger not charging the robot 12V AGM Charging while robot is powered down SUPPLY 1) Power the robot during tethered use 2) Repair damaged batteries. REPAIR Repair damaged batteries. Please review the Battery Maintenance Guide for proper care and charging of Stretch batteries.","title":"Power"},{"location":"quick_start_guide/#runstop","text":"The illuminated button on the head is its Runstop. Just tap it, you'll hear a beep and it will start flashing. This will pause motion of the primary robot joints during operation. This can be useful if the robot makes an unsafe motion, or if you just want to free up the robot motors while you roll it around. To allow motion once again, hold the button down for two seconds. After the beep, motion can resume.","title":"Runstop"},{"location":"quick_start_guide/#safe-handling","text":"Like any robot, it is possible to break Stretch if you're not careful. Use common sense when applying forces to its joints, transporting it, etc. The Stretch Unpowered Best Practices Video provides a quick overview of how to work with the robot. Things that won't hurt the robot : Manually push and pull the arm (when the motor isn't holding a position). Manually raise and lower the lift (when the motor isn't holding a position). Manually tilt and roll the base around (when the motors aren't holding a position). Pick up and carry Stretch (while holding it by the mast, two people for safety). Things to be mindful of : Manually moving the head and wrist. They will move but they want to go at their own speed. The arm will slowly descend when the robot is powered off. If the arm is retracted it may rest the tool on the base. If desired to hold the arm up when un-powered, the provided 'clip-clamp' can be clipped onto the mast below the shoulder to support it. Things that can hurt the robot : Driving the wrist and gripper into the base. When the arm and wrist are stowed it is possible to collide the two. Getting the gripper stuck on something and then driving the arm, lift, or base. Laying the robot down with it weight on its camera. Trying to ride on the robot, getting it wet, etc. (eg, common sense)","title":"Safe Handling"},{"location":"quick_start_guide/#hello-world-demo","text":"Stretch comes ready to run out of the box. The Xbox Teleoperation demo will let you quickly test out the robot capabilities by teleoperating it with an Xbox Controller. Note : You will find the USB Dongle already plugged into the the USB port of the base trunk. To start the demo after unboxing: Remove the 'trunk' cover and power on the robot Wait for about 45 seconds. You will hear the Ubuntu startup sound, followed by two beeps (indicating the demo is running). Hit the Connect button on the controller. The upper two LEDs of the ring will illuminate. Hit the Home Robot button. Stretch will go through its homing calibration routine. Note : make sure the space around the robot is clear before running the Home function You're ready to go! A few things to try: Hit the Stow Robot button. The robot will assume the stow pose. Practice driving the robot around. Pull the Fast Base trigger while driving. When stowed, it will make Stretch drive faster Manually stop the arm or lift from moving to make it stop upon contact. Try picking up your cellphone from the floor Try grasping cup from a counter top Try delivering an object to a person If you're done, hold down the Shutdown PC button for 2 seconds. This will cause the PC to turn off. You can then power down the robot. Or proceed to the next step... Now that you're familiar with the robot, take a minute to watch the Stretch Powered Best Practices Video .","title":"Hello World Demo"},{"location":"quick_start_guide/#get-plugged-in","text":"Let's get plugged in. Remove the 'trunk' cover and power on the robot if its not already on. Plug in a mouse, keyboard and HDMI monitor to the robot trunk Plug in the battery charger Place the charger in SUPPLY mode Log in to the robot computer. The default user credentials came in the box with the robot.","title":"Get Plugged In"},{"location":"quick_start_guide/#start-coding","text":"Python is the easiest way to begin writing code for the robot. This section will give you a quick look at Stretch Body, which is the low level Python interface to the robot. Detailed information on the Stretch Body Interface can be found here. Stretch is configured to run the XBox Controller demo in the background at startup. To run your own code you'll need kill off this process so that it doesn't contend with your code. $ pkill -f stretch_xbox* While you're at it, disable this autoboot feature. You can always turn it back on later. Search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop' Now open up a Terminal. From the command line, first verify that that all of the hardware is present and happy $ stretch_robot_system_check.py You may see a few joints reported in red because they haven't yet been calibrated. If so, home the robot $ stretch_robot_home.py Once the robot has homed, let's write some quick test code: $ ipython Python 2.7.17 (default, Apr 15 2020, 17:20:14) ... Now let's move the robot around using the Robot API. Try typing in these interactive commands at the iPython prompt: import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . stow () robot . arm . move_to ( 0.25 ) robot . push_command () robot . arm . move_to ( 0.0 ) robot . push_command () robot . lift . move_to ( 0.4 ) robot . push_command () robot . pretty_print () robot . lift . pretty_print () robot . head . pose ( 'tool' ) robot . head . pose ( 'ahead' ) robot . end_of_arm . move_to ( 'wrist_yaw' , 0 ) robot . end_of_arm . move_to ( 'stretch_gripper' , 50 ) robot . end_of_arm . move_to ( 'stretch_gripper' , - 50 ) robot . stow () robot . stop ()","title":"Start Coding"},{"location":"quick_start_guide/#change-credentials","text":"Finally, we recommend that you change the login credentials for the default user, hello-robot. $ sudo passwd hello-robot If you'd like to setup a new user account, check out the Stretch Installation Guide . In a lab setting, it's useful for lab members to have their own user accounts to run experiments.","title":"Change Credentials"},{"location":"quick_start_guide/#power-down","text":"The recommended power down procedure is Place a clamp on the mast below the shoulder to prevent dropping Shutdown the computer from the Desktop When the laser range finder has stopped spinning, turn off the main power switch Attach the charger Place the charger in 12V AGM mode","title":"Power Down"},{"location":"quick_start_guide/#join-the-community-forum","text":"Join the Hello Robot Community . We'd welcome hearing your feedback as you get to know your robot. Hello Robot support monitors the forum closely and will quickly get back to you on any questions or issues you post.","title":"Join the Community Forum"},{"location":"quick_start_guide/#further-exploration","text":"Encounter any issues while getting started? Please let us know at support@hello-robot.com. Also take a minute to review the Stretch Troubleshooting Guide We recommend next exploring the ROS based demos that ship with Stretch. These are found in the stretch_ros repository . That's it. Happy coding! All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Further Exploration"},{"location":"robot_safety_guide/","text":"Robot Safety Guide The Stretch RE1 is a potentially dangerous machine with safety hazards. If improperly used it can cause injury or death. All users must carefully read the following safety information prior to using the robot. Anyone near the robot who has not read this safety information must be closely supervised at all times and made aware that the robot could be dangerous. Only use the robot after inspecting the surrounding environment for potential hazards. Intended Use The Stretch RE1 (\u201cStretch\u201d) is intended for use by researchers to conduct research in controlled indoor environments. This product is not intended for other uses and lacks the required certifications for other uses, such as use in the home by consumers. Safety Hazards As described later in this document, we have designed Stretch to be safer than previous commercially-available human-scale mobile manipulators, so that researchers can explore the future of mobile manipulation. For example, we have made it smaller and lighter weight with backdrivable torque-sensing joints that can stop when they detect contact. Nonetheless, Stretch is a research robot that can be dangerous. It is essential that researchers use Stretch carefully to avoid damage, injury, or death. Here, we list a number of safety hazards that researchers must consider prior to use and during use of Stretch. Stretch Can Put People And Animals At Risk As described in more detail later, Stretch can put people and animals at risk. People and animals near the robot must be closely supervised at all times. At all times, an experienced researcher must carefully monitor the robot and be prepared to stop it. Any people near the robot must be made aware that the robot could be dangerous. Prior to any use of the robot near people or animals, researchers must carefully assess and minimize risks. Researchers who use the robot near children, animals, vulnerable adults, or other people do so at their own risk. Researchers must take appropriate precautions and obtain required approvals from their organizations. Stretch Can Topple Onto A Person The robot may drive off stairs, push or pull itself over with its telescoping arm, fall over while attempting to traverse a threshold, or encounter obstacles that cause it to fall on or otherwise collide with people, causing injury. Operate the robot only on flat surfaces away from stairs or other obstacles that may cause it to topple, and do not allow the robot to push or pull itself over. Stretch Should Not Be Lifted By A Single Person Stretch with the standard gripper weighs about 50.5lb, so two or more people should lift and carry the robot. A single person can move the robot around by enabling the runstop button, tilting it over, and rolling it on flat ground. At least two people should lift and carry the robot when needed. Stretch Can Cause Lacerations The robot wrist and tool have sharp edges that can cause lacerations or punctures to skin or the eyes. Operate the robot away from eyes and other sensitive body parts. Stretch Can Trap, Crush, Or Pinch Body Parts The robot has moving joints that can trap, crush or pinch hands, fingers, or other body parts. The robot could also injure a person or animal by driving over a body part. Keep body parts away from trap, crush, and pinch points during robot motion, including underneath the wheels. Stretch Can Entrap Loose Clothing Or Hair The robot's shoulder and telescoping arm have rollers that can pull in and entrap loose clothing or hair. Keep loose clothing and long hair away from the robot's shoulder and telescoping arm when either is in motion. Stretch Has Flammable Components The robot has polyurethane covers that are flammable and must be kept away from potential ignition sources, such as open flames and hot surfaces. The robot\u2019s head, shoulder, and mobile base have polyurethane covers. Keep the robot away from potential ignition sources and always have a working fire extinguisher nearby. Stretch Is An Electrical Device Stretch has batteries, electronics, wires, and other electrical components throughout its body. It also provides uncovered connectors that provide power. While the robot has fuses to reduce electrical risks, users must be careful. Keep the robot dry and away from liquids, avoid electrical shocks, ensure power cables and wires are in good condition, be careful with the robot\u2019s connectors, and generally exercise caution while working with this electrical device. Stretch Can Perform Dangerous Activities Stretch is a versatile robot capable of performing many actions, including actions that would be dangerous to people. For example, if a dangerous object is held by or affixed to the robot, such as a knife, a heavy object, or breakable glass, the robot can become very dangerous. Likewise, the robot is capable of physically altering the environment in ways that would be dangerous, such as turning a knob that releases gas from a gas stove. Users must be cautious while using the robot to ensure it interacts safely with people and the surrounding environment. Stretch Is An Open Platform That Can Be Made More Dangerous Stretch is an open platform with user-modifiable and user-extensible hardware and software. User changes to the hardware or software can entail serious risks. For example, when shipped, the robot has conservative settings that restrict its speed and the forces it applies to reduce the risks associated with the robot. By modifying the robot, users could enable the robot to move at unsafe speeds and apply unsafe forces. As another example, improper electrical connections could result in a fire. Researchers who choose to modify or extend the robot\u2019s hardware or software do so at their own risk, and should be careful to understand the implications of their modifications or extensions. Changes to the robot could result in dangerous situations that cause injury or death. Additional Risks The most important aspects of safety with Stretch are to use good judgment and common sense. Additional important considerations follow: If the robot appears to be damaged, stop the robot immediately. Always be ready to stop the robot. Do not operate the robot unless an experienced user is present and attentive. Be aware that the robot can move in unexpected ways. Do not put fingers or other objects into the channel that runs along the length of the mast. A belt moves within this channel. Keep an eye on cords, rugs, and any other floor hazards as the robot drives. Keep the robot at least 3 meters from ledges, curbs, stairs, and any other toppling hazard. Do not operate the robot outdoors. Do not attempt to ride the robot. Do not have the robot hold sharp objects. Do not attempt to service the robot without supervision by Hello Robot. Other Problems Will Likely Occur \u201c Anticipate potential problems and hazards. Always imagine what might happen if the robot malfunctions or behaves in a way different from the desired action. Be vigilant.\u201d - PR2 User Manual by Willow Garage from October 5, 2012 Stretch is a complex device that includes many mechanical, electrical, and computational systems that have been designed to work together. Be prepared for something to go wrong. For example, a motor control board might fail, software might not operate as anticipated, an unexpected process might still be running on the robot, or the batteries for the Xbox-style controller or the robot itself might run out. Safety Features We have considered safety from the outset in the design of Stretch. Runstop : The illuminated runstop button on Stretch\u2019s head can be used to pause operation of the four primary joints (base, lift, and arm) of the robot when it is in motion. Lightweight design: The overall mass of Stretch with the standard gripper is 23Kg (50.5lb), and the majority of the mass is in the base. The carbon fiber arm and aluminum mast make for a remarkably lightweight upper body. While this reduces the risk of crushing, crushing injury can still occur and should be carefully monitored. Gravity friendly : Due to Stretch\u2019s design, its actuators don't have to counteract gravity on a large lever arm. As a result, the motors and gearboxes are lower torque and lower weight than a conventional mobile manipulator with a comparable reach, avoiding the often dangerously strong shoulder joints of typical robot arms. Low gear ratio : The primary joints of Stretch (base, lift, and arm) have low gear-ratios (approx 5:1), allowing for backdriving of joints when powered off. A low gear-ratio also reduces the effective inertia of each joint, limiting the impacted force during undesired contacts with people and the environment. Contact Sensitivity : The four primary joints of Stretch (base, lift, and arm) have contact sensitivity. We measure motor currents to estimate contact forces. Because Stretch is a low gear-ratio robot, current sensing provides a fairly sensitive measure of contact forces. Firmware limits : Motor torques are limited at the lowest level of the firmware to configured bounds. Velocity limits : Fast motions of the base are restricted when the arm is up high and the tool is outside the base footprint. This limits the likelihood of toppling or snagging the tool during base motion. Tilt detection : The robot can detect when its body is tilted beyond a safe threshold. The robot can be configured to trigger a runstop event during an over-tilt event. Safety Markings Stretch has the following safety markings: Top of shoulder, indicating potential pinch point between rollers and mast. Top of base, indicating potential pinch point between arm and base. Runstop The runstop allows the user to pause the motion of the four primary actuators (base, lift, and arm) by tapping the illuminated button on the head. An experienced operator should always keep the runstop within reach, allowing them to stop the motion of the robot if it is deemed unsafe. NOTE: The runstop is not equivalent to an Emergency Stop found on industrial equipment and no safety guarantees are made by its function . When the runstop is enabled, these actuators are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume. The runstop logic is: Action Runstop State Button Illumination Robot startup Motion enabled Solid Tap runstop button Motion disabled Flashing at 1Hz Hold down runstop button for >2s Motion enabled Solid Safety Hazard Details Sharp Edges Stretch RE1 is a piece of laboratory equipment. As such, its structure has moderately sharp edges and corners that can be unsafe. These edges can get snagged during motion, or they may cause lacerations when sufficient force is applied to a person. Care should be taken when grasping or otherwise making contact with Stretch that a sharp corner or edge is not contacted. Toppling Stretch is a relatively lightweight robot. In some kinematic configurations a high center of gravity can make it prone to toppling. Toppling can occur when: The mobile base is moving at moderate or fast speed and hits a bump, threshold, or other change in floor property. The arm is raised up high and pushes or pulls on the environment with sufficient force. The robot drives over a drop-off such as a stair or curb. NOTE: While Stretch has cliff sensors, they do not currently inhibit motion of the base. During typical use, the robot will not attempt to stop itself at a cliff, and can fall down stairs and hurt itself or a person. Pinch Points Pinch points around the robot's head, gripper, and wrist can cause discomfort and care should be taken when handling these joints as they move. The shoulder, which travels up and down on the lift, has a series of rollers that ride along the mast. While the shoulder shells can prevent large objects from getting pinched by the rollers, small and thin objects can be pulled into and crushed. The telescoping arm, which extends and retracts, has rollers that ride along the telescoping elements. While the arm link cuffs can reduce the chance of large objects getting pinched, small and thin objects, such as hair, can be pulled in. Extra care should be taken with long hair, clothing, and small fingers around the shoulder rollers. Crush Points The lift degree of freedom is the strongest joint on the robot and as such can apply potentially unsafe forces to a person. The lift, while in motion, may trap or crush objects between the \u2018shoulder\u2019 and another surface. As such, best practices for lift safety should always be used when using the lift degree of freedom. The lift has a max theoretical strength of nearly 200N of linear force. In practice, this force is limited by the lift\u2019s Guarded Move function, which places the lift in Safety Mode when the actuator forces exceed a threshold. The diagrams below show the potential crush points at the top and bottom of the lift range of motion.","title":"Robot Safety Guide"},{"location":"robot_safety_guide/#robot-safety-guide","text":"The Stretch RE1 is a potentially dangerous machine with safety hazards. If improperly used it can cause injury or death. All users must carefully read the following safety information prior to using the robot. Anyone near the robot who has not read this safety information must be closely supervised at all times and made aware that the robot could be dangerous. Only use the robot after inspecting the surrounding environment for potential hazards.","title":"Robot Safety Guide"},{"location":"robot_safety_guide/#intended-use","text":"The Stretch RE1 (\u201cStretch\u201d) is intended for use by researchers to conduct research in controlled indoor environments. This product is not intended for other uses and lacks the required certifications for other uses, such as use in the home by consumers.","title":"Intended Use"},{"location":"robot_safety_guide/#safety-hazards","text":"As described later in this document, we have designed Stretch to be safer than previous commercially-available human-scale mobile manipulators, so that researchers can explore the future of mobile manipulation. For example, we have made it smaller and lighter weight with backdrivable torque-sensing joints that can stop when they detect contact. Nonetheless, Stretch is a research robot that can be dangerous. It is essential that researchers use Stretch carefully to avoid damage, injury, or death. Here, we list a number of safety hazards that researchers must consider prior to use and during use of Stretch.","title":"Safety Hazards"},{"location":"robot_safety_guide/#stretch-can-put-people-and-animals-at-risk","text":"As described in more detail later, Stretch can put people and animals at risk. People and animals near the robot must be closely supervised at all times. At all times, an experienced researcher must carefully monitor the robot and be prepared to stop it. Any people near the robot must be made aware that the robot could be dangerous. Prior to any use of the robot near people or animals, researchers must carefully assess and minimize risks. Researchers who use the robot near children, animals, vulnerable adults, or other people do so at their own risk. Researchers must take appropriate precautions and obtain required approvals from their organizations.","title":"Stretch Can Put People And Animals At Risk"},{"location":"robot_safety_guide/#stretch-can-topple-onto-a-person","text":"The robot may drive off stairs, push or pull itself over with its telescoping arm, fall over while attempting to traverse a threshold, or encounter obstacles that cause it to fall on or otherwise collide with people, causing injury. Operate the robot only on flat surfaces away from stairs or other obstacles that may cause it to topple, and do not allow the robot to push or pull itself over.","title":"Stretch Can Topple Onto A Person"},{"location":"robot_safety_guide/#stretch-should-not-be-lifted-by-a-single-person","text":"Stretch with the standard gripper weighs about 50.5lb, so two or more people should lift and carry the robot. A single person can move the robot around by enabling the runstop button, tilting it over, and rolling it on flat ground. At least two people should lift and carry the robot when needed.","title":"Stretch Should Not Be Lifted By A Single Person"},{"location":"robot_safety_guide/#stretch-can-cause-lacerations","text":"The robot wrist and tool have sharp edges that can cause lacerations or punctures to skin or the eyes. Operate the robot away from eyes and other sensitive body parts.","title":"Stretch Can Cause Lacerations"},{"location":"robot_safety_guide/#stretch-can-trap-crush-or-pinch-body-parts","text":"The robot has moving joints that can trap, crush or pinch hands, fingers, or other body parts. The robot could also injure a person or animal by driving over a body part. Keep body parts away from trap, crush, and pinch points during robot motion, including underneath the wheels.","title":"Stretch Can Trap, Crush, Or Pinch Body Parts"},{"location":"robot_safety_guide/#stretch-can-entrap-loose-clothing-or-hair","text":"The robot's shoulder and telescoping arm have rollers that can pull in and entrap loose clothing or hair. Keep loose clothing and long hair away from the robot's shoulder and telescoping arm when either is in motion.","title":"Stretch Can Entrap Loose Clothing Or Hair"},{"location":"robot_safety_guide/#stretch-has-flammable-components","text":"The robot has polyurethane covers that are flammable and must be kept away from potential ignition sources, such as open flames and hot surfaces. The robot\u2019s head, shoulder, and mobile base have polyurethane covers. Keep the robot away from potential ignition sources and always have a working fire extinguisher nearby.","title":"Stretch Has Flammable Components"},{"location":"robot_safety_guide/#stretch-is-an-electrical-device","text":"Stretch has batteries, electronics, wires, and other electrical components throughout its body. It also provides uncovered connectors that provide power. While the robot has fuses to reduce electrical risks, users must be careful. Keep the robot dry and away from liquids, avoid electrical shocks, ensure power cables and wires are in good condition, be careful with the robot\u2019s connectors, and generally exercise caution while working with this electrical device.","title":"Stretch Is An Electrical Device"},{"location":"robot_safety_guide/#stretch-can-perform-dangerous-activities","text":"Stretch is a versatile robot capable of performing many actions, including actions that would be dangerous to people. For example, if a dangerous object is held by or affixed to the robot, such as a knife, a heavy object, or breakable glass, the robot can become very dangerous. Likewise, the robot is capable of physically altering the environment in ways that would be dangerous, such as turning a knob that releases gas from a gas stove. Users must be cautious while using the robot to ensure it interacts safely with people and the surrounding environment.","title":"Stretch Can Perform Dangerous Activities"},{"location":"robot_safety_guide/#stretch-is-an-open-platform-that-can-be-made-more-dangerous","text":"Stretch is an open platform with user-modifiable and user-extensible hardware and software. User changes to the hardware or software can entail serious risks. For example, when shipped, the robot has conservative settings that restrict its speed and the forces it applies to reduce the risks associated with the robot. By modifying the robot, users could enable the robot to move at unsafe speeds and apply unsafe forces. As another example, improper electrical connections could result in a fire. Researchers who choose to modify or extend the robot\u2019s hardware or software do so at their own risk, and should be careful to understand the implications of their modifications or extensions. Changes to the robot could result in dangerous situations that cause injury or death.","title":"Stretch Is An Open Platform That Can Be Made More Dangerous"},{"location":"robot_safety_guide/#additional-risks","text":"The most important aspects of safety with Stretch are to use good judgment and common sense. Additional important considerations follow: If the robot appears to be damaged, stop the robot immediately. Always be ready to stop the robot. Do not operate the robot unless an experienced user is present and attentive. Be aware that the robot can move in unexpected ways. Do not put fingers or other objects into the channel that runs along the length of the mast. A belt moves within this channel. Keep an eye on cords, rugs, and any other floor hazards as the robot drives. Keep the robot at least 3 meters from ledges, curbs, stairs, and any other toppling hazard. Do not operate the robot outdoors. Do not attempt to ride the robot. Do not have the robot hold sharp objects. Do not attempt to service the robot without supervision by Hello Robot.","title":"Additional Risks"},{"location":"robot_safety_guide/#other-problems-will-likely-occur","text":"\u201c Anticipate potential problems and hazards. Always imagine what might happen if the robot malfunctions or behaves in a way different from the desired action. Be vigilant.\u201d - PR2 User Manual by Willow Garage from October 5, 2012 Stretch is a complex device that includes many mechanical, electrical, and computational systems that have been designed to work together. Be prepared for something to go wrong. For example, a motor control board might fail, software might not operate as anticipated, an unexpected process might still be running on the robot, or the batteries for the Xbox-style controller or the robot itself might run out.","title":"Other Problems Will Likely Occur"},{"location":"robot_safety_guide/#safety-features","text":"We have considered safety from the outset in the design of Stretch. Runstop : The illuminated runstop button on Stretch\u2019s head can be used to pause operation of the four primary joints (base, lift, and arm) of the robot when it is in motion. Lightweight design: The overall mass of Stretch with the standard gripper is 23Kg (50.5lb), and the majority of the mass is in the base. The carbon fiber arm and aluminum mast make for a remarkably lightweight upper body. While this reduces the risk of crushing, crushing injury can still occur and should be carefully monitored. Gravity friendly : Due to Stretch\u2019s design, its actuators don't have to counteract gravity on a large lever arm. As a result, the motors and gearboxes are lower torque and lower weight than a conventional mobile manipulator with a comparable reach, avoiding the often dangerously strong shoulder joints of typical robot arms. Low gear ratio : The primary joints of Stretch (base, lift, and arm) have low gear-ratios (approx 5:1), allowing for backdriving of joints when powered off. A low gear-ratio also reduces the effective inertia of each joint, limiting the impacted force during undesired contacts with people and the environment. Contact Sensitivity : The four primary joints of Stretch (base, lift, and arm) have contact sensitivity. We measure motor currents to estimate contact forces. Because Stretch is a low gear-ratio robot, current sensing provides a fairly sensitive measure of contact forces. Firmware limits : Motor torques are limited at the lowest level of the firmware to configured bounds. Velocity limits : Fast motions of the base are restricted when the arm is up high and the tool is outside the base footprint. This limits the likelihood of toppling or snagging the tool during base motion. Tilt detection : The robot can detect when its body is tilted beyond a safe threshold. The robot can be configured to trigger a runstop event during an over-tilt event.","title":"Safety Features"},{"location":"robot_safety_guide/#safety-markings","text":"Stretch has the following safety markings: Top of shoulder, indicating potential pinch point between rollers and mast. Top of base, indicating potential pinch point between arm and base.","title":"Safety Markings"},{"location":"robot_safety_guide/#runstop","text":"The runstop allows the user to pause the motion of the four primary actuators (base, lift, and arm) by tapping the illuminated button on the head. An experienced operator should always keep the runstop within reach, allowing them to stop the motion of the robot if it is deemed unsafe. NOTE: The runstop is not equivalent to an Emergency Stop found on industrial equipment and no safety guarantees are made by its function . When the runstop is enabled, these actuators are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume. The runstop logic is: Action Runstop State Button Illumination Robot startup Motion enabled Solid Tap runstop button Motion disabled Flashing at 1Hz Hold down runstop button for >2s Motion enabled Solid","title":"Runstop"},{"location":"robot_safety_guide/#safety-hazard-details","text":"","title":"Safety Hazard Details"},{"location":"robot_safety_guide/#sharp-edges","text":"Stretch RE1 is a piece of laboratory equipment. As such, its structure has moderately sharp edges and corners that can be unsafe. These edges can get snagged during motion, or they may cause lacerations when sufficient force is applied to a person. Care should be taken when grasping or otherwise making contact with Stretch that a sharp corner or edge is not contacted.","title":"Sharp Edges"},{"location":"robot_safety_guide/#toppling","text":"Stretch is a relatively lightweight robot. In some kinematic configurations a high center of gravity can make it prone to toppling. Toppling can occur when: The mobile base is moving at moderate or fast speed and hits a bump, threshold, or other change in floor property. The arm is raised up high and pushes or pulls on the environment with sufficient force. The robot drives over a drop-off such as a stair or curb. NOTE: While Stretch has cliff sensors, they do not currently inhibit motion of the base. During typical use, the robot will not attempt to stop itself at a cliff, and can fall down stairs and hurt itself or a person.","title":"Toppling"},{"location":"robot_safety_guide/#pinch-points","text":"Pinch points around the robot's head, gripper, and wrist can cause discomfort and care should be taken when handling these joints as they move. The shoulder, which travels up and down on the lift, has a series of rollers that ride along the mast. While the shoulder shells can prevent large objects from getting pinched by the rollers, small and thin objects can be pulled into and crushed. The telescoping arm, which extends and retracts, has rollers that ride along the telescoping elements. While the arm link cuffs can reduce the chance of large objects getting pinched, small and thin objects, such as hair, can be pulled in. Extra care should be taken with long hair, clothing, and small fingers around the shoulder rollers.","title":"Pinch Points"},{"location":"robot_safety_guide/#crush-points","text":"The lift degree of freedom is the strongest joint on the robot and as such can apply potentially unsafe forces to a person. The lift, while in motion, may trap or crush objects between the \u2018shoulder\u2019 and another surface. As such, best practices for lift safety should always be used when using the lift degree of freedom. The lift has a max theoretical strength of nearly 200N of linear force. In practice, this force is limited by the lift\u2019s Guarded Move function, which places the lift in Safety Mode when the actuator forces exceed a threshold. The diagrams below show the potential crush points at the top and bottom of the lift range of motion.","title":"Crush Points"},{"location":"stretch_body_api/","text":"Stretch Body API Reference Stretch Body is the Python interface to working with the Stretch RE1. This page serves as a reference of the interfaces defined in the stretch_body library. See the Stretch Body Guide for a tutorial to working with this library. The Robot Class Using the Robot class The most common interface to Stretch is the Robot class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 11 import stretch_body.robot r = stretch_body . robot . Robot () if not r . startup (): exit () # failed to start robot! # home the joints to find zero, if necessary if not r . is_calibrated (): r . home () # interact with the robot here The startup() and home() methods starts communication with and homes each of the robot's devices, respectively. Through the Robot class, users can interact with all other devices on the robot. For example, continuing the example above: 12 13 14 15 16 17 18 19 20 21 22 23 # moving joints on the robot r . arm . pretty_print () r . lift . pretty_print () r . base . pretty_print () r . head . pretty_print () r . end_of_arm . pretty_print () # other devices on the robot r . wacc . pretty_print () r . pimu . pretty_print () r . stop () Each of these devices are defined in other modules within stretch_body . In the following section , we'll look at the API of these classes. The stop() method shuts down communication with the robot's devices. All of Robot's subroutines are documented below. stretch_body.robot.Robot ( Device ) API to the Stretch RE1 Robot __init__ ( self ) special startup ( self ) To be called once after class instantiation. Prepares devices for communications and motion Returns bool true if startup of robot succeeded stop ( self ) To be called once before exiting a program Cleanly stops down motion and communication get_status ( self ) Thread safe and atomic read of current Robot status data Returns as a dict. pretty_print ( self ) push_command ( self ) Cause all queued up RPC commands to be sent down to Devices follow_trajectory ( self ) stop_trajectory ( self ) is_calibrated ( self ) Returns true if homing-calibration has been run all joints that require it stow ( self ) Cause the robot to move to its stow position Blocking. home ( self ) Cause the robot to home its joints by moving to hardstops Blocking. The Device Classes The stretch_body library is modular in design. Each subcomponent of Stretch is defined in its own class and the Robot class provides an interface that ties all of these classes together. This modularity allows users to plug in new/modified subcomponents into the Robot interface by extending a device class. It is possible to interface with a single subcomponent of Stretch by initializing its device class directly. In this section, we'll look at the API of seven device classes: the arm , lift , base , head , end of arm , wacc , and pimu subcomponents of Stretch. Using the Arm class The interface to Stretch's telescoping arm is the Arm class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 import stretch_body.arm a = stretch_body . arm . Arm () a . motor . disable_sync_mode () if not a . startup (): exit () # failed to start arm! a . home () # interact with the arm here Since both Arm and Robot subclass Device , the same startup() and stop() methods are available here, as well as other Device methods such as home() . Using the Arm class, we can read the arm's current state and send commands to the joint. For example, continuing the example above: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 starting_position = a . status [ 'pos' ] # move out by 10cm a . move_to ( starting_position + 0.1 ) a . push_command () a . motor . wait_until_at_setpoint () # move back to starting position quickly a . move_to ( starting_position , v_m = 0.2 , a_m = 0.25 ) a . push_command () a . motor . wait_until_at_setpoint () a . move_by ( 0.1 ) # move out by 10cm a . push_command () a . motor . wait_until_at_setpoint () The move_to() and move_by() methods queue absolute and relative commands to the arm respectively, while the nonblocking push_command() method pushes the queued command to the hardware for execution. Arm's attribute motor , an instance of the Stepper class, has wait_until_at_setpoint() which blocks program execution until the joint reaches the commanded goal. With P1 or greater firmware installed, it is also possible to queue a waypoint trajectory for the arm to follow: 26 27 28 29 30 31 32 33 34 35 36 starting_position = a . status [ 'pos' ] # queue a trajectory consisting of four waypoints a . trajectory . add ( t_s = 0 , x_m = starting_position ) a . trajectory . add ( t_s = 3 , x_m = 0.15 ) a . trajectory . add ( t_s = 6 , x_m = 0.1 ) a . trajectory . add ( t_s = 9 , x_m = 0.2 ) # trigger trajectory execution a . follow_trajectory () import time ; time . sleep ( 9 ) Arm's attribute trajectory , an instance of the PrismaticTrajectory class, has add() which adds a single waypoint in a linear sliding trajectory. For a well formed trajectory (see is_valid() ), the follow_trajectory() method kicks off trajectory following for the telescoping arm. It is also possible to dynamically restrict the arm joint's range: 37 38 39 40 41 42 43 44 45 46 47 48 49 50 range_upper_limit = 0.3 # meters # set soft limits on arm's range a . set_soft_motion_limit_min ( 0 ) a . set_soft_motion_limit_max ( range_upper_limit ) a . push_command () # command the arm outside the valid range a . move_to ( 0.4 ) a . push_command () a . motor . wait_until_at_setpoint () print ( a . status [ 'pos' ]) # we should expect to see ~0.3 a . stop () The set_soft_motion_limit_min/max() methods form the basis of an experimental self-collision avoidance system built into Stretch Body. All of Arm's subroutines are documented below. stretch_body.arm.Arm ( Device ) API to the Stretch RE1 Arm __init__ ( self ) special startup ( self , threaded = True ) Starts machinery required to interface with this device Parameters threaded : bool whether a thread manages hardware polling/pushing in the background Returns bool whether the startup procedure succeeded stop ( self ) Shuts down machinery started in startup() pull_status ( self ) push_command ( self ) pretty_print ( self ) get_soft_motion_limits ( self ) Return the currently applied soft motion limits: [min, max] The soft motion limit restricts joint motion to be <= its physical limits. There are three types of limits: Hard: The physical limits Collision: Limits set by RobotCollision to avoid collisions User: Limits set by the user software The joint is limited to the most restrictive range of the Hard / Collision/ User values. Specifying a value of None for a limit indicates that no constraint exists for that limit type. This allows a User limits and Collision limits to coexist. For example, a user can temporarily restrict the range of motion beyond the current collision limits. Then, by commanding User limits of None, the joint limits will revert back to the collision settings. set_soft_motion_limit_min ( self , x , limit_type = 'user' ) x: value to set a joints limit to limit_type: 'user' or 'collision' set_soft_motion_limit_max ( self , x , limit_type = 'user' ) x: value to set a joints limit to limit_type: 'user' or 'collision' set_velocity ( self , v_m , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) move_to ( self , x_m , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) x_m: commanded absolute position (meters). x_m=0 is retracted. x_m=~0.5 is extended v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, retraction direction) req_calibration: Disallow motion prior to homing move_by ( self , x_m , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) x_m: commanded incremental motion (meters). v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, retraction direction) req_calibration: Disallow motion prior to homing follow_trajectory ( self , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True , move_to_start_point = True ) Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method. Parameters v_m : float velocity limit for trajectory in meters per second a_m : float acceleration limit for trajectory in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N : float force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N : float force threshold to stop motion (~Newtons, retraction direction) req_calibration : bool whether to allow motion prior to homing move_to_start_point : bool whether to move to the trajectory's start to avoid a jump, this time to move doesn't count against the trajectory's timeline update_trajectory ( self ) Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method. stop_trajectory ( self ) Stop waypoint trajectory immediately and resets hardware motor_current_to_translate_force ( self , i ) translate_force_to_motor_current ( self , f ) motor_rad_to_translate ( self , ang ) translate_to_motor_rad ( self , arm_m ) home ( self , single_stop = True , measuring = False ) Home to hardstops step_sentry ( self , robot ) Using the Lift class The interface to Stretch's lift is the Lift class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 import stretch_body.lift l = stretch_body . lift . Lift () l . motor . disable_sync_mode () if not l . startup (): exit () # failed to start lift! l . home () # interact with the lift here The startup() and home() methods are extended from the Device class. Reading the lift's current state and sending commands to the joint occurs similarly to the Arm : 11 12 13 14 15 16 starting_position = l . status [ 'pos' ] # move up by 10cm l . move_to ( starting_position + 0.1 ) l . push_command () l . motor . wait_until_at_setpoint () Lift's attribute status is a dictionary of the joint's current status. This state information is updated in the background in real time by default (disable by initializing as startup(threading=False) ). Use the pretty_print() method to print out this state info in a human interpretable format. Setting up waypoint trajectories for the lift is also similar to the Arm : 17 18 19 20 21 22 23 24 25 26 starting_position = l . status [ 'pos' ] # queue a trajectory consisting of three waypoints l . trajectory . add ( t_s = 0 , x_m = starting_position , v_m = 0.0 ) l . trajectory . add ( t_s = 3 , x_m = 0.5 , v_m = 0.0 ) l . trajectory . add ( t_s = 6 , x_m = 0.6 , v_m = 0.0 ) # trigger trajectory execution l . follow_trajectory () import time ; time . sleep ( 6 ) Lift's attribute trajectory is also an instance of the PrismaticTrajectory class, and by providing the instantaneous velocity argument v_m to the add() method, a cubic spline has been loaded into the joint's trajectory . The call to follow_trajectory() begins hardware tracking of the spline. Finally, setting soft motion limits for the lift's range happens using: 27 28 29 30 31 32 # cut out 0.2m from the top and bottom of the lift's range l . set_soft_motion_limit_min ( 0.2 ) l . set_soft_motion_limit_max ( 0.8 ) l . push_command () l . stop () The set_soft_motion_limit_min/max() methods perform clipping of the joint's range at the firmware level (can persist across reboots). All of Lift's subroutines are documented below. stretch_body.lift.Lift ( Device ) API to the Stretch RE1 Lift __init__ ( self ) special startup ( self , threaded = True ) Starts machinery required to interface with this device Parameters threaded : bool whether a thread manages hardware polling/pushing in the background Returns bool whether the startup procedure succeeded stop ( self ) Shuts down machinery started in startup() pull_status ( self ) push_command ( self ) pretty_print ( self ) get_soft_motion_limits ( self ) Return the currently applied soft motion limits: [min, max] The soft motion limit restricts joint motion to be <= its physical limits. There are three types of limits: Hard: The physical limits Collision: Limits set by RobotCollision to avoid collisions User: Limits set by the user software The joint is limited to the most restrictive range of the Hard / Collision/ User values. Specifying a value of None for a limit indicates that no constraint exists for that limit type. This allows a User limits and Collision limits to coexist. For example, a user can temporarily restrict the range of motion beyond the current collision limits. Then, by commanding User limits of None, the joint limits will revert back to the collision settings. set_soft_motion_limit_min ( self , x , limit_type = 'user' ) x: value to set a joints limit to limit_type: 'user' or 'collision' set_soft_motion_limit_max ( self , x , limit_type = 'user' ) x: value to set a joints limit to limit_type: 'user' or 'collision' set_velocity ( self , v_m , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) move_to ( self , x_m , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) x_m: commanded absolute position (meters). x_m=0 is down. x_m=~1.1 is up v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, down direction) req_calibration: Disallow motion prior to homing move_by ( self , x_m , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True ) x_m: commanded incremental motion (meters). v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, down direction) req_calibration: Disallow motion prior to homing follow_trajectory ( self , v_m = None , a_m = None , stiffness = None , contact_thresh_pos_N = None , contact_thresh_neg_N = None , req_calibration = True , move_to_start_point = True ) Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method. Parameters v_m : float velocity limit for trajectory in meters per second a_m : float acceleration limit for trajectory in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N : float force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N : float force threshold to stop motion (~Newtons, down direction) req_calibration : bool whether to allow motion prior to homing move_to_start_point : bool whether to move to the trajectory's start to avoid a jump, this time to move doesn't count against the trajectory's timeline update_trajectory ( self ) Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method. stop_trajectory ( self ) Stop waypoint trajectory immediately and resets hardware motor_current_to_translate_force ( self , i ) translate_force_to_motor_current ( self , f ) motor_rad_to_translate_m ( self , ang ) translate_to_motor_rad ( self , lift_m ) home ( self , measuring = False ) step_sentry ( self , robot ) Using the Base class Item Notes A Drive wheels 4 inch diameter, urethane rubber shore 60A B Cliff sensors Sharp GP2Y0A51SK0F, Analog, range 2-15 cm C Mecanum wheel Diameter 50mm The interface to Stretch's mobile base is the Base class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.base b = stretch_body . base . Base () b . left_wheel . disable_sync_mode () b . right_wheel . disable_sync_mode () if not b . startup (): exit () # failed to start base! # interact with the base here Stretch's mobile base is a differential drive configuration. The left and right wheels are accessible through Base's left_wheel and right_wheel attributes, both of which are instances of the Stepper class. The startup() method is extended from the Device class. Since the mobile base is unconstrained, there is no homing method. We can read the base's current state and send commands using: 10 11 12 13 14 15 16 17 18 19 20 b . pretty_print () # translate forward by 10cm b . translate_by ( 0.1 ) b . push_command () b . left_wheel . wait_until_at_setpoint () # rotate counter-clockwise by 90 degrees b . rotate_by ( 1.57 ) b . push_command () b . left_wheel . wait_until_at_setpoint () The pretty_print() method prints out mobile base state info in a human interpretable format. The translate_by() and rotate_by() methods send relative commands similar to the way move_by() behaves for the single degree of freedom joints. The mobile base also supports velocity control: 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # command the base to translate forward at 5cm / second b . set_translate_velocity ( 0.05 ) b . push_command () import time ; time . sleep ( 1 ) # command the base to rotate counter-clockwise at 0.1rad / second b . set_rotational_velocity ( 0.1 ) b . push_command () time . sleep ( 1 ) # command the base with translational and rotational velocities b . set_velocity ( 0.05 , 0.1 ) b . push_command () time . sleep ( 1 ) # stop base motion b . enable_freewheel_mode () b . push_command () The set_translate_velocity() / set_rotational_velocity() give velocity control over the translational/rotational components of the mobile base independently. The set_velocity() method gives control over both of these components simultaneously. To halt motion, you can command zero velocities or command the base into freewheel mode using enable_freewheel_mode() . The mobile base also supports waypoint trajectory following, but the waypoints are part of the SE2 group (a.k.a. each of the base's desired waypoints is defined as a (x, y) point and a theta orientation): 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # reset odometry calculation b . first_step = True b . pull_status () # queue a trajectory consisting of three waypoints b . trajectory . add ( time = 0 , x = 0.0 , y = 0.0 , theta = 0.0 ) b . trajectory . add ( time = 3 , x = 0.1 , y = 0.0 , theta = 0.0 ) b . trajectory . add ( time = 6 , x = 0.0 , y = 0.0 , theta = 0.0 ) # trigger trajectory execution b . follow_trajectory () import time ; time . sleep ( 6 ) print ( b . status [ 'x' ], b . status [ 'y' ], b . status [ 'theta' ]) # we should expect to see around (0.0, 0.0, 0.0 or 6.28) b . stop () Warning The Base's waypoint trajectory following has no notion of obstacles in the environment. It will blindly follow the commanded waypoints. For obstacle avoidance, perception and a path planner should be employed. Base's attribute trajectory is an instance of the DiffDriveTrajectory class. The call to follow_trajectory() begins hardware tracking of the spline. All of Base's subroutines are documented below. stretch_body.base.Base ( Device ) API to the Stretch RE1 Mobile Base __init__ ( self ) special startup ( self , threaded = True ) Starts machinery required to interface with this device Parameters threaded : bool whether a thread manages hardware polling/pushing in the background Returns bool whether the startup procedure succeeded stop ( self ) Shuts down machinery started in startup() pretty_print ( self ) enable_freewheel_mode ( self ) Force motors into freewheel enable_pos_incr_mode ( self ) Force motors into incremental position mode translate_by ( self , x_m , v_m = None , a_m = None , stiffness = None , contact_thresh_N = None ) Incremental translation of the base x_m: desired motion (m) v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N: force threshold to stop motion (TODO: Not yet implemented) rotate_by ( self , x_r , v_r = None , a_r = None , stiffness = None , contact_thresh_N = None ) Incremental rotation of the base x_r: desired motion (radians) v_r: velocity for trapezoidal motion profile (rad/s) a_r: acceleration for trapezoidal motion profile (rad/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N: force threshold to stop motion (Not yet implemented) set_translate_velocity ( self , v_m , a_m = None ) Command the bases translational velocity. Use care to prevent collisions / avoid runaways v_m: desired velocity (m/s) a_m: acceleration of motion profile (m/s^2) set_rotational_velocity ( self , v_r , a_r = None ) Command the bases rotational velocity. Use care to prevent collisions / avoid runaways v_r: desired rotational velocity (rad/s) a_r: acceleration of motion profile (rad/s^2) set_velocity ( self , v_m , w_r , a = None ) Command the bases translational and rotational velocities simultaneously. Use care to prevent collisions / avoid runaways v_m: desired velocity (m/s) w_r: desired rotational velocity (rad/s) a: acceleration of motion profile (m/s^2 and rad/s^2) follow_trajectory ( self , v_r = None , a_r = None , stiffness = None , contact_thresh_N = None ) Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method. Parameters v_r : float velocity limit for trajectory in motor space in meters per second a_r : float acceleration limit for trajectory in motor space in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N : float force threshold to stop motion (~Newtons) update_trajectory ( self ) Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method. stop_trajectory ( self ) Stop waypoint trajectory immediately and resets hardware step_sentry ( self , robot ) Only allow fast mobile base motion if the lift is low, the arm is retracted, and the wrist is stowed. This is intended to keep the center of mass low for increased stability and avoid catching the arm or tool on something. push_command ( self ) pull_status ( self ) Computes base odometery based on stepper positions / velocities motor_current_to_translation_force ( self , il , ir ) motor_current_to_rotation_torque ( self , il , ir ) translation_force_to_motor_current ( self , f_N ) rotation_torque_to_motor_current ( self , tq_Nm ) translate_to_motor_rad ( self , x_m ) motor_rad_to_translate ( self , x_r ) rotate_to_motor_rad ( self , x_r ) motor_rad_to_rotate ( self , x_r ) translation_to_rotation ( self , x_m ) rotation_to_translation ( self , x_r ) Using the Head class The interface to Stretch's head is the Head class. Stretch's head contains a Intel Realsense D435i depth camera, so the pan/tilt joints in the head allows Stretch to swivel and capture depth imagery of its surrounding. The head is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.head h = stretch_body . head . Head () if not h . startup (): exit () # failed to start head! h . home () # interact with the head here Head is a subclass of DynamixelXChain , which in turn subclasses the Device class. Therefore, some of Head's methods, such as startup() and home() methods are extended from the Device class, while other come from the DynamixelXChain class. Reading the head's current state and sending commands to its revolute joints (head pan and tilt) happens using: 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 starting_position = h . status [ 'head_pan' ][ 'pos' ] # look right by 90 degrees h . move_to ( 'head_pan' , starting_position + 1.57 ) h . get_joint ( 'head_pan' ) . wait_until_at_setpoint () # tilt up by 30 degrees h . move_by ( 'head_tilt' , - 1.57 / 3 ) h . get_joint ( 'head_tilt' ) . wait_until_at_setpoint () # look down towards the wheels h . pose ( 'wheels' ) import time ; time . sleep ( 3 ) # look ahead h . pose ( 'ahead' ) time . sleep ( 3 ) Head's attribute status is a dictionary of dictionaries, where each subdictionary is the status of one of the head's joints. This state information is updated in the background in real time by default (disable by initializing as startup(threading=False) ). Use the pretty_print() method to print out this state info in a human interpretable format. Commanding the head's revolute joints is done through the move_to() and move_by() methods. Notice that unlike the previous joints, no push command call is required here. These joints are Dynamixel servos, which behave differently than the Hello Robot steppers. Their commands are not queued; they're executed as soon as they're received. Head's two joints, the 'head_pan' and 'head_tilt', are instances of the DynamixelHelloXL430 class, and are retreiveable using the get_joint() method. They have the wait_until_at_setpoint() method, which blocks program execution until the joint reaches the commanded goal. The pose() method makes it easy to command the head to common head poses (e.g. looking 'ahead', at the end of arm 'tool', obstacles in front of the 'wheels', or 'up'). The head supports waypoint trajectories as well: 27 28 29 30 31 32 33 34 35 36 37 # queue a trajectory consisting of three waypoints h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 0 , x_r = 0.0 ) h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 3 , x_r =- 1.0 ) h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 6 , x_r = 0.0 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 0 , x_r = 0.1 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 3 , x_r =- 0.9 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 6 , x_r = 0.1 ) # trigger trajectory execution h . follow_trajectory () import time ; time . sleep ( 6 ) The head pan/tilt DynamixelHelloXL430 instances have an attribute trajectory , which is an instance of the RevoluteTrajectory class. The call to follow_trajectory() begins software tracking of the spline. Finally, setting soft motion limits for the head's pan/tilt range happens using: 38 39 40 41 42 43 44 45 46 # clip the head_pan's range h . get_joint ( 'head_pan' ) . set_soft_motion_limit_min ( - 1.0 ) h . get_joint ( 'head_pan' ) . set_soft_motion_limit_max ( 1.0 ) # clip the head_tilt's range h . get_joint ( 'head_tilt' ) . set_soft_motion_limit_min ( - 1.0 ) h . get_joint ( 'head_tilt' ) . set_soft_motion_limit_max ( 0.1 ) h . stop () The set_soft_motion_limit_min/max() methods perform clipping of the joint's range at the software level (cannot persist across reboots). All of Head's subroutines are documented below. stretch_body.head.Head ( DynamixelXChain ) API to the Stretch RE1 Head __init__ ( self ) special startup ( self , threaded = True ) Starts machinery required to interface with this device Parameters threaded : bool whether a thread manages hardware polling/pushing in the background Returns bool whether the startup procedure succeeded get_joint ( self , joint_name ) Retrieves joint by name. Parameters joint_name : str valid joints defined in joints Returns DynamixelHelloXL430 or None Motor object on valid joint name, else None move_to ( self , joint , x_r , v_r = None , a_r = None ) joint: Name of the joint to move ('head_pan' or 'head_tilt') x_r: commanded absolute position (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2) move_by ( self , joint , x_r , v_r = None , a_r = None ) joint: Name of the joint to move ('head_pan' or 'head_tilt') x_r: commanded incremental motion (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2) home ( self ) pose ( self , p , v_r = [ None , None ], a_r = [ None , None ]) p: Dictionary key to named pose (eg 'ahead') v_r: list, velocities for trapezoidal motion profile (rad/s). a_r: list, accelerations for trapezoidal motion profile (rad/s^2) Using the EndOfArm class The interface to Stretch's end of arm is the EndOfArm class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.end_of_arm e = stretch_body . end_of_arm . EndOfArm () if not e . startup ( threaded = True ): exit () # failed to start end of arm! # interact with the end of arm here e . stop () EndOfArm's subroutines are documented below. stretch_body.end_of_arm.EndOfArm ( DynamixelXChain ) The EndOfArm class allows for an extensible serial chain of Dynamixel X series devices It allows the specific type of device to be declared at runtime via the Yaml parameters In this way, a user can add their own custom Dynamixel based tools to the robot end-of-arm by simply deriving it from DynamixelHelloXL430 and declaring the class name / Python module name in the User YAML file __init__ ( self , name = 'end_of_arm' ) special startup ( self , threaded = True ) Starts machinery required to interface with this device Parameters threaded : bool whether a thread manages hardware polling/pushing in the background Returns bool whether the startup procedure succeeded get_joint ( self , joint_name ) Retrieves joint by name. Parameters joint_name : str valid joints defined as defined in params['devices'] Returns DynamixelHelloXL430 or None Motor object on valid joint name, else None move_to ( self , joint , x_r , v_r = None , a_r = None ) joint: name of joint (string) x_r: commanded absolute position (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2) move_by ( self , joint , x_r , v_r = None , a_r = None ) joint: name of joint (string) x_r: commanded incremental motion (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2) pose ( self , joint , p , v_r = None , a_r = None ) joint: name of joint (string) p: named pose of joint v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2) stow ( self ) home ( self , joint = None ) Home to hardstops is_tool_present ( self , class_name ) Return true if the given tool type is present (eg. StretchGripper) Allows for conditional logic when switching end-of-arm tools Using the Wacc class The interface to Stretch's wrist board is the Wacc (wrist + accelerometer) class. This board provides an Arduino and accelerometer sensor that is accessible from the Wacc class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.wacc w = stretch_body . wacc . Wacc () if not w . startup ( threaded = True ): exit () # failed to start wacc! # interact with the wacc here w . stop () Wacc's subroutines are documented below. stretch_body.wacc.Wacc ( WaccBase ) API to the Stretch RE1 Power and IMU board (Pimu) __init__ ( self ) special startup ( self , threaded = False ) First determine which protocol version the uC firmware is running. Based on that version, replaces PimuBase class inheritance with a inheritance to a child class of PimuBase that supports that protocol Using the Pimu class The interface to Stretch's power board is the Pimu (power + IMU) class. This board provides an 9 DOF IMUthat is accessible from the Pimu class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.pimu p = stretch_body . pimu . Pimu () if not p . startup ( threaded = True ): exit () # failed to start pimu! # interact with the pimu here p . stop () Pimu's subroutines are documented below. stretch_body.pimu.Pimu ( PimuBase ) API to the Stretch RE1 Power and IMU board (Pimu) __init__ ( self , event_reset = False ) special startup ( self , threaded = False ) First determine which protocol version the uC firmware is running. Based on that version, replaces PimuBase class inheritance with a inheritance to a child class of PimuBase that supports that protocol All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch Body API Reference"},{"location":"stretch_body_api/#stretch-body-api-reference","text":"Stretch Body is the Python interface to working with the Stretch RE1. This page serves as a reference of the interfaces defined in the stretch_body library. See the Stretch Body Guide for a tutorial to working with this library.","title":"Stretch Body API Reference"},{"location":"stretch_body_api/#the-robot-class","text":"","title":"The Robot Class"},{"location":"stretch_body_api/#using-the-robot-class","text":"The most common interface to Stretch is the Robot class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 11 import stretch_body.robot r = stretch_body . robot . Robot () if not r . startup (): exit () # failed to start robot! # home the joints to find zero, if necessary if not r . is_calibrated (): r . home () # interact with the robot here The startup() and home() methods starts communication with and homes each of the robot's devices, respectively. Through the Robot class, users can interact with all other devices on the robot. For example, continuing the example above: 12 13 14 15 16 17 18 19 20 21 22 23 # moving joints on the robot r . arm . pretty_print () r . lift . pretty_print () r . base . pretty_print () r . head . pretty_print () r . end_of_arm . pretty_print () # other devices on the robot r . wacc . pretty_print () r . pimu . pretty_print () r . stop () Each of these devices are defined in other modules within stretch_body . In the following section , we'll look at the API of these classes. The stop() method shuts down communication with the robot's devices. All of Robot's subroutines are documented below.","title":"Using the Robot class"},{"location":"stretch_body_api/#stretch_body.robot.Robot","text":"API to the Stretch RE1 Robot","title":"Robot"},{"location":"stretch_body_api/#stretch_body.robot.Robot.__init__","text":"","title":"__init__()"},{"location":"stretch_body_api/#stretch_body.robot.Robot.startup","text":"To be called once after class instantiation. Prepares devices for communications and motion","title":"startup()"},{"location":"stretch_body_api/#stretch_body.robot.Robot.startup--returns","text":"bool true if startup of robot succeeded","title":"Returns"},{"location":"stretch_body_api/#stretch_body.robot.Robot.stop","text":"To be called once before exiting a program Cleanly stops down motion and communication","title":"stop()"},{"location":"stretch_body_api/#stretch_body.robot.Robot.get_status","text":"Thread safe and atomic read of current Robot status data Returns as a dict.","title":"get_status()"},{"location":"stretch_body_api/#stretch_body.robot.Robot.pretty_print","text":"","title":"pretty_print()"},{"location":"stretch_body_api/#stretch_body.robot.Robot.push_command","text":"Cause all queued up RPC commands to be sent down to Devices","title":"push_command()"},{"location":"stretch_body_api/#stretch_body.robot.Robot.follow_trajectory","text":"","title":"follow_trajectory()"},{"location":"stretch_body_api/#stretch_body.robot.Robot.stop_trajectory","text":"","title":"stop_trajectory()"},{"location":"stretch_body_api/#stretch_body.robot.Robot.is_calibrated","text":"Returns true if homing-calibration has been run all joints that require it","title":"is_calibrated()"},{"location":"stretch_body_api/#stretch_body.robot.Robot.stow","text":"Cause the robot to move to its stow position Blocking.","title":"stow()"},{"location":"stretch_body_api/#stretch_body.robot.Robot.home","text":"Cause the robot to home its joints by moving to hardstops Blocking.","title":"home()"},{"location":"stretch_body_api/#the-device-classes","text":"The stretch_body library is modular in design. Each subcomponent of Stretch is defined in its own class and the Robot class provides an interface that ties all of these classes together. This modularity allows users to plug in new/modified subcomponents into the Robot interface by extending a device class. It is possible to interface with a single subcomponent of Stretch by initializing its device class directly. In this section, we'll look at the API of seven device classes: the arm , lift , base , head , end of arm , wacc , and pimu subcomponents of Stretch.","title":"The Device Classes"},{"location":"stretch_body_api/#using-the-arm-class","text":"The interface to Stretch's telescoping arm is the Arm class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 import stretch_body.arm a = stretch_body . arm . Arm () a . motor . disable_sync_mode () if not a . startup (): exit () # failed to start arm! a . home () # interact with the arm here Since both Arm and Robot subclass Device , the same startup() and stop() methods are available here, as well as other Device methods such as home() . Using the Arm class, we can read the arm's current state and send commands to the joint. For example, continuing the example above: 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 starting_position = a . status [ 'pos' ] # move out by 10cm a . move_to ( starting_position + 0.1 ) a . push_command () a . motor . wait_until_at_setpoint () # move back to starting position quickly a . move_to ( starting_position , v_m = 0.2 , a_m = 0.25 ) a . push_command () a . motor . wait_until_at_setpoint () a . move_by ( 0.1 ) # move out by 10cm a . push_command () a . motor . wait_until_at_setpoint () The move_to() and move_by() methods queue absolute and relative commands to the arm respectively, while the nonblocking push_command() method pushes the queued command to the hardware for execution. Arm's attribute motor , an instance of the Stepper class, has wait_until_at_setpoint() which blocks program execution until the joint reaches the commanded goal. With P1 or greater firmware installed, it is also possible to queue a waypoint trajectory for the arm to follow: 26 27 28 29 30 31 32 33 34 35 36 starting_position = a . status [ 'pos' ] # queue a trajectory consisting of four waypoints a . trajectory . add ( t_s = 0 , x_m = starting_position ) a . trajectory . add ( t_s = 3 , x_m = 0.15 ) a . trajectory . add ( t_s = 6 , x_m = 0.1 ) a . trajectory . add ( t_s = 9 , x_m = 0.2 ) # trigger trajectory execution a . follow_trajectory () import time ; time . sleep ( 9 ) Arm's attribute trajectory , an instance of the PrismaticTrajectory class, has add() which adds a single waypoint in a linear sliding trajectory. For a well formed trajectory (see is_valid() ), the follow_trajectory() method kicks off trajectory following for the telescoping arm. It is also possible to dynamically restrict the arm joint's range: 37 38 39 40 41 42 43 44 45 46 47 48 49 50 range_upper_limit = 0.3 # meters # set soft limits on arm's range a . set_soft_motion_limit_min ( 0 ) a . set_soft_motion_limit_max ( range_upper_limit ) a . push_command () # command the arm outside the valid range a . move_to ( 0.4 ) a . push_command () a . motor . wait_until_at_setpoint () print ( a . status [ 'pos' ]) # we should expect to see ~0.3 a . stop () The set_soft_motion_limit_min/max() methods form the basis of an experimental self-collision avoidance system built into Stretch Body. All of Arm's subroutines are documented below.","title":"Using the Arm class"},{"location":"stretch_body_api/#stretch_body.arm.Arm","text":"API to the Stretch RE1 Arm","title":"Arm"},{"location":"stretch_body_api/#stretch_body.arm.Arm.__init__","text":"","title":"__init__()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.startup","text":"Starts machinery required to interface with this device","title":"startup()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.startup--parameters","text":"threaded : bool whether a thread manages hardware polling/pushing in the background","title":"Parameters"},{"location":"stretch_body_api/#stretch_body.arm.Arm.startup--returns","text":"bool whether the startup procedure succeeded","title":"Returns"},{"location":"stretch_body_api/#stretch_body.arm.Arm.stop","text":"Shuts down machinery started in startup()","title":"stop()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.pull_status","text":"","title":"pull_status()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.push_command","text":"","title":"push_command()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.pretty_print","text":"","title":"pretty_print()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.get_soft_motion_limits","text":"Return the currently applied soft motion limits: [min, max] The soft motion limit restricts joint motion to be <= its physical limits. There are three types of limits: Hard: The physical limits Collision: Limits set by RobotCollision to avoid collisions User: Limits set by the user software The joint is limited to the most restrictive range of the Hard / Collision/ User values. Specifying a value of None for a limit indicates that no constraint exists for that limit type. This allows a User limits and Collision limits to coexist. For example, a user can temporarily restrict the range of motion beyond the current collision limits. Then, by commanding User limits of None, the joint limits will revert back to the collision settings.","title":"get_soft_motion_limits()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.set_soft_motion_limit_min","text":"x: value to set a joints limit to limit_type: 'user' or 'collision'","title":"set_soft_motion_limit_min()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.set_soft_motion_limit_max","text":"x: value to set a joints limit to limit_type: 'user' or 'collision'","title":"set_soft_motion_limit_max()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.set_velocity","text":"","title":"set_velocity()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.move_to","text":"x_m: commanded absolute position (meters). x_m=0 is retracted. x_m=~0.5 is extended v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, retraction direction) req_calibration: Disallow motion prior to homing","title":"move_to()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.move_by","text":"x_m: commanded incremental motion (meters). v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, retraction direction) req_calibration: Disallow motion prior to homing","title":"move_by()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.follow_trajectory","text":"Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method.","title":"follow_trajectory()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.follow_trajectory--parameters","text":"v_m : float velocity limit for trajectory in meters per second a_m : float acceleration limit for trajectory in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N : float force threshold to stop motion (~Newtons, extension direction) contact_thresh_neg_N : float force threshold to stop motion (~Newtons, retraction direction) req_calibration : bool whether to allow motion prior to homing move_to_start_point : bool whether to move to the trajectory's start to avoid a jump, this time to move doesn't count against the trajectory's timeline","title":"Parameters"},{"location":"stretch_body_api/#stretch_body.arm.Arm.update_trajectory","text":"Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method.","title":"update_trajectory()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.stop_trajectory","text":"Stop waypoint trajectory immediately and resets hardware","title":"stop_trajectory()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.motor_current_to_translate_force","text":"","title":"motor_current_to_translate_force()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.translate_force_to_motor_current","text":"","title":"translate_force_to_motor_current()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.motor_rad_to_translate","text":"","title":"motor_rad_to_translate()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.translate_to_motor_rad","text":"","title":"translate_to_motor_rad()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.home","text":"Home to hardstops","title":"home()"},{"location":"stretch_body_api/#stretch_body.arm.Arm.step_sentry","text":"","title":"step_sentry()"},{"location":"stretch_body_api/#using-the-lift-class","text":"The interface to Stretch's lift is the Lift class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 10 import stretch_body.lift l = stretch_body . lift . Lift () l . motor . disable_sync_mode () if not l . startup (): exit () # failed to start lift! l . home () # interact with the lift here The startup() and home() methods are extended from the Device class. Reading the lift's current state and sending commands to the joint occurs similarly to the Arm : 11 12 13 14 15 16 starting_position = l . status [ 'pos' ] # move up by 10cm l . move_to ( starting_position + 0.1 ) l . push_command () l . motor . wait_until_at_setpoint () Lift's attribute status is a dictionary of the joint's current status. This state information is updated in the background in real time by default (disable by initializing as startup(threading=False) ). Use the pretty_print() method to print out this state info in a human interpretable format. Setting up waypoint trajectories for the lift is also similar to the Arm : 17 18 19 20 21 22 23 24 25 26 starting_position = l . status [ 'pos' ] # queue a trajectory consisting of three waypoints l . trajectory . add ( t_s = 0 , x_m = starting_position , v_m = 0.0 ) l . trajectory . add ( t_s = 3 , x_m = 0.5 , v_m = 0.0 ) l . trajectory . add ( t_s = 6 , x_m = 0.6 , v_m = 0.0 ) # trigger trajectory execution l . follow_trajectory () import time ; time . sleep ( 6 ) Lift's attribute trajectory is also an instance of the PrismaticTrajectory class, and by providing the instantaneous velocity argument v_m to the add() method, a cubic spline has been loaded into the joint's trajectory . The call to follow_trajectory() begins hardware tracking of the spline. Finally, setting soft motion limits for the lift's range happens using: 27 28 29 30 31 32 # cut out 0.2m from the top and bottom of the lift's range l . set_soft_motion_limit_min ( 0.2 ) l . set_soft_motion_limit_max ( 0.8 ) l . push_command () l . stop () The set_soft_motion_limit_min/max() methods perform clipping of the joint's range at the firmware level (can persist across reboots). All of Lift's subroutines are documented below.","title":"Using the Lift class"},{"location":"stretch_body_api/#stretch_body.lift.Lift","text":"API to the Stretch RE1 Lift","title":"Lift"},{"location":"stretch_body_api/#stretch_body.lift.Lift.__init__","text":"","title":"__init__()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.startup","text":"Starts machinery required to interface with this device","title":"startup()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.startup--parameters","text":"threaded : bool whether a thread manages hardware polling/pushing in the background","title":"Parameters"},{"location":"stretch_body_api/#stretch_body.lift.Lift.startup--returns","text":"bool whether the startup procedure succeeded","title":"Returns"},{"location":"stretch_body_api/#stretch_body.lift.Lift.stop","text":"Shuts down machinery started in startup()","title":"stop()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.pull_status","text":"","title":"pull_status()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.push_command","text":"","title":"push_command()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.pretty_print","text":"","title":"pretty_print()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.get_soft_motion_limits","text":"Return the currently applied soft motion limits: [min, max] The soft motion limit restricts joint motion to be <= its physical limits. There are three types of limits: Hard: The physical limits Collision: Limits set by RobotCollision to avoid collisions User: Limits set by the user software The joint is limited to the most restrictive range of the Hard / Collision/ User values. Specifying a value of None for a limit indicates that no constraint exists for that limit type. This allows a User limits and Collision limits to coexist. For example, a user can temporarily restrict the range of motion beyond the current collision limits. Then, by commanding User limits of None, the joint limits will revert back to the collision settings.","title":"get_soft_motion_limits()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.set_soft_motion_limit_min","text":"x: value to set a joints limit to limit_type: 'user' or 'collision'","title":"set_soft_motion_limit_min()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.set_soft_motion_limit_max","text":"x: value to set a joints limit to limit_type: 'user' or 'collision'","title":"set_soft_motion_limit_max()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.set_velocity","text":"","title":"set_velocity()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.move_to","text":"x_m: commanded absolute position (meters). x_m=0 is down. x_m=~1.1 is up v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, down direction) req_calibration: Disallow motion prior to homing","title":"move_to()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.move_by","text":"x_m: commanded incremental motion (meters). v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N: force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N: force threshold to stop motion (~Newtons, down direction) req_calibration: Disallow motion prior to homing","title":"move_by()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.follow_trajectory","text":"Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method.","title":"follow_trajectory()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.follow_trajectory--parameters","text":"v_m : float velocity limit for trajectory in meters per second a_m : float acceleration limit for trajectory in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_pos_N : float force threshold to stop motion (~Newtons, up direction) contact_thresh_neg_N : float force threshold to stop motion (~Newtons, down direction) req_calibration : bool whether to allow motion prior to homing move_to_start_point : bool whether to move to the trajectory's start to avoid a jump, this time to move doesn't count against the trajectory's timeline","title":"Parameters"},{"location":"stretch_body_api/#stretch_body.lift.Lift.update_trajectory","text":"Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method.","title":"update_trajectory()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.stop_trajectory","text":"Stop waypoint trajectory immediately and resets hardware","title":"stop_trajectory()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.motor_current_to_translate_force","text":"","title":"motor_current_to_translate_force()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.translate_force_to_motor_current","text":"","title":"translate_force_to_motor_current()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.motor_rad_to_translate_m","text":"","title":"motor_rad_to_translate_m()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.translate_to_motor_rad","text":"","title":"translate_to_motor_rad()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.home","text":"","title":"home()"},{"location":"stretch_body_api/#stretch_body.lift.Lift.step_sentry","text":"","title":"step_sentry()"},{"location":"stretch_body_api/#using-the-base-class","text":"Item Notes A Drive wheels 4 inch diameter, urethane rubber shore 60A B Cliff sensors Sharp GP2Y0A51SK0F, Analog, range 2-15 cm C Mecanum wheel Diameter 50mm The interface to Stretch's mobile base is the Base class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.base b = stretch_body . base . Base () b . left_wheel . disable_sync_mode () b . right_wheel . disable_sync_mode () if not b . startup (): exit () # failed to start base! # interact with the base here Stretch's mobile base is a differential drive configuration. The left and right wheels are accessible through Base's left_wheel and right_wheel attributes, both of which are instances of the Stepper class. The startup() method is extended from the Device class. Since the mobile base is unconstrained, there is no homing method. We can read the base's current state and send commands using: 10 11 12 13 14 15 16 17 18 19 20 b . pretty_print () # translate forward by 10cm b . translate_by ( 0.1 ) b . push_command () b . left_wheel . wait_until_at_setpoint () # rotate counter-clockwise by 90 degrees b . rotate_by ( 1.57 ) b . push_command () b . left_wheel . wait_until_at_setpoint () The pretty_print() method prints out mobile base state info in a human interpretable format. The translate_by() and rotate_by() methods send relative commands similar to the way move_by() behaves for the single degree of freedom joints. The mobile base also supports velocity control: 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # command the base to translate forward at 5cm / second b . set_translate_velocity ( 0.05 ) b . push_command () import time ; time . sleep ( 1 ) # command the base to rotate counter-clockwise at 0.1rad / second b . set_rotational_velocity ( 0.1 ) b . push_command () time . sleep ( 1 ) # command the base with translational and rotational velocities b . set_velocity ( 0.05 , 0.1 ) b . push_command () time . sleep ( 1 ) # stop base motion b . enable_freewheel_mode () b . push_command () The set_translate_velocity() / set_rotational_velocity() give velocity control over the translational/rotational components of the mobile base independently. The set_velocity() method gives control over both of these components simultaneously. To halt motion, you can command zero velocities or command the base into freewheel mode using enable_freewheel_mode() . The mobile base also supports waypoint trajectory following, but the waypoints are part of the SE2 group (a.k.a. each of the base's desired waypoints is defined as a (x, y) point and a theta orientation): 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # reset odometry calculation b . first_step = True b . pull_status () # queue a trajectory consisting of three waypoints b . trajectory . add ( time = 0 , x = 0.0 , y = 0.0 , theta = 0.0 ) b . trajectory . add ( time = 3 , x = 0.1 , y = 0.0 , theta = 0.0 ) b . trajectory . add ( time = 6 , x = 0.0 , y = 0.0 , theta = 0.0 ) # trigger trajectory execution b . follow_trajectory () import time ; time . sleep ( 6 ) print ( b . status [ 'x' ], b . status [ 'y' ], b . status [ 'theta' ]) # we should expect to see around (0.0, 0.0, 0.0 or 6.28) b . stop () Warning The Base's waypoint trajectory following has no notion of obstacles in the environment. It will blindly follow the commanded waypoints. For obstacle avoidance, perception and a path planner should be employed. Base's attribute trajectory is an instance of the DiffDriveTrajectory class. The call to follow_trajectory() begins hardware tracking of the spline. All of Base's subroutines are documented below.","title":"Using the Base class"},{"location":"stretch_body_api/#stretch_body.base.Base","text":"API to the Stretch RE1 Mobile Base","title":"Base"},{"location":"stretch_body_api/#stretch_body.base.Base.__init__","text":"","title":"__init__()"},{"location":"stretch_body_api/#stretch_body.base.Base.startup","text":"Starts machinery required to interface with this device","title":"startup()"},{"location":"stretch_body_api/#stretch_body.base.Base.startup--parameters","text":"threaded : bool whether a thread manages hardware polling/pushing in the background","title":"Parameters"},{"location":"stretch_body_api/#stretch_body.base.Base.startup--returns","text":"bool whether the startup procedure succeeded","title":"Returns"},{"location":"stretch_body_api/#stretch_body.base.Base.stop","text":"Shuts down machinery started in startup()","title":"stop()"},{"location":"stretch_body_api/#stretch_body.base.Base.pretty_print","text":"","title":"pretty_print()"},{"location":"stretch_body_api/#stretch_body.base.Base.enable_freewheel_mode","text":"Force motors into freewheel","title":"enable_freewheel_mode()"},{"location":"stretch_body_api/#stretch_body.base.Base.enable_pos_incr_mode","text":"Force motors into incremental position mode","title":"enable_pos_incr_mode()"},{"location":"stretch_body_api/#stretch_body.base.Base.translate_by","text":"Incremental translation of the base x_m: desired motion (m) v_m: velocity for trapezoidal motion profile (m/s) a_m: acceleration for trapezoidal motion profile (m/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N: force threshold to stop motion (TODO: Not yet implemented)","title":"translate_by()"},{"location":"stretch_body_api/#stretch_body.base.Base.rotate_by","text":"Incremental rotation of the base x_r: desired motion (radians) v_r: velocity for trapezoidal motion profile (rad/s) a_r: acceleration for trapezoidal motion profile (rad/s^2) stiffness: stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N: force threshold to stop motion (Not yet implemented)","title":"rotate_by()"},{"location":"stretch_body_api/#stretch_body.base.Base.set_translate_velocity","text":"Command the bases translational velocity. Use care to prevent collisions / avoid runaways v_m: desired velocity (m/s) a_m: acceleration of motion profile (m/s^2)","title":"set_translate_velocity()"},{"location":"stretch_body_api/#stretch_body.base.Base.set_rotational_velocity","text":"Command the bases rotational velocity. Use care to prevent collisions / avoid runaways v_r: desired rotational velocity (rad/s) a_r: acceleration of motion profile (rad/s^2)","title":"set_rotational_velocity()"},{"location":"stretch_body_api/#stretch_body.base.Base.set_velocity","text":"Command the bases translational and rotational velocities simultaneously. Use care to prevent collisions / avoid runaways v_m: desired velocity (m/s) w_r: desired rotational velocity (rad/s) a: acceleration of motion profile (m/s^2 and rad/s^2)","title":"set_velocity()"},{"location":"stretch_body_api/#stretch_body.base.Base.follow_trajectory","text":"Starts executing a waypoint trajectory self.trajectory must be populated with a valid trajectory before calling this method.","title":"follow_trajectory()"},{"location":"stretch_body_api/#stretch_body.base.Base.follow_trajectory--parameters","text":"v_r : float velocity limit for trajectory in motor space in meters per second a_r : float acceleration limit for trajectory in motor space in meters per second squared stiffness : float stiffness of motion. Range 0.0 (min) to 1.0 (max) contact_thresh_N : float force threshold to stop motion (~Newtons)","title":"Parameters"},{"location":"stretch_body_api/#stretch_body.base.Base.update_trajectory","text":"Updates hardware with the next segment of self.trajectory This method must be called frequently to enable complete trajectory execution and preemption of future segments. If used with stretch_body.robot.Robot or with self.startup(threaded=True) , a background thread is launched for this. Otherwise, the user must handle calling this method.","title":"update_trajectory()"},{"location":"stretch_body_api/#stretch_body.base.Base.stop_trajectory","text":"Stop waypoint trajectory immediately and resets hardware","title":"stop_trajectory()"},{"location":"stretch_body_api/#stretch_body.base.Base.step_sentry","text":"Only allow fast mobile base motion if the lift is low, the arm is retracted, and the wrist is stowed. This is intended to keep the center of mass low for increased stability and avoid catching the arm or tool on something.","title":"step_sentry()"},{"location":"stretch_body_api/#stretch_body.base.Base.push_command","text":"","title":"push_command()"},{"location":"stretch_body_api/#stretch_body.base.Base.pull_status","text":"Computes base odometery based on stepper positions / velocities","title":"pull_status()"},{"location":"stretch_body_api/#stretch_body.base.Base.motor_current_to_translation_force","text":"","title":"motor_current_to_translation_force()"},{"location":"stretch_body_api/#stretch_body.base.Base.motor_current_to_rotation_torque","text":"","title":"motor_current_to_rotation_torque()"},{"location":"stretch_body_api/#stretch_body.base.Base.translation_force_to_motor_current","text":"","title":"translation_force_to_motor_current()"},{"location":"stretch_body_api/#stretch_body.base.Base.rotation_torque_to_motor_current","text":"","title":"rotation_torque_to_motor_current()"},{"location":"stretch_body_api/#stretch_body.base.Base.translate_to_motor_rad","text":"","title":"translate_to_motor_rad()"},{"location":"stretch_body_api/#stretch_body.base.Base.motor_rad_to_translate","text":"","title":"motor_rad_to_translate()"},{"location":"stretch_body_api/#stretch_body.base.Base.rotate_to_motor_rad","text":"","title":"rotate_to_motor_rad()"},{"location":"stretch_body_api/#stretch_body.base.Base.motor_rad_to_rotate","text":"","title":"motor_rad_to_rotate()"},{"location":"stretch_body_api/#stretch_body.base.Base.translation_to_rotation","text":"","title":"translation_to_rotation()"},{"location":"stretch_body_api/#stretch_body.base.Base.rotation_to_translation","text":"","title":"rotation_to_translation()"},{"location":"stretch_body_api/#using-the-head-class","text":"The interface to Stretch's head is the Head class. Stretch's head contains a Intel Realsense D435i depth camera, so the pan/tilt joints in the head allows Stretch to swivel and capture depth imagery of its surrounding. The head is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.head h = stretch_body . head . Head () if not h . startup (): exit () # failed to start head! h . home () # interact with the head here Head is a subclass of DynamixelXChain , which in turn subclasses the Device class. Therefore, some of Head's methods, such as startup() and home() methods are extended from the Device class, while other come from the DynamixelXChain class. Reading the head's current state and sending commands to its revolute joints (head pan and tilt) happens using: 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 starting_position = h . status [ 'head_pan' ][ 'pos' ] # look right by 90 degrees h . move_to ( 'head_pan' , starting_position + 1.57 ) h . get_joint ( 'head_pan' ) . wait_until_at_setpoint () # tilt up by 30 degrees h . move_by ( 'head_tilt' , - 1.57 / 3 ) h . get_joint ( 'head_tilt' ) . wait_until_at_setpoint () # look down towards the wheels h . pose ( 'wheels' ) import time ; time . sleep ( 3 ) # look ahead h . pose ( 'ahead' ) time . sleep ( 3 ) Head's attribute status is a dictionary of dictionaries, where each subdictionary is the status of one of the head's joints. This state information is updated in the background in real time by default (disable by initializing as startup(threading=False) ). Use the pretty_print() method to print out this state info in a human interpretable format. Commanding the head's revolute joints is done through the move_to() and move_by() methods. Notice that unlike the previous joints, no push command call is required here. These joints are Dynamixel servos, which behave differently than the Hello Robot steppers. Their commands are not queued; they're executed as soon as they're received. Head's two joints, the 'head_pan' and 'head_tilt', are instances of the DynamixelHelloXL430 class, and are retreiveable using the get_joint() method. They have the wait_until_at_setpoint() method, which blocks program execution until the joint reaches the commanded goal. The pose() method makes it easy to command the head to common head poses (e.g. looking 'ahead', at the end of arm 'tool', obstacles in front of the 'wheels', or 'up'). The head supports waypoint trajectories as well: 27 28 29 30 31 32 33 34 35 36 37 # queue a trajectory consisting of three waypoints h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 0 , x_r = 0.0 ) h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 3 , x_r =- 1.0 ) h . get_joint ( 'head_tilt' ) . trajectory . add ( t_s = 6 , x_r = 0.0 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 0 , x_r = 0.1 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 3 , x_r =- 0.9 ) h . get_joint ( 'head_pan' ) . trajectory . add ( t_s = 6 , x_r = 0.1 ) # trigger trajectory execution h . follow_trajectory () import time ; time . sleep ( 6 ) The head pan/tilt DynamixelHelloXL430 instances have an attribute trajectory , which is an instance of the RevoluteTrajectory class. The call to follow_trajectory() begins software tracking of the spline. Finally, setting soft motion limits for the head's pan/tilt range happens using: 38 39 40 41 42 43 44 45 46 # clip the head_pan's range h . get_joint ( 'head_pan' ) . set_soft_motion_limit_min ( - 1.0 ) h . get_joint ( 'head_pan' ) . set_soft_motion_limit_max ( 1.0 ) # clip the head_tilt's range h . get_joint ( 'head_tilt' ) . set_soft_motion_limit_min ( - 1.0 ) h . get_joint ( 'head_tilt' ) . set_soft_motion_limit_max ( 0.1 ) h . stop () The set_soft_motion_limit_min/max() methods perform clipping of the joint's range at the software level (cannot persist across reboots). All of Head's subroutines are documented below.","title":"Using the Head class"},{"location":"stretch_body_api/#stretch_body.head.Head","text":"API to the Stretch RE1 Head","title":"Head"},{"location":"stretch_body_api/#stretch_body.head.Head.__init__","text":"","title":"__init__()"},{"location":"stretch_body_api/#stretch_body.head.Head.startup","text":"Starts machinery required to interface with this device","title":"startup()"},{"location":"stretch_body_api/#stretch_body.head.Head.startup--parameters","text":"threaded : bool whether a thread manages hardware polling/pushing in the background","title":"Parameters"},{"location":"stretch_body_api/#stretch_body.head.Head.startup--returns","text":"bool whether the startup procedure succeeded","title":"Returns"},{"location":"stretch_body_api/#stretch_body.head.Head.get_joint","text":"Retrieves joint by name.","title":"get_joint()"},{"location":"stretch_body_api/#stretch_body.head.Head.get_joint--parameters","text":"joint_name : str valid joints defined in joints","title":"Parameters"},{"location":"stretch_body_api/#stretch_body.head.Head.get_joint--returns","text":"DynamixelHelloXL430 or None Motor object on valid joint name, else None","title":"Returns"},{"location":"stretch_body_api/#stretch_body.head.Head.move_to","text":"joint: Name of the joint to move ('head_pan' or 'head_tilt') x_r: commanded absolute position (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2)","title":"move_to()"},{"location":"stretch_body_api/#stretch_body.head.Head.move_by","text":"joint: Name of the joint to move ('head_pan' or 'head_tilt') x_r: commanded incremental motion (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2)","title":"move_by()"},{"location":"stretch_body_api/#stretch_body.head.Head.home","text":"","title":"home()"},{"location":"stretch_body_api/#stretch_body.head.Head.pose","text":"p: Dictionary key to named pose (eg 'ahead') v_r: list, velocities for trapezoidal motion profile (rad/s). a_r: list, accelerations for trapezoidal motion profile (rad/s^2)","title":"pose()"},{"location":"stretch_body_api/#using-the-endofarm-class","text":"The interface to Stretch's end of arm is the EndOfArm class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.end_of_arm e = stretch_body . end_of_arm . EndOfArm () if not e . startup ( threaded = True ): exit () # failed to start end of arm! # interact with the end of arm here e . stop () EndOfArm's subroutines are documented below.","title":"Using the EndOfArm class"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm","text":"The EndOfArm class allows for an extensible serial chain of Dynamixel X series devices It allows the specific type of device to be declared at runtime via the Yaml parameters In this way, a user can add their own custom Dynamixel based tools to the robot end-of-arm by simply deriving it from DynamixelHelloXL430 and declaring the class name / Python module name in the User YAML file","title":"EndOfArm"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.__init__","text":"","title":"__init__()"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.startup","text":"Starts machinery required to interface with this device","title":"startup()"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.startup--parameters","text":"threaded : bool whether a thread manages hardware polling/pushing in the background","title":"Parameters"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.startup--returns","text":"bool whether the startup procedure succeeded","title":"Returns"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.get_joint","text":"Retrieves joint by name.","title":"get_joint()"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.get_joint--parameters","text":"joint_name : str valid joints defined as defined in params['devices']","title":"Parameters"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.get_joint--returns","text":"DynamixelHelloXL430 or None Motor object on valid joint name, else None","title":"Returns"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.move_to","text":"joint: name of joint (string) x_r: commanded absolute position (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2)","title":"move_to()"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.move_by","text":"joint: name of joint (string) x_r: commanded incremental motion (radians). v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2)","title":"move_by()"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.pose","text":"joint: name of joint (string) p: named pose of joint v_r: velocity for trapezoidal motion profile (rad/s). a_r: acceleration for trapezoidal motion profile (rad/s^2)","title":"pose()"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.stow","text":"","title":"stow()"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.home","text":"Home to hardstops","title":"home()"},{"location":"stretch_body_api/#stretch_body.end_of_arm.EndOfArm.is_tool_present","text":"Return true if the given tool type is present (eg. StretchGripper) Allows for conditional logic when switching end-of-arm tools","title":"is_tool_present()"},{"location":"stretch_body_api/#using-the-wacc-class","text":"The interface to Stretch's wrist board is the Wacc (wrist + accelerometer) class. This board provides an Arduino and accelerometer sensor that is accessible from the Wacc class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.wacc w = stretch_body . wacc . Wacc () if not w . startup ( threaded = True ): exit () # failed to start wacc! # interact with the wacc here w . stop () Wacc's subroutines are documented below.","title":"Using the Wacc class"},{"location":"stretch_body_api/#stretch_body.wacc.Wacc","text":"API to the Stretch RE1 Power and IMU board (Pimu)","title":"Wacc"},{"location":"stretch_body_api/#stretch_body.wacc.Wacc.__init__","text":"","title":"__init__()"},{"location":"stretch_body_api/#stretch_body.wacc.Wacc.startup","text":"First determine which protocol version the uC firmware is running. Based on that version, replaces PimuBase class inheritance with a inheritance to a child class of PimuBase that supports that protocol","title":"startup()"},{"location":"stretch_body_api/#using-the-pimu-class","text":"The interface to Stretch's power board is the Pimu (power + IMU) class. This board provides an 9 DOF IMUthat is accessible from the Pimu class. It is typically initialized as: 1 2 3 4 5 6 7 8 9 import stretch_body.pimu p = stretch_body . pimu . Pimu () if not p . startup ( threaded = True ): exit () # failed to start pimu! # interact with the pimu here p . stop () Pimu's subroutines are documented below.","title":"Using the Pimu class"},{"location":"stretch_body_api/#stretch_body.pimu.Pimu","text":"API to the Stretch RE1 Power and IMU board (Pimu)","title":"Pimu"},{"location":"stretch_body_api/#stretch_body.pimu.Pimu.__init__","text":"","title":"__init__()"},{"location":"stretch_body_api/#stretch_body.pimu.Pimu.startup","text":"First determine which protocol version the uC firmware is running. Based on that version, replaces PimuBase class inheritance with a inheritance to a child class of PimuBase that supports that protocol All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"startup()"},{"location":"stretch_body_guide/","text":"Stretch Body Guide The Stretch_Body package provides a low level Python API to the Stretch RE1 hardware. The package is available on Git and installable via Pip . It encapsulates Mobile base Arm Lift Head actuators Wrist and tool actuators Wrist accelerometer and Arduino Base power and IMU board The robot's 3rd party hardware devices are intended to be accessed through ROS and not Stretch_Body. However, it is possible to directly access this hardware through open-source Python packages: Laser range finder: rplidar Respeaker: respeaker_python_library D435i: pyrealsense2 The Stretch_Body package is intended for advanced users who prefer to not use ROS to control the robot. It assumes a moderate level of experience programming robot sensors and actuators. Robot Interface The primary developer interface to Stretch_Body is the Robot class . As an example, the Python script below prints all Robot sensor and state data to the console every 250ms. 1 2 3 4 5 6 7 8 9 10 11 import time import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () for i in range ( 10 ): robot . pretty_print () time . sleep ( 0.25 ) robot . stop () Looking at this in detail: 2 import stretch_body.robot The package stretch_body includes the Python module for Robot as well as other Devices such as Lift and Arm. 4 5 robot = stretch_body . robot . Robot () robot . startup () Here we instantiate an instance of our Robot. The call to startup() opens the serial ports to the various devices, loads the Robot YAML parameters, and launches a few helper threads. 7 8 9 for i in range ( 10 ): robot . pretty_print () time . sleep ( 0.25 ) The call to pretty_print() prints to console all of the robot's sensor and state data. 11 robot . stop () Finally, the stop() method shuts down the Robot threads and cleanly closes the open serial ports. Units The Robot API uses SI units of: meters radians seconds Newtons Amps Volts Parameters may be named with a suffix to help describe the unit type. For example: pos_m : meters pos_r: radians The Robot Status The Robot derives from the Device class . It also encapsulates a number of other Devices: robot.head robot.arm robot.lift robot.base robot.wacc robot.pimu robot.end_of_arm All devices contain a Status dictionary. The Status contains the most recent sensor and state data of that device. For example, looking at the Arm class we see: class Arm ( Device ): def __init__ ( self ): ... self . status = { 'pos' : 0.0 , 'vel' : 0.0 , 'force' : 0.0 , \\ 'motor' : self . motor . status , 'timestamp_pc' : 0 } The Status dictionaries are automatically updated by a background thread of the Robot at 25Hz. The Status data can be accessed via the Robot. For example: if robot . arm . status [ 'pos' ] > 0.25 : print ( 'Arm extension greater than 0.25m' ) If an instantaneous snapshot of the entire Robot Status is needed, the get_status() method can be used instead: status = robot . get_status () if status [ 'arm' ][ 'pos' ] > 0.25 : print ( 'Arm extension greater than 0.25m' ) The Robot Command In contrast to the Robot Status which pulls data from the Devices, the Robot Command pushes data to the Devices. Consider the following example which extends and then retracts the arm by 0.1 meters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import time import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . arm . move_by ( 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . arm . move_by ( - 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . stop () A few important things are going on: 7 robot . arm . move_by ( 0.1 ) The move_by() method queues up an RPC command to the stepper motor controller. However, the command does not yet execute. 8 robot . push_command () The push_command() causes all queued up RPC commands to be executed at once. In this example we call sleep() to allow time for the motion to complete before initiating a new motion. NOTE : The Dynamixel servos do not use the Hello Robot RPC protocol. As such, the head, wrist, and gripper will move immediately upon issuing a motion command. The stepper actuators support a synchronous mode, allowing the base, arm, and lift to synchronously track trajectories. Thus, the following code will cause the base, arm, and lift to initiate motion simultaneously: robot . arm . move_by ( 0.1 ) robot . lift . move_by ( 0.1 ) robot . base . translate_by ( 0.1 ) robot . push_command () Commanding robot motion through the Stretch_Body interface is covered in more detail in the Robot Motion section. Stowing and Homing After power up the robot requires homing in order for its joint encoders to find their zero position. The homing procedure will run the robot through a series of moves to find these zeros. It can be done programatically: if not robot . is_calibrated (): robot . home () #blocking Or it can be done manually after boot using the command line tool: $ stretch_robot_home.py Likewise, stowing is a robot procedure that will cause it to move its arm and tool safely within the footprint of the base. robot . stow () #blocking Or it can be done manually from the command line when needed: $ stretch_robot_stow.py Scripting the Robot A simplified design pattern to script the Robot is as follows 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #!/usr/bin/env python import time import stretch_body.robot from stretch_body.hello_utils import ThreadServiceExit robot = stretch_body . robot . Robot () robot . startup () x_move_base = 0 x_move_arm = 0 x_move_lift = 0 x_move_head_pan = 0 x_move_head_tilt = 0 x_move_wrist_yaw = 0 x_move_gripper = 0 def update_my_behavior ( status ): #Update the joint commands based on the status data pass try : while True : #Get a snapshot of the robot status data status = robot . get_status () #Compute new position targets based on sensor data update_my_behavior ( status ) #Queue new targets to devices robot . base . translate_by ( x_move_base ) #or robot.base.rotate_by() robot . arm . move_by ( x_move_arm ) robot . lift . move_by ( x_move_lift ) robot . head . move_by ( 'head_pan' , x_move_head_pan ) robot . head . move_by ( 'head_tilt' , x_move_head_tilt ) robot . end_of_arm . move_by ( 'wrist_yaw' , x_move_wrist_yaw ) robot . end_of_arm . move_by ( 'stretch_gripper' , x_move_gripper ) #Synchronized send of new position targets robot . push_command () #Wait for next control cycle time . sleep ( 0.1 ) except ( KeyboardInterrupt , SystemExit , ThreadServiceExit ) pass robot . stop () Command Line Tools The Stretch_Body package comes with a suite of command line tools that allow direct interaction with hardware subsystems. These can be useful when developing and debugging applications. They also serve as code examples when developing applications for Stretch_Body. These tools can be found by tab completion of 'stretch_' from a terminal. $ stretch_ stretch_about.py stretch_gripper_home.py stretch_lift_jog.py stretch_robot_dynamixel_reboot.py stretch_robot_stow.py stretch_wacc_scope.py stretch_arm_home.py stretch_gripper_jog.py stretch_pimu_jog.py stretch_robot_home.py stretch_robot_system_check.py stretch_wrist_yaw_home.py stretch_arm_jog.py stretch_hardware_echo.py stretch_pimu_scope.py stretch_robot_jog.py stretch_rp_lidar_jog.py stretch_wrist_yaw_jog.py stretch_audio_test.py stretch_head_jog.py stretch_respeaker_test.py stretch_robot_keyboard_teleop.py stretch_urdf_show.py stretch_xbox_controller_teleop.py stretch_base_jog.py stretch_lift_home.py stretch_robot_battery_check.py stretch_robot_monitor.py stretch_wacc_jog.py All tools accept '--help' as a command line argument to learn its function. For example: $ stretch_wacc_scope.py --help usage: stretch_wacc_scope.py [-h] [--ax] [--ay] [--az] [--a0] [--d0] [--d1] [--tap] Visualize Wacc (Wrist+Accel) board data with an oscilloscope optional arguments: -h, --help show this help message and exit --ax Scope accelerometer AX --ay Scope accelerometer AY --az Scope accelerometer AZ --a0 Scope analog-in-0 --d0 Scope digital-in-0 --d1 Scope digital-in-1 --tap Scope single tap Commonly Used Tools These are the tools a typical user will want to become familiar with. Tool Utility stretch_robot_home.py Commonly run after booting up the robot in-order to calibrate the joints stretch_robot_system_check.py Scans for all hardware devices and ensure they are present on the bus and reporting valid values. Useful to verify that the robot is in good working order prior to commanding motion. It will report all success in green, failures in red. stretch_robot_stow.py Useful to return the robot arm and tool to a safe position within the base footprint. It can also be useful if a program fails to exit cleanly and the robot joints are not backdriveable. It will restore them to their 'Safety' state. stretch_robot_battery_check.py Quick way to check the battery voltage / current consumption stretch_xbox_controller_teleop.py Useful to quickly test if a robot can achieve a task by manually teleoperating the robot stretch_robot_dynamixel_reboot.py This will reset all Dynamixels in the robot, which may be needed if a servo overheats during high use and enters an error state. The other tools are fairly self explanatory. They allow the user to quickly read a sensor value or control an individual hardware subsystem. Robot Motion Controlling the motion of the robot's actuators is typically done through the ROS interfaces. However it is also possible to control the robot directly through the stretch_body interfaces. Actuators are commanded by either a move_by or move_to command (the former being incremental, the latter being absolute). For example, a relative move using the default motion parameters of the arm looks like: 1 2 3 4 5 6 7 8 9 import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . arm . move_by ( 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . stop () Motion Profiles All joints support trapezoidal based motion generation. Other types of controllers are available (PID, velocity, etc) but they are not covered here . The trapezoidal motion controllers require three values: x: target position of joint v: maximum velocity of motion a: acceleration of motion We provide 'default' settings for the velocity and acceleration settings, as well as 'fast', and 'slow' settings. These values have been tuned to be appropriate for safe motion of the robot. These values can be seen in the 'stretch_re1_factory_params.yaml'. For example: arm : motion : fast : { accel_m : 0.2 , vel_m : 0.2 } default : { accel_m : 0.14 , vel_m : 0.14 } max : { accel_m : 1.0 , vel_m : 1.0 } slow : { accel_m : 0.07 , vel_m : 0.06 } To move the arm quickly instead: vel_fast_m = robot . arm . params [ 'motion' ][ 'fast' ][ 'vel_m' ] accel_fast_m = robot . arm . params [ 'motion' ][ 'fast' ][ 'accel_m' ] robot . arm . move_by ( x_m = 0.1 , v_m = vel_fast_m , a_m = accel_fast_m ) robot . push_command () The motion will fall back to the 'default' settings found in the YAML if no parameters are provided. Range of Motion All joints obey motion limits which are specified in the factory YAML. These limits have been set at the factory to prevent damage to the hardware. It is not recommended to set them to be greater than the factory specified values. However, they can be further limited if desired. For example. to prevent the lift from descending within 100mm of the base, one can override the factory setting in stretch_re1_user_params.yaml lift : range_m : [ 0.1 , 1.095 ] Control Modes Each joint has a default safety mode and default control mode. These are: Joint Default Safety Mode Default Control Mode left_wheel Freewheel Trapezoidal position control right_wheel Freewheel Trapezoidal position control lift Gravity compensated 'float' Trapezoidal position control arm Freewheel Trapezoidal position control head_pan Torque disabled Trapezoidal position control head_tilt Torque disabled Trapezoidal position control wrist_yaw Torque disabled Trapezoidal position control stretch_gripper Torque disabled Trapezoidal position control The actuator remains in Safety Mode when no program is running. When the <device>.startup() function is called it transitions to its Control Mode. It is placed back in Safety Mode when <device>.stop() is called. In addition, the Base supports a velocity control mode. The Base controllers will automatically switch between velocity and position based control. For example: robot . base . translate_by ( x_m = 0.5 ) robot . push_command () time . sleep ( 4.0 ) #wait robot . base . set_rotational_velocity ( v_r = 0.1 ) #switch to velocity controller robot . push_command () time . sleep ( 4.0 ) #wait robot . base . set_rotational_velocity ( v_r = 0.0 ) #stop motion robot . push_command () As shown, care should be taken to reduce commanded velocities to zero to avoid runaway. Runstop Runstop activation will cause the Base, Arm, and Lift to switch to Safety Mode and for motion commands will be ignored. The motion commands will resume smoothly when the runstop is deactivated. This is usually done via the runstop button. However, it can also be done via the Pimu interface: if robot . pimu . status [ 'runstop_event' ]: robot . pimu . runstop_event_reset () robot . push_command () Guarded Motion The Arm, Lift, and Base support a guarded motion function. It will automatically transition the actuator from Control mode to Safety mode when the exerted motor torque exceeds a threshold. This functionality is most useful for the Lift and the Arm. It allows these joints to safely stop upon contact. It can be used to: Safely stop when contacting an actuator hardstop Safely stop when making unexpected contact with the environment or a person Make a guarded motion where the robot reaches to a surface and then stops Each of these tasks have different force characteristics and may require different threshold settings. The factory defaults are set so as to allow freespace motion without a payload (without triggering a false positive stop). These thresholds are set in the factory YAML. For example: arm : contact_thresh_N : [ -50 , 50 ] contact_thresh_max_N : [ -80 , 80 ] A user can dynamically set the contact thresholds depending on the task requirements. For example, to make the arm extension motion more sensitive: robot . arm . move_by ( x_m = 0.1 , contact_thresh_pos_N = 30.0 ) If too sensitive, the joint may trigger false positives (e.g., stop without contact), and different thresholds may be needed in different portions of the workspace. When a guarded motion event has occurred it is reported in the Status: if robot . arm . motor . status [ 'in_guarded_event' ]: print ( 'Arm has made contact' ) The guarded event can be reset and motion resumed by simply sending a new motion command to the joint (that is not identical to the previous command). Here is a simple example of moving to contact, then moving back: robot . arm . move_to ( 0.5 ) #Reach all the way out robot . push_command () while robot . arm . status [ 'pos' ] < 0.5 : if robot . arm . motor . status [ 'in_guarded_event' ]: print ( 'Contact made at' , robot . arm . status [ 'pos' ]) break time . sleep ( 0.1 ) print ( 'Retracting...' ) robot . arm . move_to ( 0.0 ) robot . push_command () Note: The units of Newtons are approximations only and may not be accurate to real world contact forces. Synchronized Motion The Arm, Lift, and Base actuators have a hardware synchronization mechanism. This allows for controller commands to be time synchronized across joints. By default these are turned out in the factory YAML: hello-motor-arm : gains : { enable_sync_mode : 1 , ... } Motion Status It can be useful to poll the status of a joint during motion in order to modify the robot behavior, etc. The useful status values include: robot . arm . status [ 'pos' ] #Joint position robot . arm . status [ 'vel' ] #Joint velocity robot . arm . status [ 'force' ] #Joint force (derived from motor current) robot . arm . motor . status [ 'near_pos_setpoint' ] #Is sensed position near commanded position robot . arm . motor . status [ 'near_vel_setpoint' ] #Is sensed velocity near commanded velocity robot . arm . motor . status [ 'is_moving' ] #Is the joint in motion robot . arm . motor . status [ 'in_guarded_event' ] #Has a guarded event occured robot . arm . motor . status [ 'in_safety_event' ] #Has a safety event occured Update Rates The following update rates apply to Stretch: Item Rate Notes Status data for Arm, Lift, Base, Wacc, and Pimu 25Hz Polled automatically by Robot thread Status data for End of Arm and Head servos 15Hz Polled automatically by Robot thread Command data for Arm, Lift, Base, Wacc, Pimu N/A Commands are queued and executed upon calling robot.push_command( ) Command data for End of Arm and Head servos N/A Commands execute immediately Motion commands are non-blocking and it is the responsibility of the user code to poll the Robot Status to determine when and if a motion target has been achieved. The Stretch_Body interface is not designed to support high bandwidth control applications. The natural dynamics of the robot actuators do not support high bandwidth contorl, and the USB based interface limits high rate communication. In practice, a Python based control loop that calls push_command( ) at 1Hz to 10Hz is sufficiently matched to the robot natural dynamics. Sensors Base IMU Coming soon. Wrist Accelerometer Coming soon. Cliff Sensors Stretch has four IR cliff sensors pointed towards the floor. These report the distance to the floor, allowing for detection of thresholds, stair edges, etc. Relevant parameters in the factory YAML are pimu : config : cliff_LPF : 10.0 cliff_thresh : -50 cliff_zero : - 523.7940936279297 - 508.10246490478517 - 496.55742706298827 - 525.149652709961 stop_at_cliff : 0 The stop_at_cliff field causes the robot to execute a Runstop when the cliff sensor readings are out of bounds. Note: As configured at the factory, stop_at_cliff is set to zero and Stretch does not stop its motion based on the cliff sensor readings. Hello Robot makes no guarantees as to the reliability of Stretch's ability to avoid driving over ledges and stairs when this flag is enabled. The sensors are calibrated such that a zero value indicates the sensor is at the correct height from the floor surface. A negative value indicates a drop off such as a stair ledge while a positive value indicates an obstacle like a threshold or high pile carpet. The calibrated range values from the sensors can be read from the robot.pimu.status message. Relevant fields are: In [ 1 ]: robot . pimu . pretty_print () ------ Pimu ----- ... At Cliff [ False , False , False , False ] Cliff Range [ 2.043212890625 , 3.710906982421875 , 1.6026611328125 , 1.95098876953125 ] Cliff Event False ... A Cliff Event flag is set when any of the four sensor readings exceed cliff_thresh and stop_at_cliff is enabled. In the event of a Cliff Event, it must be reset by robot.pimu.cliff_event_reset() in order to reset the generated Runstop. The cliff detection logic can be found in the Pimu firmware . Robot Parameters All robot data is stored in the stretch_user directory. The location of this directory can be found by: $ echo $HELLO_FLEET_PATH /home/hello-robot/stretch_user The robot data stored here is identified by the robot ID (eg, stretch-re1-1002) $ cd $HELLO_FLEET_PATH / $HELLO_FLEET_ID $ ls calibration_base_imu calibration_guarded_contact calibration_steppers calibration_D435i calibration_ros export_urdf udev stretch_re1_factory_params.yaml stretch_re1_user_params.yaml stretch_re1_tool_params.yaml A factory image of this data (as shipped), is stored read-only under /etc/hello-robot . This is only for backup and to support cloning the user environment for new users. Calibration Data The raw calibration data that was used in production for the robot is also stored for reference within the stretch_user directory. It isn't generally required for development. URDF Data A calibrated URDF, and associated mesh files, are provided in the 'export_urdf' directory. This is provided for users who don't wish to use ROS yet still want an accurate model of the robot. The stretch_urdf_view.py tool demonstrates how to visualize the URDF from Python. YAML Data Stretch_Body relies upon the following three primary YAML files: File Purpose stretch_re1_factory_params.yaml Factory settings for controller gains, calibrations, and system configuration. Read only stretch_re1_user_params.yaml User parameters that override the factory parameters stretch_re1_tool_params.yaml Settings and configuration data for optional 3rd party end-of-arm tools. Factory Parameters This stretch_re1_factory_params.yaml file contains the robot's 'factory' settings. This includes things such as PID parameters for motor controllers, calibration constants, and default joint velocities and accelerations. The user should not edit this file. Hello Robot retains an 'as shipped' version of this file should it ever get corrupted. It can be instructive to review this file when getting to know the Stretch_Body code base. User Parameters The factory settings should suffice for most use cases. However, the user is allowed to override the factory settings. This is done by using same YAML structure and name as is used in the stretch_re1_user_params.yaml file as in the factory file. For example, heres the stretch_re1_user_params.yaml file is overriding the factory default contact thresholds and motion speeds. factory_params : stretch_re1_factory_params.yaml tool_params : stretch_re1_tool_params.yaml lift : contact_thresh_N : [ -60 , 60 ] motion : default : { accel_m : 0.15 , vel_m : 0.095 } arm : contact_thresh_N : [ -80 , 80 ] motion : default : { accel_m : 0.14 , vel_m : 0.14 } base : motion : default : { accel_m : 0.1 , vel_m : 0.15 } End of Arm Tool Parameters The stretch_re1_tool_params.yaml file stores configuration parameters specific to the user's custom end-of-arm-tools. It is read by the Robot class and the parameter data is made accessible to the user's end-of-arm-tool class. More information on integrating custom hardware on the End of Arm Dynamixel bus can be found at the Extending Wrist DOF Tutorial Safe Operation Features Stretch includes a number of built-in functions that help it maintain safe operating conditions. These functions can be disabled and enabled via the robot YAML parameters. Logging Upon instantiation, the Robot class opens a new log file for warning and informational messages to be written to. These timestamped logs are found under $HELLO_FLEET_DIRECTORY/log. The logging messages can be echoed to the console by setting: robot : log_to_console : 1 Runstop Functions YAML Function stop_at_low_voltage Trigger runstop / beep when voltage too low stop_at_high_current Trigger runstop when bus current too high stop_at_cliff Trigger runstop when a cliff sensor is outside of range stop_at_runstop Allow runstop to disable motors stop_at_tilt Trigger runstop when robot tilts too far Robot Monitor The Robot Monitor is a thread that monitors the Robot Status data for significant events. For example, it can monitor the error flags from the Dynamixel servos and notify when a thermal overload occurs. The Robot Monitor logs warnings to a log file by default. YAML Function monitor_base_bump_event Report when the accelerometer detects a bump event monitor_base_cliff_event Report when a cliff sensor event occurs monitor_current Report when the battery current exceeds desired range monitor_dynamixel_flags Report when a Dynamixel servo enters an error state monitor_guarded_contact Report when a guarded contact event occurs monitor_over_tilt_alert Report when an over-tilt event occurs monitor_runstop Report when the runstop is activated / deactivated monitor_voltage Report when the battery voltage is out of range monitor_wrist_single_tap Report when the wrist accelerometer reports a single tap event The YAML below illustrates the types of events that are can be configured. robot : log_to_console : 0 use_monitor : 1 use_sentry : 1 robot_monitor : monitor_base_bump_event : 1 monitor_base_cliff_event : 1 monitor_current : 1 monitor_dynamixel_flags : 1 monitor_guarded_contact : 1 monitor_over_tilt_alert : 1 monitor_runstop : 1 monitor_voltage : 1 monitor_wrist_single_tap : 1 robot_sentry : base_fan_control : 1 base_max_velocity : 1 stretch_gripper_overload : 1 wrist_yaw_overload : 1 Robot Sentry The Robot Sentry is a thread that can override and also generate commands to the robot hardware. It's purpose is to keep the robot operating within a safe regime. For example, the Robot Sentry monitors the position of the Lift and Arm and limits the maximum base velocity and acceleration (in order to reduce the chance of toppling). The Robot Sentry reports events to the log file as well. YAML Function base_fan_control Turn the fan on when CPU temp exceeds range base_max_velocity Limit the base velocity when robot CG is high stretch_gripper_overload Reset commanded position to prevent thermal overload during grasp wrist_yaw_overload Reset commanded position to prevent thermal overload during pushing All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch Body Guide"},{"location":"stretch_body_guide/#stretch-body-guide","text":"The Stretch_Body package provides a low level Python API to the Stretch RE1 hardware. The package is available on Git and installable via Pip . It encapsulates Mobile base Arm Lift Head actuators Wrist and tool actuators Wrist accelerometer and Arduino Base power and IMU board The robot's 3rd party hardware devices are intended to be accessed through ROS and not Stretch_Body. However, it is possible to directly access this hardware through open-source Python packages: Laser range finder: rplidar Respeaker: respeaker_python_library D435i: pyrealsense2 The Stretch_Body package is intended for advanced users who prefer to not use ROS to control the robot. It assumes a moderate level of experience programming robot sensors and actuators.","title":"Stretch Body Guide"},{"location":"stretch_body_guide/#robot-interface","text":"The primary developer interface to Stretch_Body is the Robot class . As an example, the Python script below prints all Robot sensor and state data to the console every 250ms. 1 2 3 4 5 6 7 8 9 10 11 import time import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () for i in range ( 10 ): robot . pretty_print () time . sleep ( 0.25 ) robot . stop () Looking at this in detail: 2 import stretch_body.robot The package stretch_body includes the Python module for Robot as well as other Devices such as Lift and Arm. 4 5 robot = stretch_body . robot . Robot () robot . startup () Here we instantiate an instance of our Robot. The call to startup() opens the serial ports to the various devices, loads the Robot YAML parameters, and launches a few helper threads. 7 8 9 for i in range ( 10 ): robot . pretty_print () time . sleep ( 0.25 ) The call to pretty_print() prints to console all of the robot's sensor and state data. 11 robot . stop () Finally, the stop() method shuts down the Robot threads and cleanly closes the open serial ports.","title":"Robot Interface"},{"location":"stretch_body_guide/#units","text":"The Robot API uses SI units of: meters radians seconds Newtons Amps Volts Parameters may be named with a suffix to help describe the unit type. For example: pos_m : meters pos_r: radians","title":"Units"},{"location":"stretch_body_guide/#the-robot-status","text":"The Robot derives from the Device class . It also encapsulates a number of other Devices: robot.head robot.arm robot.lift robot.base robot.wacc robot.pimu robot.end_of_arm All devices contain a Status dictionary. The Status contains the most recent sensor and state data of that device. For example, looking at the Arm class we see: class Arm ( Device ): def __init__ ( self ): ... self . status = { 'pos' : 0.0 , 'vel' : 0.0 , 'force' : 0.0 , \\ 'motor' : self . motor . status , 'timestamp_pc' : 0 } The Status dictionaries are automatically updated by a background thread of the Robot at 25Hz. The Status data can be accessed via the Robot. For example: if robot . arm . status [ 'pos' ] > 0.25 : print ( 'Arm extension greater than 0.25m' ) If an instantaneous snapshot of the entire Robot Status is needed, the get_status() method can be used instead: status = robot . get_status () if status [ 'arm' ][ 'pos' ] > 0.25 : print ( 'Arm extension greater than 0.25m' )","title":"The Robot Status"},{"location":"stretch_body_guide/#the-robot-command","text":"In contrast to the Robot Status which pulls data from the Devices, the Robot Command pushes data to the Devices. Consider the following example which extends and then retracts the arm by 0.1 meters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import time import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . arm . move_by ( 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . arm . move_by ( - 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . stop () A few important things are going on: 7 robot . arm . move_by ( 0.1 ) The move_by() method queues up an RPC command to the stepper motor controller. However, the command does not yet execute. 8 robot . push_command () The push_command() causes all queued up RPC commands to be executed at once. In this example we call sleep() to allow time for the motion to complete before initiating a new motion. NOTE : The Dynamixel servos do not use the Hello Robot RPC protocol. As such, the head, wrist, and gripper will move immediately upon issuing a motion command. The stepper actuators support a synchronous mode, allowing the base, arm, and lift to synchronously track trajectories. Thus, the following code will cause the base, arm, and lift to initiate motion simultaneously: robot . arm . move_by ( 0.1 ) robot . lift . move_by ( 0.1 ) robot . base . translate_by ( 0.1 ) robot . push_command () Commanding robot motion through the Stretch_Body interface is covered in more detail in the Robot Motion section.","title":"The Robot Command"},{"location":"stretch_body_guide/#stowing-and-homing","text":"After power up the robot requires homing in order for its joint encoders to find their zero position. The homing procedure will run the robot through a series of moves to find these zeros. It can be done programatically: if not robot . is_calibrated (): robot . home () #blocking Or it can be done manually after boot using the command line tool: $ stretch_robot_home.py Likewise, stowing is a robot procedure that will cause it to move its arm and tool safely within the footprint of the base. robot . stow () #blocking Or it can be done manually from the command line when needed: $ stretch_robot_stow.py","title":"Stowing and Homing"},{"location":"stretch_body_guide/#scripting-the-robot","text":"A simplified design pattern to script the Robot is as follows 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #!/usr/bin/env python import time import stretch_body.robot from stretch_body.hello_utils import ThreadServiceExit robot = stretch_body . robot . Robot () robot . startup () x_move_base = 0 x_move_arm = 0 x_move_lift = 0 x_move_head_pan = 0 x_move_head_tilt = 0 x_move_wrist_yaw = 0 x_move_gripper = 0 def update_my_behavior ( status ): #Update the joint commands based on the status data pass try : while True : #Get a snapshot of the robot status data status = robot . get_status () #Compute new position targets based on sensor data update_my_behavior ( status ) #Queue new targets to devices robot . base . translate_by ( x_move_base ) #or robot.base.rotate_by() robot . arm . move_by ( x_move_arm ) robot . lift . move_by ( x_move_lift ) robot . head . move_by ( 'head_pan' , x_move_head_pan ) robot . head . move_by ( 'head_tilt' , x_move_head_tilt ) robot . end_of_arm . move_by ( 'wrist_yaw' , x_move_wrist_yaw ) robot . end_of_arm . move_by ( 'stretch_gripper' , x_move_gripper ) #Synchronized send of new position targets robot . push_command () #Wait for next control cycle time . sleep ( 0.1 ) except ( KeyboardInterrupt , SystemExit , ThreadServiceExit ) pass robot . stop ()","title":"Scripting the Robot"},{"location":"stretch_body_guide/#command-line-tools","text":"The Stretch_Body package comes with a suite of command line tools that allow direct interaction with hardware subsystems. These can be useful when developing and debugging applications. They also serve as code examples when developing applications for Stretch_Body. These tools can be found by tab completion of 'stretch_' from a terminal. $ stretch_ stretch_about.py stretch_gripper_home.py stretch_lift_jog.py stretch_robot_dynamixel_reboot.py stretch_robot_stow.py stretch_wacc_scope.py stretch_arm_home.py stretch_gripper_jog.py stretch_pimu_jog.py stretch_robot_home.py stretch_robot_system_check.py stretch_wrist_yaw_home.py stretch_arm_jog.py stretch_hardware_echo.py stretch_pimu_scope.py stretch_robot_jog.py stretch_rp_lidar_jog.py stretch_wrist_yaw_jog.py stretch_audio_test.py stretch_head_jog.py stretch_respeaker_test.py stretch_robot_keyboard_teleop.py stretch_urdf_show.py stretch_xbox_controller_teleop.py stretch_base_jog.py stretch_lift_home.py stretch_robot_battery_check.py stretch_robot_monitor.py stretch_wacc_jog.py All tools accept '--help' as a command line argument to learn its function. For example: $ stretch_wacc_scope.py --help usage: stretch_wacc_scope.py [-h] [--ax] [--ay] [--az] [--a0] [--d0] [--d1] [--tap] Visualize Wacc (Wrist+Accel) board data with an oscilloscope optional arguments: -h, --help show this help message and exit --ax Scope accelerometer AX --ay Scope accelerometer AY --az Scope accelerometer AZ --a0 Scope analog-in-0 --d0 Scope digital-in-0 --d1 Scope digital-in-1 --tap Scope single tap","title":"Command Line Tools"},{"location":"stretch_body_guide/#commonly-used-tools","text":"These are the tools a typical user will want to become familiar with. Tool Utility stretch_robot_home.py Commonly run after booting up the robot in-order to calibrate the joints stretch_robot_system_check.py Scans for all hardware devices and ensure they are present on the bus and reporting valid values. Useful to verify that the robot is in good working order prior to commanding motion. It will report all success in green, failures in red. stretch_robot_stow.py Useful to return the robot arm and tool to a safe position within the base footprint. It can also be useful if a program fails to exit cleanly and the robot joints are not backdriveable. It will restore them to their 'Safety' state. stretch_robot_battery_check.py Quick way to check the battery voltage / current consumption stretch_xbox_controller_teleop.py Useful to quickly test if a robot can achieve a task by manually teleoperating the robot stretch_robot_dynamixel_reboot.py This will reset all Dynamixels in the robot, which may be needed if a servo overheats during high use and enters an error state. The other tools are fairly self explanatory. They allow the user to quickly read a sensor value or control an individual hardware subsystem.","title":"Commonly Used Tools"},{"location":"stretch_body_guide/#robot-motion","text":"Controlling the motion of the robot's actuators is typically done through the ROS interfaces. However it is also possible to control the robot directly through the stretch_body interfaces. Actuators are commanded by either a move_by or move_to command (the former being incremental, the latter being absolute). For example, a relative move using the default motion parameters of the arm looks like: 1 2 3 4 5 6 7 8 9 import stretch_body.robot robot = stretch_body . robot . Robot () robot . startup () robot . arm . move_by ( 0.1 ) robot . push_command () time . sleep ( 2.0 ) robot . stop ()","title":"Robot Motion"},{"location":"stretch_body_guide/#motion-profiles","text":"All joints support trapezoidal based motion generation. Other types of controllers are available (PID, velocity, etc) but they are not covered here . The trapezoidal motion controllers require three values: x: target position of joint v: maximum velocity of motion a: acceleration of motion We provide 'default' settings for the velocity and acceleration settings, as well as 'fast', and 'slow' settings. These values have been tuned to be appropriate for safe motion of the robot. These values can be seen in the 'stretch_re1_factory_params.yaml'. For example: arm : motion : fast : { accel_m : 0.2 , vel_m : 0.2 } default : { accel_m : 0.14 , vel_m : 0.14 } max : { accel_m : 1.0 , vel_m : 1.0 } slow : { accel_m : 0.07 , vel_m : 0.06 } To move the arm quickly instead: vel_fast_m = robot . arm . params [ 'motion' ][ 'fast' ][ 'vel_m' ] accel_fast_m = robot . arm . params [ 'motion' ][ 'fast' ][ 'accel_m' ] robot . arm . move_by ( x_m = 0.1 , v_m = vel_fast_m , a_m = accel_fast_m ) robot . push_command () The motion will fall back to the 'default' settings found in the YAML if no parameters are provided.","title":"Motion Profiles"},{"location":"stretch_body_guide/#range-of-motion","text":"All joints obey motion limits which are specified in the factory YAML. These limits have been set at the factory to prevent damage to the hardware. It is not recommended to set them to be greater than the factory specified values. However, they can be further limited if desired. For example. to prevent the lift from descending within 100mm of the base, one can override the factory setting in stretch_re1_user_params.yaml lift : range_m : [ 0.1 , 1.095 ]","title":"Range of Motion"},{"location":"stretch_body_guide/#control-modes","text":"Each joint has a default safety mode and default control mode. These are: Joint Default Safety Mode Default Control Mode left_wheel Freewheel Trapezoidal position control right_wheel Freewheel Trapezoidal position control lift Gravity compensated 'float' Trapezoidal position control arm Freewheel Trapezoidal position control head_pan Torque disabled Trapezoidal position control head_tilt Torque disabled Trapezoidal position control wrist_yaw Torque disabled Trapezoidal position control stretch_gripper Torque disabled Trapezoidal position control The actuator remains in Safety Mode when no program is running. When the <device>.startup() function is called it transitions to its Control Mode. It is placed back in Safety Mode when <device>.stop() is called. In addition, the Base supports a velocity control mode. The Base controllers will automatically switch between velocity and position based control. For example: robot . base . translate_by ( x_m = 0.5 ) robot . push_command () time . sleep ( 4.0 ) #wait robot . base . set_rotational_velocity ( v_r = 0.1 ) #switch to velocity controller robot . push_command () time . sleep ( 4.0 ) #wait robot . base . set_rotational_velocity ( v_r = 0.0 ) #stop motion robot . push_command () As shown, care should be taken to reduce commanded velocities to zero to avoid runaway.","title":"Control Modes"},{"location":"stretch_body_guide/#runstop","text":"Runstop activation will cause the Base, Arm, and Lift to switch to Safety Mode and for motion commands will be ignored. The motion commands will resume smoothly when the runstop is deactivated. This is usually done via the runstop button. However, it can also be done via the Pimu interface: if robot . pimu . status [ 'runstop_event' ]: robot . pimu . runstop_event_reset () robot . push_command ()","title":"Runstop"},{"location":"stretch_body_guide/#guarded-motion","text":"The Arm, Lift, and Base support a guarded motion function. It will automatically transition the actuator from Control mode to Safety mode when the exerted motor torque exceeds a threshold. This functionality is most useful for the Lift and the Arm. It allows these joints to safely stop upon contact. It can be used to: Safely stop when contacting an actuator hardstop Safely stop when making unexpected contact with the environment or a person Make a guarded motion where the robot reaches to a surface and then stops Each of these tasks have different force characteristics and may require different threshold settings. The factory defaults are set so as to allow freespace motion without a payload (without triggering a false positive stop). These thresholds are set in the factory YAML. For example: arm : contact_thresh_N : [ -50 , 50 ] contact_thresh_max_N : [ -80 , 80 ] A user can dynamically set the contact thresholds depending on the task requirements. For example, to make the arm extension motion more sensitive: robot . arm . move_by ( x_m = 0.1 , contact_thresh_pos_N = 30.0 ) If too sensitive, the joint may trigger false positives (e.g., stop without contact), and different thresholds may be needed in different portions of the workspace. When a guarded motion event has occurred it is reported in the Status: if robot . arm . motor . status [ 'in_guarded_event' ]: print ( 'Arm has made contact' ) The guarded event can be reset and motion resumed by simply sending a new motion command to the joint (that is not identical to the previous command). Here is a simple example of moving to contact, then moving back: robot . arm . move_to ( 0.5 ) #Reach all the way out robot . push_command () while robot . arm . status [ 'pos' ] < 0.5 : if robot . arm . motor . status [ 'in_guarded_event' ]: print ( 'Contact made at' , robot . arm . status [ 'pos' ]) break time . sleep ( 0.1 ) print ( 'Retracting...' ) robot . arm . move_to ( 0.0 ) robot . push_command () Note: The units of Newtons are approximations only and may not be accurate to real world contact forces.","title":"Guarded Motion"},{"location":"stretch_body_guide/#synchronized-motion","text":"The Arm, Lift, and Base actuators have a hardware synchronization mechanism. This allows for controller commands to be time synchronized across joints. By default these are turned out in the factory YAML: hello-motor-arm : gains : { enable_sync_mode : 1 , ... }","title":"Synchronized Motion"},{"location":"stretch_body_guide/#motion-status","text":"It can be useful to poll the status of a joint during motion in order to modify the robot behavior, etc. The useful status values include: robot . arm . status [ 'pos' ] #Joint position robot . arm . status [ 'vel' ] #Joint velocity robot . arm . status [ 'force' ] #Joint force (derived from motor current) robot . arm . motor . status [ 'near_pos_setpoint' ] #Is sensed position near commanded position robot . arm . motor . status [ 'near_vel_setpoint' ] #Is sensed velocity near commanded velocity robot . arm . motor . status [ 'is_moving' ] #Is the joint in motion robot . arm . motor . status [ 'in_guarded_event' ] #Has a guarded event occured robot . arm . motor . status [ 'in_safety_event' ] #Has a safety event occured","title":"Motion Status"},{"location":"stretch_body_guide/#update-rates","text":"The following update rates apply to Stretch: Item Rate Notes Status data for Arm, Lift, Base, Wacc, and Pimu 25Hz Polled automatically by Robot thread Status data for End of Arm and Head servos 15Hz Polled automatically by Robot thread Command data for Arm, Lift, Base, Wacc, Pimu N/A Commands are queued and executed upon calling robot.push_command( ) Command data for End of Arm and Head servos N/A Commands execute immediately Motion commands are non-blocking and it is the responsibility of the user code to poll the Robot Status to determine when and if a motion target has been achieved. The Stretch_Body interface is not designed to support high bandwidth control applications. The natural dynamics of the robot actuators do not support high bandwidth contorl, and the USB based interface limits high rate communication. In practice, a Python based control loop that calls push_command( ) at 1Hz to 10Hz is sufficiently matched to the robot natural dynamics.","title":"Update Rates"},{"location":"stretch_body_guide/#sensors","text":"","title":"Sensors"},{"location":"stretch_body_guide/#base-imu","text":"Coming soon.","title":"Base IMU"},{"location":"stretch_body_guide/#wrist-accelerometer","text":"Coming soon.","title":"Wrist Accelerometer"},{"location":"stretch_body_guide/#cliff-sensors","text":"Stretch has four IR cliff sensors pointed towards the floor. These report the distance to the floor, allowing for detection of thresholds, stair edges, etc. Relevant parameters in the factory YAML are pimu : config : cliff_LPF : 10.0 cliff_thresh : -50 cliff_zero : - 523.7940936279297 - 508.10246490478517 - 496.55742706298827 - 525.149652709961 stop_at_cliff : 0 The stop_at_cliff field causes the robot to execute a Runstop when the cliff sensor readings are out of bounds. Note: As configured at the factory, stop_at_cliff is set to zero and Stretch does not stop its motion based on the cliff sensor readings. Hello Robot makes no guarantees as to the reliability of Stretch's ability to avoid driving over ledges and stairs when this flag is enabled. The sensors are calibrated such that a zero value indicates the sensor is at the correct height from the floor surface. A negative value indicates a drop off such as a stair ledge while a positive value indicates an obstacle like a threshold or high pile carpet. The calibrated range values from the sensors can be read from the robot.pimu.status message. Relevant fields are: In [ 1 ]: robot . pimu . pretty_print () ------ Pimu ----- ... At Cliff [ False , False , False , False ] Cliff Range [ 2.043212890625 , 3.710906982421875 , 1.6026611328125 , 1.95098876953125 ] Cliff Event False ... A Cliff Event flag is set when any of the four sensor readings exceed cliff_thresh and stop_at_cliff is enabled. In the event of a Cliff Event, it must be reset by robot.pimu.cliff_event_reset() in order to reset the generated Runstop. The cliff detection logic can be found in the Pimu firmware .","title":"Cliff Sensors"},{"location":"stretch_body_guide/#robot-parameters","text":"All robot data is stored in the stretch_user directory. The location of this directory can be found by: $ echo $HELLO_FLEET_PATH /home/hello-robot/stretch_user The robot data stored here is identified by the robot ID (eg, stretch-re1-1002) $ cd $HELLO_FLEET_PATH / $HELLO_FLEET_ID $ ls calibration_base_imu calibration_guarded_contact calibration_steppers calibration_D435i calibration_ros export_urdf udev stretch_re1_factory_params.yaml stretch_re1_user_params.yaml stretch_re1_tool_params.yaml A factory image of this data (as shipped), is stored read-only under /etc/hello-robot . This is only for backup and to support cloning the user environment for new users.","title":"Robot Parameters"},{"location":"stretch_body_guide/#calibration-data","text":"The raw calibration data that was used in production for the robot is also stored for reference within the stretch_user directory. It isn't generally required for development.","title":"Calibration Data"},{"location":"stretch_body_guide/#urdf-data","text":"A calibrated URDF, and associated mesh files, are provided in the 'export_urdf' directory. This is provided for users who don't wish to use ROS yet still want an accurate model of the robot. The stretch_urdf_view.py tool demonstrates how to visualize the URDF from Python.","title":"URDF Data"},{"location":"stretch_body_guide/#yaml-data","text":"Stretch_Body relies upon the following three primary YAML files: File Purpose stretch_re1_factory_params.yaml Factory settings for controller gains, calibrations, and system configuration. Read only stretch_re1_user_params.yaml User parameters that override the factory parameters stretch_re1_tool_params.yaml Settings and configuration data for optional 3rd party end-of-arm tools.","title":"YAML Data"},{"location":"stretch_body_guide/#factory-parameters","text":"This stretch_re1_factory_params.yaml file contains the robot's 'factory' settings. This includes things such as PID parameters for motor controllers, calibration constants, and default joint velocities and accelerations. The user should not edit this file. Hello Robot retains an 'as shipped' version of this file should it ever get corrupted. It can be instructive to review this file when getting to know the Stretch_Body code base.","title":"Factory Parameters"},{"location":"stretch_body_guide/#user-parameters","text":"The factory settings should suffice for most use cases. However, the user is allowed to override the factory settings. This is done by using same YAML structure and name as is used in the stretch_re1_user_params.yaml file as in the factory file. For example, heres the stretch_re1_user_params.yaml file is overriding the factory default contact thresholds and motion speeds. factory_params : stretch_re1_factory_params.yaml tool_params : stretch_re1_tool_params.yaml lift : contact_thresh_N : [ -60 , 60 ] motion : default : { accel_m : 0.15 , vel_m : 0.095 } arm : contact_thresh_N : [ -80 , 80 ] motion : default : { accel_m : 0.14 , vel_m : 0.14 } base : motion : default : { accel_m : 0.1 , vel_m : 0.15 }","title":"User Parameters"},{"location":"stretch_body_guide/#end-of-arm-tool-parameters","text":"The stretch_re1_tool_params.yaml file stores configuration parameters specific to the user's custom end-of-arm-tools. It is read by the Robot class and the parameter data is made accessible to the user's end-of-arm-tool class. More information on integrating custom hardware on the End of Arm Dynamixel bus can be found at the Extending Wrist DOF Tutorial","title":"End of Arm Tool Parameters"},{"location":"stretch_body_guide/#safe-operation-features","text":"Stretch includes a number of built-in functions that help it maintain safe operating conditions. These functions can be disabled and enabled via the robot YAML parameters.","title":"Safe Operation Features"},{"location":"stretch_body_guide/#logging","text":"Upon instantiation, the Robot class opens a new log file for warning and informational messages to be written to. These timestamped logs are found under $HELLO_FLEET_DIRECTORY/log. The logging messages can be echoed to the console by setting: robot : log_to_console : 1","title":"Logging"},{"location":"stretch_body_guide/#runstop-functions","text":"YAML Function stop_at_low_voltage Trigger runstop / beep when voltage too low stop_at_high_current Trigger runstop when bus current too high stop_at_cliff Trigger runstop when a cliff sensor is outside of range stop_at_runstop Allow runstop to disable motors stop_at_tilt Trigger runstop when robot tilts too far","title":"Runstop Functions"},{"location":"stretch_body_guide/#robot-monitor","text":"The Robot Monitor is a thread that monitors the Robot Status data for significant events. For example, it can monitor the error flags from the Dynamixel servos and notify when a thermal overload occurs. The Robot Monitor logs warnings to a log file by default. YAML Function monitor_base_bump_event Report when the accelerometer detects a bump event monitor_base_cliff_event Report when a cliff sensor event occurs monitor_current Report when the battery current exceeds desired range monitor_dynamixel_flags Report when a Dynamixel servo enters an error state monitor_guarded_contact Report when a guarded contact event occurs monitor_over_tilt_alert Report when an over-tilt event occurs monitor_runstop Report when the runstop is activated / deactivated monitor_voltage Report when the battery voltage is out of range monitor_wrist_single_tap Report when the wrist accelerometer reports a single tap event The YAML below illustrates the types of events that are can be configured. robot : log_to_console : 0 use_monitor : 1 use_sentry : 1 robot_monitor : monitor_base_bump_event : 1 monitor_base_cliff_event : 1 monitor_current : 1 monitor_dynamixel_flags : 1 monitor_guarded_contact : 1 monitor_over_tilt_alert : 1 monitor_runstop : 1 monitor_voltage : 1 monitor_wrist_single_tap : 1 robot_sentry : base_fan_control : 1 base_max_velocity : 1 stretch_gripper_overload : 1 wrist_yaw_overload : 1","title":"Robot Monitor"},{"location":"stretch_body_guide/#robot-sentry","text":"The Robot Sentry is a thread that can override and also generate commands to the robot hardware. It's purpose is to keep the robot operating within a safe regime. For example, the Robot Sentry monitors the position of the Lift and Arm and limits the maximum base velocity and acceleration (in order to reduce the chance of toppling). The Robot Sentry reports events to the log file as well. YAML Function base_fan_control Turn the fan on when CPU temp exceeds range base_max_velocity Limit the base velocity when robot CG is high stretch_gripper_overload Reset commanded position to prevent thermal overload during grasp wrist_yaw_overload Reset commanded position to prevent thermal overload during pushing All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Robot Sentry"},{"location":"tool_change_tutorial/","text":"Stretch RE1: Tool Change Tutorial Many users will want to work with tools other than the default Stretch Gripper that ships with the robot. In this tutorial you will learn how to configure the Stretch software interfaces to support other tools. Changing Tool Interfaces in Stretch Body Stretch Body v0.1.x and later supports a plug-in based architecture for tools. A tool interface is an extension of the EndOfArm class that supports additional degrees of freedom. Standard Tools Stretch Body supports two tool interfaces by default: The ToolNone & ToolStretchGripper . We will explore swapping between these default tools. ToolStretchGripper The RE1 is configured to load the ToolStretchGripper interface by default. This tool is loaded according to the stretch_re1_user_params.yaml field: robot : tool : tool_stretch_gripper We can interact with this tool from iPython In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_body . end_of_arm_tools . ToolStretchGripper instance at 0x7f99109155a0 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'stretch_gripper' : < stretch_body . stretch_gripper . StretchGripper instance at 0x7f99109159b0 > , 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f9910915820 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ---- --------- Stowing Gripper ---- In [ 7 ]: r . stop () ToolNone The ToolNone interface can be loaded when no tool is attached to the Wrist Yaw joint. To switch to this interface, simply update the field in your stretch_re1_user_params.yaml to: robot : tool : tool_none After updating the YAML we can interact with the ToolNone via iPython In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_body . end_of_arm_tools . ToolNone instance at 0x7f245f786fa0 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f245e69e410 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ---- In [ 7 ]: r . stop () Loading Tool Interfaces from the Stretch Tool Share The Stretch Tool Share is an open Git repository for non-standard RE1 tools. It hosts the CAD, URDF, and Python files needed to integrate these tools onto your robot. To use Stretch Tool Share tools, first update your installation: $ pip2 install hello-robot-stretch-tool-share As an example, we see on the Tool Share that there is a tool, the ToolDryEraseToolHolderV1 which extends the EndOfArm class. In order to load this tool interface , modify your stretch_re1_user_params.yaml to load the tool as before. We will also need to tell it where to find the tool's parameter file : robot : tool : tool_dry_erase_holder_v1 params : - stretch_tool_share.dry_erase_holder_v1.params We can now interact with the tool in iPython: In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_tool_share . dry_erase_holder_v1 . tool . ToolDryEraseHolderV1 instance at 0x7f3b61c17f00 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f3b61c59280 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ---- Changing Tool Interfaces in Stretch ROS Next we'll show how to change the ROS interface for a tool. Here we will continue with the ToolDryEraseHolderV1 example. First, configure Stretch Body to use the tool as in the previous exercise. Next, ensure your ROS is up to date: $ cd ~/catkin_ws/src/stretch_ros/ $ git pull To access the URDF data for the ToolDryEraseHolderV1 we'll need to clone the Tool Share repository: $ cd ~/repos $ git clone https://github.com/hello-robot/stretch_tool_share Copy in the tool's URDF data into the Stretch ROS repository: $ cd ~/repos/stretch_tool_share/tool_share/dry_erase_holder_v1 $ cp stretch_description/urdf/*.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf/ $ cp stretch_description/meshes/*.STL ~/catkin_ws/src/stretch_ros/stretch_description/meshes/ Now we will update the tool Xacro for Stretch. Open the file ~/catkin_ws/src/stretch_ros/stretch_description/urdf/stretch_description.xacro in an editor. Comment out the current tool Xacro and include the Xacro for the dry erase holder. <?xml version=\"1.0\"?> <robot xmlns:xacro= \"http://www.ros.org/wiki/xacro\" name= \"stretch_description\" > <!--<xacro:include filename=\"stretch_gripper.xacro\" />--> <xacro:include filename= \"stretch_dry_erase_marker.xacro\" /> <xacro:include filename= \"stretch_main.xacro\" /> <xacro:include filename= \"stretch_aruco.xacro\" /> <xacro:include filename= \"stretch_d435i.xacro\" /> <xacro:include filename= \"stretch_laser_range_finder.xacro\" /> <xacro:include filename= \"stretch_respeaker.xacro\" /> </robot> Finally, we'll update our already calibrated URDF to use this new tool: $ cd ~/catkin_ws/src/stretch_ros/stretch_description/urdf $ cp stretch.urdf stretch.urdf.bak $ rosrun stretch_calibration update_urdf_after_xacro_change.sh Ctrl-C when the rosrun command terminates and you're ready to visualize the tool in RViz: $ roslaunch stretch_calibration simple_test_head_calibration.launch Advanced Topics Understanding How the Tool Plug-In Works For users looking to create their own custom tools it can be useful to understand how the tool plug-in architecture works. Here we will walk through the basics of the system for both Stretch Body and Stretch ROS Stretch Body The Robot class expects an instance of EndOfArm tool to be present. The EndOfArm tool is an extension of the DynamixelXChain class, which manages a chain of Dynamixel servos. A tool is defined via its parameters (either in user YAML or Python). For example, the ToolStretchGripper is defined in robot_params.py . These parameters tell the plug-in which DynamixelHelloXL430 instances to load and manage. Here we see: \"tool_stretch_gripper\" : { 'use_group_sync_read' : 1 , 'retry_on_comm_failure' : 1 , 'baud' : 115200 , 'verbose' : 0 , 'py_class_name' : 'ToolStretchGripper' , 'py_module_name' : 'stretch_body.end_of_arm_tools' , 'stow' : { 'stretch_gripper' : 0 , 'wrist_yaw' : 3.4 }, 'devices' : { 'stretch_gripper' : { 'py_class_name' : 'StretchGripper' , 'py_module_name' : 'stretch_body.stretch_gripper' }, 'wrist_yaw' : { 'py_class_name' : 'WristYaw' , 'py_module_name' : 'stretch_body.wrist_yaw' } } }, This dictionary defines a tool of class ToolStretchGripper with two DynamixelHelloXL430 devices on its bus (StretchGripper and WristYaw). We see that the ToolStretchGripper class extends the EndOfArm class and provides its own stowing behavior: class ToolStretchGripper ( EndOfArm ): def __init__ ( self , name = 'tool_stretch_gripper' ): EndOfArm . __init__ ( self , name ) def stow ( self ): # Fold in wrist and gripper print ( '--------- Stowing Wrist Yaw ----' ) self . move_to ( 'wrist_yaw' , self . params [ 'stow' ][ 'wrist_yaw' ]) print ( '--------- Stowing Gripper ----' ) self . move_to ( 'stretch_gripper' , self . params [ 'stow' ][ 'stretch_gripper' ]) For tools that are not a part of Stretch Body, such as from the Tool Share, you must include the tool parameters as well in your stretch_re1_user_params.yaml . A robot that must support many tools may have user YAML that looks like: params : - stretch_tool_share.usbcam_wrist_v1.params - stretch_tool_share.stretch_dex_wrist_beta.params - stretch_tool_share.dry_erase_holder_v1.params robot : tool : tool_dry_erase_holder_v1 #tool: tool_none #tool: tool_stretch_gripper #tool: tool_usbcam_wrist_v1 #tool: tool_stretch_dex_wrist_beta For a more complex implementation of a tool we recommend reviewing the Stretch Dex Wrist implementation on the Stretch Tool Share. Stretch ROS Stretch ROS also supports the tool plug-in architecture. Under ROS this is managed by extending the SimpleCommandGroup . More coming soon. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch RE1: Tool Change Tutorial"},{"location":"tool_change_tutorial/#stretch-re1-tool-change-tutorial","text":"Many users will want to work with tools other than the default Stretch Gripper that ships with the robot. In this tutorial you will learn how to configure the Stretch software interfaces to support other tools.","title":"Stretch RE1: Tool Change Tutorial"},{"location":"tool_change_tutorial/#changing-tool-interfaces-in-stretch-body","text":"Stretch Body v0.1.x and later supports a plug-in based architecture for tools. A tool interface is an extension of the EndOfArm class that supports additional degrees of freedom.","title":"Changing Tool Interfaces in Stretch Body"},{"location":"tool_change_tutorial/#standard-tools","text":"Stretch Body supports two tool interfaces by default: The ToolNone & ToolStretchGripper . We will explore swapping between these default tools.","title":"Standard Tools"},{"location":"tool_change_tutorial/#toolstretchgripper","text":"The RE1 is configured to load the ToolStretchGripper interface by default. This tool is loaded according to the stretch_re1_user_params.yaml field: robot : tool : tool_stretch_gripper We can interact with this tool from iPython In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_body . end_of_arm_tools . ToolStretchGripper instance at 0x7f99109155a0 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'stretch_gripper' : < stretch_body . stretch_gripper . StretchGripper instance at 0x7f99109159b0 > , 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f9910915820 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ---- --------- Stowing Gripper ---- In [ 7 ]: r . stop ()","title":"ToolStretchGripper"},{"location":"tool_change_tutorial/#toolnone","text":"The ToolNone interface can be loaded when no tool is attached to the Wrist Yaw joint. To switch to this interface, simply update the field in your stretch_re1_user_params.yaml to: robot : tool : tool_none After updating the YAML we can interact with the ToolNone via iPython In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_body . end_of_arm_tools . ToolNone instance at 0x7f245f786fa0 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f245e69e410 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ---- In [ 7 ]: r . stop ()","title":"ToolNone"},{"location":"tool_change_tutorial/#loading-tool-interfaces-from-the-stretch-tool-share","text":"The Stretch Tool Share is an open Git repository for non-standard RE1 tools. It hosts the CAD, URDF, and Python files needed to integrate these tools onto your robot. To use Stretch Tool Share tools, first update your installation: $ pip2 install hello-robot-stretch-tool-share As an example, we see on the Tool Share that there is a tool, the ToolDryEraseToolHolderV1 which extends the EndOfArm class. In order to load this tool interface , modify your stretch_re1_user_params.yaml to load the tool as before. We will also need to tell it where to find the tool's parameter file : robot : tool : tool_dry_erase_holder_v1 params : - stretch_tool_share.dry_erase_holder_v1.params We can now interact with the tool in iPython: In [ 1 ]: import stretch_body.robot as robot In [ 2 ]: r = robot . Robot () In [ 3 ]: r . startup () In [ 4 ]: r . end_of_arm Out [ 4 ]: < stretch_tool_share . dry_erase_holder_v1 . tool . ToolDryEraseHolderV1 instance at 0x7f3b61c17f00 > In [ 5 ]: r . end_of_arm . motors Out [ 5 ]: { 'wrist_yaw' : < stretch_body . wrist_yaw . WristYaw instance at 0x7f3b61c59280 > } In [ 6 ]: r . end_of_arm . stow () --------- Stowing Wrist Yaw ----","title":"Loading Tool Interfaces from the Stretch Tool Share"},{"location":"tool_change_tutorial/#changing-tool-interfaces-in-stretch-ros","text":"Next we'll show how to change the ROS interface for a tool. Here we will continue with the ToolDryEraseHolderV1 example. First, configure Stretch Body to use the tool as in the previous exercise. Next, ensure your ROS is up to date: $ cd ~/catkin_ws/src/stretch_ros/ $ git pull To access the URDF data for the ToolDryEraseHolderV1 we'll need to clone the Tool Share repository: $ cd ~/repos $ git clone https://github.com/hello-robot/stretch_tool_share Copy in the tool's URDF data into the Stretch ROS repository: $ cd ~/repos/stretch_tool_share/tool_share/dry_erase_holder_v1 $ cp stretch_description/urdf/*.xacro ~/catkin_ws/src/stretch_ros/stretch_description/urdf/ $ cp stretch_description/meshes/*.STL ~/catkin_ws/src/stretch_ros/stretch_description/meshes/ Now we will update the tool Xacro for Stretch. Open the file ~/catkin_ws/src/stretch_ros/stretch_description/urdf/stretch_description.xacro in an editor. Comment out the current tool Xacro and include the Xacro for the dry erase holder. <?xml version=\"1.0\"?> <robot xmlns:xacro= \"http://www.ros.org/wiki/xacro\" name= \"stretch_description\" > <!--<xacro:include filename=\"stretch_gripper.xacro\" />--> <xacro:include filename= \"stretch_dry_erase_marker.xacro\" /> <xacro:include filename= \"stretch_main.xacro\" /> <xacro:include filename= \"stretch_aruco.xacro\" /> <xacro:include filename= \"stretch_d435i.xacro\" /> <xacro:include filename= \"stretch_laser_range_finder.xacro\" /> <xacro:include filename= \"stretch_respeaker.xacro\" /> </robot> Finally, we'll update our already calibrated URDF to use this new tool: $ cd ~/catkin_ws/src/stretch_ros/stretch_description/urdf $ cp stretch.urdf stretch.urdf.bak $ rosrun stretch_calibration update_urdf_after_xacro_change.sh Ctrl-C when the rosrun command terminates and you're ready to visualize the tool in RViz: $ roslaunch stretch_calibration simple_test_head_calibration.launch","title":"Changing Tool Interfaces in Stretch ROS"},{"location":"tool_change_tutorial/#advanced-topics","text":"","title":"Advanced Topics"},{"location":"tool_change_tutorial/#understanding-how-the-tool-plug-in-works","text":"For users looking to create their own custom tools it can be useful to understand how the tool plug-in architecture works. Here we will walk through the basics of the system for both Stretch Body and Stretch ROS","title":"Understanding How the Tool Plug-In Works"},{"location":"tool_change_tutorial/#stretch-body","text":"The Robot class expects an instance of EndOfArm tool to be present. The EndOfArm tool is an extension of the DynamixelXChain class, which manages a chain of Dynamixel servos. A tool is defined via its parameters (either in user YAML or Python). For example, the ToolStretchGripper is defined in robot_params.py . These parameters tell the plug-in which DynamixelHelloXL430 instances to load and manage. Here we see: \"tool_stretch_gripper\" : { 'use_group_sync_read' : 1 , 'retry_on_comm_failure' : 1 , 'baud' : 115200 , 'verbose' : 0 , 'py_class_name' : 'ToolStretchGripper' , 'py_module_name' : 'stretch_body.end_of_arm_tools' , 'stow' : { 'stretch_gripper' : 0 , 'wrist_yaw' : 3.4 }, 'devices' : { 'stretch_gripper' : { 'py_class_name' : 'StretchGripper' , 'py_module_name' : 'stretch_body.stretch_gripper' }, 'wrist_yaw' : { 'py_class_name' : 'WristYaw' , 'py_module_name' : 'stretch_body.wrist_yaw' } } }, This dictionary defines a tool of class ToolStretchGripper with two DynamixelHelloXL430 devices on its bus (StretchGripper and WristYaw). We see that the ToolStretchGripper class extends the EndOfArm class and provides its own stowing behavior: class ToolStretchGripper ( EndOfArm ): def __init__ ( self , name = 'tool_stretch_gripper' ): EndOfArm . __init__ ( self , name ) def stow ( self ): # Fold in wrist and gripper print ( '--------- Stowing Wrist Yaw ----' ) self . move_to ( 'wrist_yaw' , self . params [ 'stow' ][ 'wrist_yaw' ]) print ( '--------- Stowing Gripper ----' ) self . move_to ( 'stretch_gripper' , self . params [ 'stow' ][ 'stretch_gripper' ]) For tools that are not a part of Stretch Body, such as from the Tool Share, you must include the tool parameters as well in your stretch_re1_user_params.yaml . A robot that must support many tools may have user YAML that looks like: params : - stretch_tool_share.usbcam_wrist_v1.params - stretch_tool_share.stretch_dex_wrist_beta.params - stretch_tool_share.dry_erase_holder_v1.params robot : tool : tool_dry_erase_holder_v1 #tool: tool_none #tool: tool_stretch_gripper #tool: tool_usbcam_wrist_v1 #tool: tool_stretch_dex_wrist_beta For a more complex implementation of a tool we recommend reviewing the Stretch Dex Wrist implementation on the Stretch Tool Share.","title":"Stretch Body"},{"location":"tool_change_tutorial/#stretch-ros","text":"Stretch ROS also supports the tool plug-in architecture. Under ROS this is managed by extending the SimpleCommandGroup . More coming soon. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch ROS"},{"location":"troubleshooting_guide/","text":"Stretch RE1: Troubleshooting Guide This guide covers common issues and ways to resolve them. Please check the Hello Robot Forum for additional topics not covered here. XBox teleoperation is not working The provided Easy SMX wireless controller can accidentally be placed in the wrong mode. The mode is indicated by the round illuminated ring (shown as Connect below). The top 2 LEDs only should be illuminated. If a different LED pattern is shown then the button mapping expected by stretch_xbox_controller_teleop.py will be incorrect. To set the controller into the correct mode: Hold the center button down for 5s. It will switch modes. Release. Repeat until top half of ring (upper two lights) are illuminated. In addition, check that the provided USB dongle is plugged into the robot USB port in its trunk. . Battery is not staying charged Please review the troubleshooting section of the Battery Maintenance Guide . RPC Transport Errors (Stretch doesn't respond to commands) If more than one instance of Stretch Body's Robot class is instantiated at a time, Stretch Body will report communication errors and will not always execute motion commands as expected. This is because Robot manages communications with the robot hardware and it doesn't support multiple writes to the USB devices. These errors can appear as Transport RX Error on RPC_ACK_SEND_BLOCK_MORE False 0 102 ---- Debug Exception --------------- New RPC ------------------------- Framer sent RPC_START_NEW_RPC ... or as IOError(None): None ... To check if a instance of Robot is already instantiated, you may use the Unix top command to monitor active processes. You may use the Unix pkill command to end the background instance of Robot. $ pkill -9 python As shipped, Stretch launches stretch_xbox_controller_teleop.py upon boot. It is necessary to turn off this automatic launch feature, otherwise your own Robot instance will conflict with this script. Additionally, if you are logged into multiple accounts, a Robot instance may be active in another user account. To turn it off, search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop'. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch RE1: Troubleshooting Guide"},{"location":"troubleshooting_guide/#stretch-re1-troubleshooting-guide","text":"This guide covers common issues and ways to resolve them. Please check the Hello Robot Forum for additional topics not covered here.","title":"Stretch RE1: Troubleshooting Guide"},{"location":"troubleshooting_guide/#xbox-teleoperation-is-not-working","text":"The provided Easy SMX wireless controller can accidentally be placed in the wrong mode. The mode is indicated by the round illuminated ring (shown as Connect below). The top 2 LEDs only should be illuminated. If a different LED pattern is shown then the button mapping expected by stretch_xbox_controller_teleop.py will be incorrect. To set the controller into the correct mode: Hold the center button down for 5s. It will switch modes. Release. Repeat until top half of ring (upper two lights) are illuminated. In addition, check that the provided USB dongle is plugged into the robot USB port in its trunk. .","title":"XBox teleoperation is not working"},{"location":"troubleshooting_guide/#battery-is-not-staying-charged","text":"Please review the troubleshooting section of the Battery Maintenance Guide .","title":"Battery is not staying charged"},{"location":"troubleshooting_guide/#rpc-transport-errors-stretch-doesnt-respond-to-commands","text":"If more than one instance of Stretch Body's Robot class is instantiated at a time, Stretch Body will report communication errors and will not always execute motion commands as expected. This is because Robot manages communications with the robot hardware and it doesn't support multiple writes to the USB devices. These errors can appear as Transport RX Error on RPC_ACK_SEND_BLOCK_MORE False 0 102 ---- Debug Exception --------------- New RPC ------------------------- Framer sent RPC_START_NEW_RPC ... or as IOError(None): None ... To check if a instance of Robot is already instantiated, you may use the Unix top command to monitor active processes. You may use the Unix pkill command to end the background instance of Robot. $ pkill -9 python As shipped, Stretch launches stretch_xbox_controller_teleop.py upon boot. It is necessary to turn off this automatic launch feature, otherwise your own Robot instance will conflict with this script. Additionally, if you are logged into multiple accounts, a Robot instance may be active in another user account. To turn it off, search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop'. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"RPC Transport Errors (Stretch doesn't respond to commands)"},{"location":"untethered_operation/","text":"Untethered Operation As a mobile manipulator, the Stretch RE1 can only go so far when tethered to the monitor, keyboard, and mouse setup. This guide will explain three methods of setting up the Stretch RE1 for untethered usage. These methods typically require a wireless network, but it is possible to set up any of these methods without a wireless network by setting up a hotspot . Remote Desktop Requirements This is the recommended approach if you are running Windows or MacOS. This method requires a Virtual Network Computing (VNC) package. Using any of the free or paid options available for Windows, MacOS, and Chrome will be fine since they all use the Remote Frame Buffer (RFB) protocol to communicate with the robot. If you're using Ubuntu, Remmina Remote Desktop Client will be installed by default. How To While the Stretch RE1 is tethered to the monitor, keyboard, and mouse setup, first verify that the robot is connected to the wireless network then install Vino VNC server using the following command: $ sudo apt install vino Go to System Settings. Select the Sharing tab and turn it on then, turn on Screen Sharing and choose a password. If you plan to connect to the robot from a Windows or MacOS machine, then open a terminal and run the following command. $ sudo gsettings set org.gnome.Vino require-encryption false Finally, we need the robot's IP address, username, and password. Open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. The robot's default username and password is printed on papers that came in the tools box alongside the robot. VNC will only function properly with an external display attached to the robot. Using a dummy HDMI dongle when operating the robot untethered via VNC is recommended. One possible dummy HDMI dongle can be found on Amazon here . On your computer, connect to the same wireless network as the robot and open the VNC package being used. Using the robot's IP address and username, initialize a new connection to the robot. The robot's desktop will open in a new window. SSH & X Server Requirements This is the recommended approach if you are running an Unix-based operating system, like Ubuntu or Arch Linux. This method requires both SSH and X Server to be installed. While most Unix-based operating systems have both installed by default, MacOS will only have SSH installed and Windows has neither installed by default. It is possible to install these tools for MacOS or Windows. How To While the Remote Desktop approach is easy to set up, graphics and interaction with the remote desktop is often slow. In this method, we will use SSH and X Server to accomplish the same a bit faster. SSH stands for Secure Shell, enabling one to remotely use the terminal (shell) of another machine. X Server is used on many Unix variants to render the Windowed GUI of applications. With SSH and X Server, it is possible to render a Windowed GUI of an application running on the robot on your computer's screen. The first step is to identify the robot's IP address on the local network. While the Stretch RE1 is tethered to the monitor, keyboard, and mouse, verify that the robot is connected to a wireless network. Then, open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. Using any other machine on the same local network, I can SSH into the robot using this IP address. Take note of the username and password of the robot. The default combo is printed on papers that came in the tools box alongside the robot. To SSH into the robot, run the following. It will require the password and may ask you to add the robot to the known hosts. $ ssh -X username@ip-address Now that you're SSH-ed into the robot, you can disconnect any wires from the robot. You can accomplish any of the same tasks through the terminal. For example, you can type in ipython and interact with the robot using Stretch Body, as explained in the Getting Started Guide . Furthermore, Windowed GUI applications that would have displayed on the monitor will now display on your SSH-ed machine. For example, we can open Rviz to visualize what the robot is seeing. Open two terminals and SSH into the robot as explained above. In the first, run roslaunch stretch_core stretch_driver.launch . You should see some information print out in the terminal. In the second, run rviz . A window will pop up and information about the robot can be visualized by clicking on Add -> RobotModel and Add -> By Topic -> /Scan . Additional information on how to use ROS tools can be found in ROS's tutorials or in our Stretch ROS guides . Moving files to/from the robot wirelessly It's common to need to move files to/from the robot wirelessly and a tool similar to SSH can help with this: Secure Copy (SCP). To send the files from your computer to the robot, run: $ scp ./filename username@ip-address:~/path/to/put/it/ To copy the files from the robot to your computer, run the reverse: $ scp username@ip-address:/path/to/filename ~/path/to/put/it/ This works for copying directories and their contents as well. ROS Remote Master Requirements This is the recommended approach if you are running Ubuntu 16.04/18.04/20.04 with ROS kinetic/melodic/noetic installed on your computer. This method will utilize the local installation of ROS tools, such as Rviz, rostopic, and rosservice, while retrieving data from the robot. How To If you are developing ROS code to test on the Stretch RE1 and you already have ROS installed on your Ubuntu computer, then there is an easier way of using Rviz than the method described in SSH & X Server . In the ROS world, this concept is known as \"remote master\". First, identify your robot's and computer's IP address on the network (e.g. using ifconfig ). These are robot-ip-address and computer-ip-address respectively. Next, run the following on the robot: $ export ROS_IP = robot-ip-address $ export ROS_MASTER_URI = http://robot-ip-address:11311/ Next, start the ROS launch files on the robot as you normally would. Finally, on your computer, run: $ export ROS_IP = computer-ip-address $ export ROS_MASTER_URI = http://robot-ip-address:11311 If you use ROS Remote Master often, you can export these environment variables in your bashrc . Tools like rostopic and rosservice can now be used on your computer as you would have on the robot. For example, you can use rostopic list on your computer to print out the topics available on the robot. Additional information can be found in the ROS Multiple Machines Tutorial . Visualizing remotely with RViz If you'd like to visualize the robot model on your computer using Rviz, you'll need to setup a ROS workspace with the Stretch Description package. First, copy over the ~/stretch_user directory from the robot to your computer (e.g. using Secure Copy ). Second, clone Stretch Install , and checkout the noetic branch if you are running ROS Noetic on the robot. Finally, run the stretch_create_ros_workspace.sh script. A ROS Workspace with the Stretch ROS packages is now set up on your computer. Furthermore, Stretch Description has been set up with your robot's calibrated URDF. We can now use remote master and Rviz to visualize what the robot is seeing on your computer. Open two terminals. In the first, SSH into the robot and run roslaunch stretch_core stretch_driver.launch . You should see some information print out in the terminal. In the second, run rviz . A window will pop up and information about the robot can be visualized by clicking on Add -> RobotModel and Add -> By Topic -> /Scan . Additional information on how to use Rviz can be found in ROS's tutorials or in our Stretch ROS guides . Additional Ideas Although the methods described above will enable you to wirelessly control the robot, there are a number of way to improve usability and security of your wireless connection. These ideas are listed here. Hotspot Often the trouble with wirelessly controlling the robot is the network. If your network is using industrial security like 2-factor authentication, there may be trouble connecting the robot to the network. If the network is servicing a large number of users, the connection may feel sluggish. The alternative is to skip the network by connecting directly to the robot. After starting a hotspot on the robot, you can follow instructions for any of the methods described above to control the robot. The trade-off is that while connected to the robot's hotspot, you will be unable to connect to the internet. To set up the robot's hotspot, visit the Ubuntu Wifi Settings page in the robot. Click on the hamburger menu in the top right and select \"Enable hotspot\". From your local machine, connect to the robot's hotspot and save the credentials. To change the hotspot's password or enable the hotspot automatically whenever the robot boots, see the following Stackoverflow post . VS Code Remote Development It is possible to simultaneously develop code on the robot while running wireless experiments using the Remote Development Extension provided by the VS Code IDE. If you're already using the VS Code IDE , navigate to the Extensions tab and search for Remote Development Extension by Microsoft . After installing, click on a green button in the bottom left of the screen and then select \"Remote-SSH: Connect to Host\". Setting this up for the first time will require you to know the robot's IP address and username. Add a new host with the information. While connecting, VS Code will ask you for the password of the robot. Once you are connected, you can open any folder and edit the code remotely. Combined with the method explained in SSH & X Server , this is a powerful method of iteratively developing code while testing it. Static IP Address Routers that serve wireless networks often dynamically assign IP address to machines that connect to the network. This means that your robot's IP address may have changed since the last time you turned it on. Since it becomes a pain to connect to the monitor, keyboard, and mouse setup every time to run ifconfig , many users prefer to assign the robot a static IP address. If you control the router, visit the router's settings page to set up the robot's static IP address. It is common at universities and companies to have staff dedicated to the management of the network. This staff will often be able to set up a static IP address for the robot. Public Key Authentication The method of SSH described in SSH & X Server uses basic password authentication when connecting. There is a better and more-secure method of SSH-ing into the robot called Public Key Authentication. This method will allow multiple developers to SSH into the robot without having to share the robot's admin password. The first step is to generate public and private keys on your computer. Linux and MacOS machines can simply open the terminal and run: $ ssh-keygen -t ed25519 -f <key_filepath_without_extension> -C \"<some comment>\" It will prompt you to enter a password. If you do, you'll need it to use the private key when you SSH into the robot. Next, we give the robot the public key. Linux and MacOS machines can run: $ ssh-copy-id -i <key_filepath_without_extension> username@ip-address This requires you to know the username and ip-address of the robot. Instructions on how to find this information is found in the SSH & X Server section. You may now SSH into the robot as normal, and no prompt for the robot's password will appear. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Untethered Operation"},{"location":"untethered_operation/#untethered-operation","text":"As a mobile manipulator, the Stretch RE1 can only go so far when tethered to the monitor, keyboard, and mouse setup. This guide will explain three methods of setting up the Stretch RE1 for untethered usage. These methods typically require a wireless network, but it is possible to set up any of these methods without a wireless network by setting up a hotspot .","title":"Untethered Operation"},{"location":"untethered_operation/#remote-desktop","text":"","title":"Remote Desktop"},{"location":"untethered_operation/#requirements","text":"This is the recommended approach if you are running Windows or MacOS. This method requires a Virtual Network Computing (VNC) package. Using any of the free or paid options available for Windows, MacOS, and Chrome will be fine since they all use the Remote Frame Buffer (RFB) protocol to communicate with the robot. If you're using Ubuntu, Remmina Remote Desktop Client will be installed by default.","title":"Requirements"},{"location":"untethered_operation/#how-to","text":"While the Stretch RE1 is tethered to the monitor, keyboard, and mouse setup, first verify that the robot is connected to the wireless network then install Vino VNC server using the following command: $ sudo apt install vino Go to System Settings. Select the Sharing tab and turn it on then, turn on Screen Sharing and choose a password. If you plan to connect to the robot from a Windows or MacOS machine, then open a terminal and run the following command. $ sudo gsettings set org.gnome.Vino require-encryption false Finally, we need the robot's IP address, username, and password. Open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. The robot's default username and password is printed on papers that came in the tools box alongside the robot. VNC will only function properly with an external display attached to the robot. Using a dummy HDMI dongle when operating the robot untethered via VNC is recommended. One possible dummy HDMI dongle can be found on Amazon here . On your computer, connect to the same wireless network as the robot and open the VNC package being used. Using the robot's IP address and username, initialize a new connection to the robot. The robot's desktop will open in a new window.","title":"How To"},{"location":"untethered_operation/#ssh-x-server","text":"","title":"SSH &amp; X Server"},{"location":"untethered_operation/#requirements_1","text":"This is the recommended approach if you are running an Unix-based operating system, like Ubuntu or Arch Linux. This method requires both SSH and X Server to be installed. While most Unix-based operating systems have both installed by default, MacOS will only have SSH installed and Windows has neither installed by default. It is possible to install these tools for MacOS or Windows.","title":"Requirements"},{"location":"untethered_operation/#how-to_1","text":"While the Remote Desktop approach is easy to set up, graphics and interaction with the remote desktop is often slow. In this method, we will use SSH and X Server to accomplish the same a bit faster. SSH stands for Secure Shell, enabling one to remotely use the terminal (shell) of another machine. X Server is used on many Unix variants to render the Windowed GUI of applications. With SSH and X Server, it is possible to render a Windowed GUI of an application running on the robot on your computer's screen. The first step is to identify the robot's IP address on the local network. While the Stretch RE1 is tethered to the monitor, keyboard, and mouse, verify that the robot is connected to a wireless network. Then, open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. Using any other machine on the same local network, I can SSH into the robot using this IP address. Take note of the username and password of the robot. The default combo is printed on papers that came in the tools box alongside the robot. To SSH into the robot, run the following. It will require the password and may ask you to add the robot to the known hosts. $ ssh -X username@ip-address Now that you're SSH-ed into the robot, you can disconnect any wires from the robot. You can accomplish any of the same tasks through the terminal. For example, you can type in ipython and interact with the robot using Stretch Body, as explained in the Getting Started Guide . Furthermore, Windowed GUI applications that would have displayed on the monitor will now display on your SSH-ed machine. For example, we can open Rviz to visualize what the robot is seeing. Open two terminals and SSH into the robot as explained above. In the first, run roslaunch stretch_core stretch_driver.launch . You should see some information print out in the terminal. In the second, run rviz . A window will pop up and information about the robot can be visualized by clicking on Add -> RobotModel and Add -> By Topic -> /Scan . Additional information on how to use ROS tools can be found in ROS's tutorials or in our Stretch ROS guides .","title":"How To"},{"location":"untethered_operation/#moving-files-tofrom-the-robot-wirelessly","text":"It's common to need to move files to/from the robot wirelessly and a tool similar to SSH can help with this: Secure Copy (SCP). To send the files from your computer to the robot, run: $ scp ./filename username@ip-address:~/path/to/put/it/ To copy the files from the robot to your computer, run the reverse: $ scp username@ip-address:/path/to/filename ~/path/to/put/it/ This works for copying directories and their contents as well.","title":"Moving files to/from the robot wirelessly"},{"location":"untethered_operation/#ros-remote-master","text":"","title":"ROS Remote Master"},{"location":"untethered_operation/#requirements_2","text":"This is the recommended approach if you are running Ubuntu 16.04/18.04/20.04 with ROS kinetic/melodic/noetic installed on your computer. This method will utilize the local installation of ROS tools, such as Rviz, rostopic, and rosservice, while retrieving data from the robot.","title":"Requirements"},{"location":"untethered_operation/#how-to_2","text":"If you are developing ROS code to test on the Stretch RE1 and you already have ROS installed on your Ubuntu computer, then there is an easier way of using Rviz than the method described in SSH & X Server . In the ROS world, this concept is known as \"remote master\". First, identify your robot's and computer's IP address on the network (e.g. using ifconfig ). These are robot-ip-address and computer-ip-address respectively. Next, run the following on the robot: $ export ROS_IP = robot-ip-address $ export ROS_MASTER_URI = http://robot-ip-address:11311/ Next, start the ROS launch files on the robot as you normally would. Finally, on your computer, run: $ export ROS_IP = computer-ip-address $ export ROS_MASTER_URI = http://robot-ip-address:11311 If you use ROS Remote Master often, you can export these environment variables in your bashrc . Tools like rostopic and rosservice can now be used on your computer as you would have on the robot. For example, you can use rostopic list on your computer to print out the topics available on the robot. Additional information can be found in the ROS Multiple Machines Tutorial .","title":"How To"},{"location":"untethered_operation/#visualizing-remotely-with-rviz","text":"If you'd like to visualize the robot model on your computer using Rviz, you'll need to setup a ROS workspace with the Stretch Description package. First, copy over the ~/stretch_user directory from the robot to your computer (e.g. using Secure Copy ). Second, clone Stretch Install , and checkout the noetic branch if you are running ROS Noetic on the robot. Finally, run the stretch_create_ros_workspace.sh script. A ROS Workspace with the Stretch ROS packages is now set up on your computer. Furthermore, Stretch Description has been set up with your robot's calibrated URDF. We can now use remote master and Rviz to visualize what the robot is seeing on your computer. Open two terminals. In the first, SSH into the robot and run roslaunch stretch_core stretch_driver.launch . You should see some information print out in the terminal. In the second, run rviz . A window will pop up and information about the robot can be visualized by clicking on Add -> RobotModel and Add -> By Topic -> /Scan . Additional information on how to use Rviz can be found in ROS's tutorials or in our Stretch ROS guides .","title":"Visualizing remotely with RViz"},{"location":"untethered_operation/#additional-ideas","text":"Although the methods described above will enable you to wirelessly control the robot, there are a number of way to improve usability and security of your wireless connection. These ideas are listed here.","title":"Additional Ideas"},{"location":"untethered_operation/#hotspot","text":"Often the trouble with wirelessly controlling the robot is the network. If your network is using industrial security like 2-factor authentication, there may be trouble connecting the robot to the network. If the network is servicing a large number of users, the connection may feel sluggish. The alternative is to skip the network by connecting directly to the robot. After starting a hotspot on the robot, you can follow instructions for any of the methods described above to control the robot. The trade-off is that while connected to the robot's hotspot, you will be unable to connect to the internet. To set up the robot's hotspot, visit the Ubuntu Wifi Settings page in the robot. Click on the hamburger menu in the top right and select \"Enable hotspot\". From your local machine, connect to the robot's hotspot and save the credentials. To change the hotspot's password or enable the hotspot automatically whenever the robot boots, see the following Stackoverflow post .","title":"Hotspot"},{"location":"untethered_operation/#vs-code-remote-development","text":"It is possible to simultaneously develop code on the robot while running wireless experiments using the Remote Development Extension provided by the VS Code IDE. If you're already using the VS Code IDE , navigate to the Extensions tab and search for Remote Development Extension by Microsoft . After installing, click on a green button in the bottom left of the screen and then select \"Remote-SSH: Connect to Host\". Setting this up for the first time will require you to know the robot's IP address and username. Add a new host with the information. While connecting, VS Code will ask you for the password of the robot. Once you are connected, you can open any folder and edit the code remotely. Combined with the method explained in SSH & X Server , this is a powerful method of iteratively developing code while testing it.","title":"VS Code Remote Development"},{"location":"untethered_operation/#static-ip-address","text":"Routers that serve wireless networks often dynamically assign IP address to machines that connect to the network. This means that your robot's IP address may have changed since the last time you turned it on. Since it becomes a pain to connect to the monitor, keyboard, and mouse setup every time to run ifconfig , many users prefer to assign the robot a static IP address. If you control the router, visit the router's settings page to set up the robot's static IP address. It is common at universities and companies to have staff dedicated to the management of the network. This staff will often be able to set up a static IP address for the robot.","title":"Static IP Address"},{"location":"untethered_operation/#public-key-authentication","text":"The method of SSH described in SSH & X Server uses basic password authentication when connecting. There is a better and more-secure method of SSH-ing into the robot called Public Key Authentication. This method will allow multiple developers to SSH into the robot without having to share the robot's admin password. The first step is to generate public and private keys on your computer. Linux and MacOS machines can simply open the terminal and run: $ ssh-keygen -t ed25519 -f <key_filepath_without_extension> -C \"<some comment>\" It will prompt you to enter a password. If you do, you'll need it to use the private key when you SSH into the robot. Next, we give the robot the public key. Linux and MacOS machines can run: $ ssh-copy-id -i <key_filepath_without_extension> username@ip-address This requires you to know the username and ip-address of the robot. Instructions on how to find this information is found in the SSH & X Server section. You may now SSH into the robot as normal, and no prompt for the robot's password will appear. All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Public Key Authentication"},{"location":"updating_software/","text":"Updating Stretch Software Stretch's software is improved with new features and bug fixes with each update. In this guide, we cover when and how to update the various software components on your Stretch RE1. When to Update We develop our software publicly on Github, allowing anyone to follow/propose the development of a code feature or bug fix. While we wholeheartedly welcome collaboration on Github, it is not necessary to be active on Github to follow our software releases. We announce every major release of software on our forum . These are stable releases with code that has been extensively tested on many Stretch RE1s. To be notified of new releases, create an account on the forum and click the bell icon in the top left of the announcements section . The forum is also available to report issues and ask questions about any of our software packages. How to Update Each Stretch RE1 is shipped with firmware, a Python SDK, and ROS packages developed specifically for Stretch. At the moment, there are three separate processes for updating each of these components. Stretch ROS Stretch ROS is the Robot Operating System (ROS) interface to the robot. Many robotics developers find ROS useful to bootstrap their robotics software developments. You may update it using the following commands: $ roscd stretch_core $ git pull Stretch Body Stretch Body is the Python SDK to the robot. It abstracts away the low level details of communication with the embedded devices and provides an intuitive API to working with the robot. You may update it using the following commands: $ pip install -U hello-robot-stretch-body $ pip install -U hello-robot-stretch-body-tools $ pip install -U hello-robot-stretch-factory $ pip3 install -U hello_robot_stretch_body_tools_py3 Stretch Firmware The firmware and the Python SDK (called Stretch Body) communicate on an established protocol. Therefore, it is important to maintain a protocol match between the different firmware and Stretch Body versions. Fortunately, there is a script that handles this automatically. In the command line, run the following command: $ RE1_firmware_updater.py --status This script will automatically determine what version is currently running on the robot and provide a recommendation for a next step. Follow the next steps provided by the firmware updater script. Ubuntu The operating system upon which Stretch RE1 is built is called Ubuntu. This operating system provides the underlying packages that power Stretch's software packages. Furthermore, users of Stretch depend on this operating system and the underlying packages to develop software on Stretch. Therefore, it is important to keep the OS and these underlying packages up to date. In the command line, run the following command: $ sudo apt update $ sudo apt upgrade Apt is the package manager that handles updates for all Ubuntu packages. Troubleshooting Firmware Mismatch Error When working with Stretch Body, if you see the following error: ---------------- Firmware protocol mismatch on /dev/XXXX. Protocol on board is pX. Valid protocol is: pX. Disabling device. Please upgrade the firmware and/or version of Stretch Body. ---------------- This error appears because the low level Python SDK and the firmware cannot communicate to each other. There is a protocol mismatch preventing communication between the two. Simply run the following script and follow its recommendations to upgrade/downgrade the firmware as necessary to match the protocol level of Stretch Body. $ RE1_firmware_updater.py --status All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Updating Stretch Software"},{"location":"updating_software/#updating-stretch-software","text":"Stretch's software is improved with new features and bug fixes with each update. In this guide, we cover when and how to update the various software components on your Stretch RE1.","title":"Updating Stretch Software"},{"location":"updating_software/#when-to-update","text":"We develop our software publicly on Github, allowing anyone to follow/propose the development of a code feature or bug fix. While we wholeheartedly welcome collaboration on Github, it is not necessary to be active on Github to follow our software releases. We announce every major release of software on our forum . These are stable releases with code that has been extensively tested on many Stretch RE1s. To be notified of new releases, create an account on the forum and click the bell icon in the top left of the announcements section . The forum is also available to report issues and ask questions about any of our software packages.","title":"When to Update"},{"location":"updating_software/#how-to-update","text":"Each Stretch RE1 is shipped with firmware, a Python SDK, and ROS packages developed specifically for Stretch. At the moment, there are three separate processes for updating each of these components.","title":"How to Update"},{"location":"updating_software/#stretch-ros","text":"Stretch ROS is the Robot Operating System (ROS) interface to the robot. Many robotics developers find ROS useful to bootstrap their robotics software developments. You may update it using the following commands: $ roscd stretch_core $ git pull","title":"Stretch ROS"},{"location":"updating_software/#stretch-body","text":"Stretch Body is the Python SDK to the robot. It abstracts away the low level details of communication with the embedded devices and provides an intuitive API to working with the robot. You may update it using the following commands: $ pip install -U hello-robot-stretch-body $ pip install -U hello-robot-stretch-body-tools $ pip install -U hello-robot-stretch-factory $ pip3 install -U hello_robot_stretch_body_tools_py3","title":"Stretch Body"},{"location":"updating_software/#stretch-firmware","text":"The firmware and the Python SDK (called Stretch Body) communicate on an established protocol. Therefore, it is important to maintain a protocol match between the different firmware and Stretch Body versions. Fortunately, there is a script that handles this automatically. In the command line, run the following command: $ RE1_firmware_updater.py --status This script will automatically determine what version is currently running on the robot and provide a recommendation for a next step. Follow the next steps provided by the firmware updater script.","title":"Stretch Firmware"},{"location":"updating_software/#ubuntu","text":"The operating system upon which Stretch RE1 is built is called Ubuntu. This operating system provides the underlying packages that power Stretch's software packages. Furthermore, users of Stretch depend on this operating system and the underlying packages to develop software on Stretch. Therefore, it is important to keep the OS and these underlying packages up to date. In the command line, run the following command: $ sudo apt update $ sudo apt upgrade Apt is the package manager that handles updates for all Ubuntu packages.","title":"Ubuntu"},{"location":"updating_software/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"updating_software/#firmware-mismatch-error","text":"When working with Stretch Body, if you see the following error: ---------------- Firmware protocol mismatch on /dev/XXXX. Protocol on board is pX. Valid protocol is: pX. Disabling device. Please upgrade the firmware and/or version of Stretch Body. ---------------- This error appears because the low level Python SDK and the firmware cannot communicate to each other. There is a protocol mismatch preventing communication between the two. Simply run the following script and follow its recommendations to upgrade/downgrade the firmware as necessary to match the protocol level of Stretch Body. $ RE1_firmware_updater.py --status All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Firmware Mismatch Error"}]}